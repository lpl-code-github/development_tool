{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { resolveDirective as _resolveDirective, createVNode as _createVNode } from \"vue\";\nimport { useRafState } from '../hooks/useRaf';\nimport TabNode from './TabNode';\nimport useOffsets from '../hooks/useOffsets';\nimport OperationNode from './OperationNode';\nimport { useInjectTabs } from '../TabContext';\nimport useTouchMove from '../hooks/useTouchMove';\nimport AddButton from './AddButton';\nimport { objectType, functionType } from '../../../_util/type';\nimport { shallowRef, onBeforeUnmount, defineComponent, watch, watchEffect, computed } from 'vue';\nimport PropTypes from '../../../_util/vue-types';\nimport useSyncState from '../hooks/useSyncState';\nimport useState from '../../../_util/hooks/useState';\nimport raf from '../../../_util/raf';\nimport classNames from '../../../_util/classNames';\nimport ResizeObserver from '../../../vc-resize-observer';\nimport { toPx } from '../../../_util/util';\nimport useRefs from '../../../_util/hooks/useRefs';\nimport pick from 'lodash-es/pick';\nconst DEFAULT_SIZE = {\n  width: 0,\n  height: 0,\n  left: 0,\n  top: 0,\n  right: 0\n};\nexport const tabNavListProps = () => {\n  return {\n    id: {\n      type: String\n    },\n    tabPosition: {\n      type: String\n    },\n    activeKey: {\n      type: [String, Number]\n    },\n    rtl: {\n      type: Boolean\n    },\n    animated: objectType(),\n    editable: objectType(),\n    moreIcon: PropTypes.any,\n    moreTransitionName: {\n      type: String\n    },\n    mobile: {\n      type: Boolean\n    },\n    tabBarGutter: {\n      type: Number\n    },\n    renderTabBar: {\n      type: Function\n    },\n    locale: objectType(),\n    popupClassName: String,\n    getPopupContainer: functionType(),\n    onTabClick: {\n      type: Function\n    },\n    onTabScroll: {\n      type: Function\n    }\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'TabNavList',\n  inheritAttrs: false,\n  props: tabNavListProps(),\n  slots: Object,\n  emits: ['tabClick', 'tabScroll'],\n  setup(props, _ref) {\n    let {\n      attrs,\n      slots\n    } = _ref;\n    const {\n      tabs,\n      prefixCls\n    } = useInjectTabs();\n    const tabsWrapperRef = shallowRef();\n    const tabListRef = shallowRef();\n    const operationsRef = shallowRef();\n    const innerAddButtonRef = shallowRef();\n    const [setRef, btnRefs] = useRefs();\n    const tabPositionTopOrBottom = computed(() => props.tabPosition === 'top' || props.tabPosition === 'bottom');\n    const [transformLeft, setTransformLeft] = useSyncState(0, (next, prev) => {\n      if (tabPositionTopOrBottom.value && props.onTabScroll) {\n        props.onTabScroll({\n          direction: next > prev ? 'left' : 'right'\n        });\n      }\n    });\n    const [transformTop, setTransformTop] = useSyncState(0, (next, prev) => {\n      if (!tabPositionTopOrBottom.value && props.onTabScroll) {\n        props.onTabScroll({\n          direction: next > prev ? 'top' : 'bottom'\n        });\n      }\n    });\n    const [wrapperScrollWidth, setWrapperScrollWidth] = useState(0);\n    const [wrapperScrollHeight, setWrapperScrollHeight] = useState(0);\n    const [wrapperWidth, setWrapperWidth] = useState(null);\n    const [wrapperHeight, setWrapperHeight] = useState(null);\n    const [addWidth, setAddWidth] = useState(0);\n    const [addHeight, setAddHeight] = useState(0);\n    const [tabSizes, setTabSizes] = useRafState(new Map());\n    const tabOffsets = useOffsets(tabs, tabSizes);\n    // ========================== Util =========================\n    const operationsHiddenClassName = computed(() => `${prefixCls.value}-nav-operations-hidden`);\n    const transformMin = shallowRef(0);\n    const transformMax = shallowRef(0);\n    watchEffect(() => {\n      if (!tabPositionTopOrBottom.value) {\n        transformMin.value = Math.min(0, wrapperHeight.value - wrapperScrollHeight.value);\n        transformMax.value = 0;\n      } else if (props.rtl) {\n        transformMin.value = 0;\n        transformMax.value = Math.max(0, wrapperScrollWidth.value - wrapperWidth.value);\n      } else {\n        transformMin.value = Math.min(0, wrapperWidth.value - wrapperScrollWidth.value);\n        transformMax.value = 0;\n      }\n    });\n    const alignInRange = value => {\n      if (value < transformMin.value) {\n        return transformMin.value;\n      }\n      if (value > transformMax.value) {\n        return transformMax.value;\n      }\n      return value;\n    };\n    // ========================= Mobile ========================\n    const touchMovingRef = shallowRef();\n    const [lockAnimation, setLockAnimation] = useState();\n    const doLockAnimation = () => {\n      setLockAnimation(Date.now());\n    };\n    const clearTouchMoving = () => {\n      clearTimeout(touchMovingRef.value);\n    };\n    const doMove = (setState, offset) => {\n      setState(value => {\n        const newValue = alignInRange(value + offset);\n        return newValue;\n      });\n    };\n    useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {\n      if (tabPositionTopOrBottom.value) {\n        // Skip scroll if place is enough\n        if (wrapperWidth.value >= wrapperScrollWidth.value) {\n          return false;\n        }\n        doMove(setTransformLeft, offsetX);\n      } else {\n        if (wrapperHeight.value >= wrapperScrollHeight.value) {\n          return false;\n        }\n        doMove(setTransformTop, offsetY);\n      }\n      clearTouchMoving();\n      doLockAnimation();\n      return true;\n    });\n    watch(lockAnimation, () => {\n      clearTouchMoving();\n      if (lockAnimation.value) {\n        touchMovingRef.value = setTimeout(() => {\n          setLockAnimation(0);\n        }, 100);\n      }\n    });\n    // ========================= Scroll ========================\n    const scrollToTab = function () {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : props.activeKey;\n      const tabOffset = tabOffsets.value.get(key) || {\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0\n      };\n      if (tabPositionTopOrBottom.value) {\n        // ============ Align with top & bottom ============\n        let newTransform = transformLeft.value;\n        // RTL\n        if (props.rtl) {\n          if (tabOffset.right < transformLeft.value) {\n            newTransform = tabOffset.right;\n          } else if (tabOffset.right + tabOffset.width > transformLeft.value + wrapperWidth.value) {\n            newTransform = tabOffset.right + tabOffset.width - wrapperWidth.value;\n          }\n        }\n        // LTR\n        else if (tabOffset.left < -transformLeft.value) {\n          newTransform = -tabOffset.left;\n        } else if (tabOffset.left + tabOffset.width > -transformLeft.value + wrapperWidth.value) {\n          newTransform = -(tabOffset.left + tabOffset.width - wrapperWidth.value);\n        }\n        setTransformTop(0);\n        setTransformLeft(alignInRange(newTransform));\n      } else {\n        // ============ Align with left & right ============\n        let newTransform = transformTop.value;\n        if (tabOffset.top < -transformTop.value) {\n          newTransform = -tabOffset.top;\n        } else if (tabOffset.top + tabOffset.height > -transformTop.value + wrapperHeight.value) {\n          newTransform = -(tabOffset.top + tabOffset.height - wrapperHeight.value);\n        }\n        setTransformLeft(0);\n        setTransformTop(alignInRange(newTransform));\n      }\n    };\n    const visibleStart = shallowRef(0);\n    const visibleEnd = shallowRef(0);\n    watchEffect(() => {\n      let unit;\n      let position;\n      let transformSize;\n      let basicSize;\n      let tabContentSize;\n      let addSize;\n      const tabOffsetsValue = tabOffsets.value;\n      if (['top', 'bottom'].includes(props.tabPosition)) {\n        unit = 'width';\n        basicSize = wrapperWidth.value;\n        tabContentSize = wrapperScrollWidth.value;\n        addSize = addWidth.value;\n        position = props.rtl ? 'right' : 'left';\n        transformSize = Math.abs(transformLeft.value);\n      } else {\n        unit = 'height';\n        basicSize = wrapperHeight.value;\n        tabContentSize = wrapperScrollWidth.value;\n        addSize = addHeight.value;\n        position = 'top';\n        transformSize = -transformTop.value;\n      }\n      let mergedBasicSize = basicSize;\n      if (tabContentSize + addSize > basicSize && tabContentSize < basicSize) {\n        mergedBasicSize = basicSize - addSize;\n      }\n      const tabsVal = tabs.value;\n      if (!tabsVal.length) {\n        return [visibleStart.value, visibleEnd.value] = [0, 0];\n      }\n      const len = tabsVal.length;\n      let endIndex = len;\n      for (let i = 0; i < len; i += 1) {\n        const offset = tabOffsetsValue.get(tabsVal[i].key) || DEFAULT_SIZE;\n        if (offset[position] + offset[unit] > transformSize + mergedBasicSize) {\n          endIndex = i - 1;\n          break;\n        }\n      }\n      let startIndex = 0;\n      for (let i = len - 1; i >= 0; i -= 1) {\n        const offset = tabOffsetsValue.get(tabsVal[i].key) || DEFAULT_SIZE;\n        if (offset[position] < transformSize) {\n          startIndex = i + 1;\n          break;\n        }\n      }\n      return [visibleStart.value, visibleEnd.value] = [startIndex, endIndex];\n    });\n    const onListHolderResize = () => {\n      var _a, _b, _c, _d, _e;\n      // Update wrapper records\n      const offsetWidth = ((_a = tabsWrapperRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth) || 0;\n      const offsetHeight = ((_b = tabsWrapperRef.value) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;\n      const addDom = ((_c = innerAddButtonRef.value) === null || _c === void 0 ? void 0 : _c.$el) || {};\n      const newAddWidth = addDom.offsetWidth || 0;\n      const newAddHeight = addDom.offsetHeight || 0;\n      setWrapperWidth(offsetWidth);\n      setWrapperHeight(offsetHeight);\n      setAddWidth(newAddWidth);\n      setAddHeight(newAddHeight);\n      const newWrapperScrollWidth = (((_d = tabListRef.value) === null || _d === void 0 ? void 0 : _d.offsetWidth) || 0) - newAddWidth;\n      const newWrapperScrollHeight = (((_e = tabListRef.value) === null || _e === void 0 ? void 0 : _e.offsetHeight) || 0) - newAddHeight;\n      setWrapperScrollWidth(newWrapperScrollWidth);\n      setWrapperScrollHeight(newWrapperScrollHeight);\n      // Update buttons records\n      setTabSizes(() => {\n        const newSizes = new Map();\n        tabs.value.forEach(_ref2 => {\n          let {\n            key\n          } = _ref2;\n          const btnRef = btnRefs.value.get(key);\n          const btnNode = (btnRef === null || btnRef === void 0 ? void 0 : btnRef.$el) || btnRef;\n          if (btnNode) {\n            newSizes.set(key, {\n              width: btnNode.offsetWidth,\n              height: btnNode.offsetHeight,\n              left: btnNode.offsetLeft,\n              top: btnNode.offsetTop\n            });\n          }\n        });\n        return newSizes;\n      });\n    };\n    // ======================== Dropdown =======================\n    const hiddenTabs = computed(() => [...tabs.value.slice(0, visibleStart.value), ...tabs.value.slice(visibleEnd.value + 1)]);\n    // =================== Link & Operations ===================\n    const [inkStyle, setInkStyle] = useState();\n    const activeTabOffset = computed(() => tabOffsets.value.get(props.activeKey));\n    // Delay set ink style to avoid remove tab blink\n    const inkBarRafRef = shallowRef();\n    const cleanInkBarRaf = () => {\n      raf.cancel(inkBarRafRef.value);\n    };\n    watch([activeTabOffset, tabPositionTopOrBottom, () => props.rtl], () => {\n      const newInkStyle = {};\n      if (activeTabOffset.value) {\n        if (tabPositionTopOrBottom.value) {\n          if (props.rtl) {\n            newInkStyle.right = toPx(activeTabOffset.value.right);\n          } else {\n            newInkStyle.left = toPx(activeTabOffset.value.left);\n          }\n          newInkStyle.width = toPx(activeTabOffset.value.width);\n        } else {\n          newInkStyle.top = toPx(activeTabOffset.value.top);\n          newInkStyle.height = toPx(activeTabOffset.value.height);\n        }\n      }\n      cleanInkBarRaf();\n      inkBarRafRef.value = raf(() => {\n        setInkStyle(newInkStyle);\n      });\n    });\n    watch([() => props.activeKey, activeTabOffset, tabOffsets, tabPositionTopOrBottom], () => {\n      scrollToTab();\n    }, {\n      flush: 'post'\n    });\n    watch([() => props.rtl, () => props.tabBarGutter, () => props.activeKey, () => tabs.value], () => {\n      onListHolderResize();\n    }, {\n      flush: 'post'\n    });\n    const ExtraContent = _ref3 => {\n      let {\n        position,\n        prefixCls,\n        extra\n      } = _ref3;\n      if (!extra) return null;\n      const content = extra === null || extra === void 0 ? void 0 : extra({\n        position\n      });\n      return content ? _createVNode(\"div\", {\n        \"class\": `${prefixCls}-extra-content`\n      }, [content]) : null;\n    };\n    onBeforeUnmount(() => {\n      clearTouchMoving();\n      cleanInkBarRaf();\n    });\n    return () => {\n      const {\n        id,\n        animated,\n        activeKey,\n        rtl,\n        editable,\n        locale,\n        tabPosition,\n        tabBarGutter,\n        onTabClick\n      } = props;\n      const {\n        class: className,\n        style\n      } = attrs;\n      const pre = prefixCls.value;\n      // ========================= Render ========================\n      const hasDropdown = !!hiddenTabs.value.length;\n      const wrapPrefix = `${pre}-nav-wrap`;\n      let pingLeft;\n      let pingRight;\n      let pingTop;\n      let pingBottom;\n      if (tabPositionTopOrBottom.value) {\n        if (rtl) {\n          pingRight = transformLeft.value > 0;\n          pingLeft = transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;\n        } else {\n          pingLeft = transformLeft.value < 0;\n          pingRight = -transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;\n        }\n      } else {\n        pingTop = transformTop.value < 0;\n        pingBottom = -transformTop.value + wrapperHeight.value < wrapperScrollHeight.value;\n      }\n      const tabNodeStyle = {};\n      if (tabPosition === 'top' || tabPosition === 'bottom') {\n        tabNodeStyle[rtl ? 'marginRight' : 'marginLeft'] = typeof tabBarGutter === 'number' ? `${tabBarGutter}px` : tabBarGutter;\n      } else {\n        tabNodeStyle.marginTop = typeof tabBarGutter === 'number' ? `${tabBarGutter}px` : tabBarGutter;\n      }\n      const tabNodes = tabs.value.map((tab, i) => {\n        const {\n          key\n        } = tab;\n        return _createVNode(TabNode, {\n          \"id\": id,\n          \"prefixCls\": pre,\n          \"key\": key,\n          \"tab\": tab,\n          \"style\": i === 0 ? undefined : tabNodeStyle,\n          \"closable\": tab.closable,\n          \"editable\": editable,\n          \"active\": key === activeKey,\n          \"removeAriaLabel\": locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,\n          \"ref\": setRef(key),\n          \"onClick\": e => {\n            onTabClick(key, e);\n          },\n          \"onFocus\": () => {\n            scrollToTab(key);\n            doLockAnimation();\n            if (!tabsWrapperRef.value) {\n              return;\n            }\n            // Focus element will make scrollLeft change which we should reset back\n            if (!rtl) {\n              tabsWrapperRef.value.scrollLeft = 0;\n            }\n            tabsWrapperRef.value.scrollTop = 0;\n          }\n        }, slots);\n      });\n      return _createVNode(\"div\", {\n        \"role\": \"tablist\",\n        \"class\": classNames(`${pre}-nav`, className),\n        \"style\": style,\n        \"onKeydown\": () => {\n          // No need animation when use keyboard\n          doLockAnimation();\n        }\n      }, [_createVNode(ExtraContent, {\n        \"position\": \"left\",\n        \"prefixCls\": pre,\n        \"extra\": slots.leftExtra\n      }, null), _createVNode(ResizeObserver, {\n        \"onResize\": onListHolderResize\n      }, {\n        default: () => [_createVNode(\"div\", {\n          \"class\": classNames(wrapPrefix, {\n            [`${wrapPrefix}-ping-left`]: pingLeft,\n            [`${wrapPrefix}-ping-right`]: pingRight,\n            [`${wrapPrefix}-ping-top`]: pingTop,\n            [`${wrapPrefix}-ping-bottom`]: pingBottom\n          }),\n          \"ref\": tabsWrapperRef\n        }, [_createVNode(ResizeObserver, {\n          \"onResize\": onListHolderResize\n        }, {\n          default: () => [_createVNode(\"div\", {\n            \"ref\": tabListRef,\n            \"class\": `${pre}-nav-list`,\n            \"style\": {\n              transform: `translate(${transformLeft.value}px, ${transformTop.value}px)`,\n              transition: lockAnimation.value ? 'none' : undefined\n            }\n          }, [tabNodes, _createVNode(AddButton, {\n            \"ref\": innerAddButtonRef,\n            \"prefixCls\": pre,\n            \"locale\": locale,\n            \"editable\": editable,\n            \"style\": _extends(_extends({}, tabNodes.length === 0 ? undefined : tabNodeStyle), {\n              visibility: hasDropdown ? 'hidden' : null\n            })\n          }, null), _createVNode(\"div\", {\n            \"class\": classNames(`${pre}-ink-bar`, {\n              [`${pre}-ink-bar-animated`]: animated.inkBar\n            }),\n            \"style\": inkStyle.value\n          }, null)])]\n        })])]\n      }), _createVNode(OperationNode, _objectSpread(_objectSpread({}, props), {}, {\n        \"removeAriaLabel\": locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,\n        \"ref\": operationsRef,\n        \"prefixCls\": pre,\n        \"tabs\": hiddenTabs.value,\n        \"class\": !hasDropdown && operationsHiddenClassName.value\n      }), pick(slots, ['moreIcon'])), _createVNode(ExtraContent, {\n        \"position\": \"right\",\n        \"prefixCls\": pre,\n        \"extra\": slots.rightExtra\n      }, null), _createVNode(ExtraContent, {\n        \"position\": \"right\",\n        \"prefixCls\": pre,\n        \"extra\": slots.tabBarExtraContent\n      }, null)]);\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","resolveDirective","_resolveDirective","createVNode","_createVNode","useRafState","TabNode","useOffsets","OperationNode","useInjectTabs","useTouchMove","AddButton","objectType","functionType","shallowRef","onBeforeUnmount","defineComponent","watch","watchEffect","computed","PropTypes","useSyncState","useState","raf","classNames","ResizeObserver","toPx","useRefs","pick","DEFAULT_SIZE","width","height","left","top","right","tabNavListProps","id","type","String","tabPosition","activeKey","Number","rtl","Boolean","animated","editable","moreIcon","any","moreTransitionName","mobile","tabBarGutter","renderTabBar","Function","locale","popupClassName","getPopupContainer","onTabClick","onTabScroll","compatConfig","MODE","name","inheritAttrs","props","slots","Object","emits","setup","_ref","attrs","tabs","prefixCls","tabsWrapperRef","tabListRef","operationsRef","innerAddButtonRef","setRef","btnRefs","tabPositionTopOrBottom","transformLeft","setTransformLeft","next","prev","value","direction","transformTop","setTransformTop","wrapperScrollWidth","setWrapperScrollWidth","wrapperScrollHeight","setWrapperScrollHeight","wrapperWidth","setWrapperWidth","wrapperHeight","setWrapperHeight","addWidth","setAddWidth","addHeight","setAddHeight","tabSizes","setTabSizes","Map","tabOffsets","operationsHiddenClassName","transformMin","transformMax","Math","min","max","alignInRange","touchMovingRef","lockAnimation","setLockAnimation","doLockAnimation","Date","now","clearTouchMoving","clearTimeout","doMove","setState","offset","newValue","offsetX","offsetY","setTimeout","scrollToTab","key","arguments","length","undefined","tabOffset","get","newTransform","visibleStart","visibleEnd","unit","position","transformSize","basicSize","tabContentSize","addSize","tabOffsetsValue","includes","abs","mergedBasicSize","tabsVal","len","endIndex","i","startIndex","onListHolderResize","_a","_b","_c","_d","_e","offsetWidth","offsetHeight","addDom","$el","newAddWidth","newAddHeight","newWrapperScrollWidth","newWrapperScrollHeight","newSizes","forEach","_ref2","btnRef","btnNode","set","offsetLeft","offsetTop","hiddenTabs","slice","inkStyle","setInkStyle","activeTabOffset","inkBarRafRef","cleanInkBarRaf","cancel","newInkStyle","flush","ExtraContent","_ref3","extra","content","class","className","style","pre","hasDropdown","wrapPrefix","pingLeft","pingRight","pingTop","pingBottom","tabNodeStyle","marginTop","tabNodes","map","tab","closable","removeAriaLabel","e","onFocus","scrollLeft","scrollTop","onKeydown","leftExtra","default","transform","transition","visibility","inkBar","rightExtra","tabBarExtraContent"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/tabs/src/TabNavList/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { resolveDirective as _resolveDirective, createVNode as _createVNode } from \"vue\";\nimport { useRafState } from '../hooks/useRaf';\nimport TabNode from './TabNode';\nimport useOffsets from '../hooks/useOffsets';\nimport OperationNode from './OperationNode';\nimport { useInjectTabs } from '../TabContext';\nimport useTouchMove from '../hooks/useTouchMove';\nimport AddButton from './AddButton';\nimport { objectType, functionType } from '../../../_util/type';\nimport { shallowRef, onBeforeUnmount, defineComponent, watch, watchEffect, computed } from 'vue';\nimport PropTypes from '../../../_util/vue-types';\nimport useSyncState from '../hooks/useSyncState';\nimport useState from '../../../_util/hooks/useState';\nimport raf from '../../../_util/raf';\nimport classNames from '../../../_util/classNames';\nimport ResizeObserver from '../../../vc-resize-observer';\nimport { toPx } from '../../../_util/util';\nimport useRefs from '../../../_util/hooks/useRefs';\nimport pick from 'lodash-es/pick';\nconst DEFAULT_SIZE = {\n  width: 0,\n  height: 0,\n  left: 0,\n  top: 0,\n  right: 0\n};\nexport const tabNavListProps = () => {\n  return {\n    id: {\n      type: String\n    },\n    tabPosition: {\n      type: String\n    },\n    activeKey: {\n      type: [String, Number]\n    },\n    rtl: {\n      type: Boolean\n    },\n    animated: objectType(),\n    editable: objectType(),\n    moreIcon: PropTypes.any,\n    moreTransitionName: {\n      type: String\n    },\n    mobile: {\n      type: Boolean\n    },\n    tabBarGutter: {\n      type: Number\n    },\n    renderTabBar: {\n      type: Function\n    },\n    locale: objectType(),\n    popupClassName: String,\n    getPopupContainer: functionType(),\n    onTabClick: {\n      type: Function\n    },\n    onTabScroll: {\n      type: Function\n    }\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'TabNavList',\n  inheritAttrs: false,\n  props: tabNavListProps(),\n  slots: Object,\n  emits: ['tabClick', 'tabScroll'],\n  setup(props, _ref) {\n    let {\n      attrs,\n      slots\n    } = _ref;\n    const {\n      tabs,\n      prefixCls\n    } = useInjectTabs();\n    const tabsWrapperRef = shallowRef();\n    const tabListRef = shallowRef();\n    const operationsRef = shallowRef();\n    const innerAddButtonRef = shallowRef();\n    const [setRef, btnRefs] = useRefs();\n    const tabPositionTopOrBottom = computed(() => props.tabPosition === 'top' || props.tabPosition === 'bottom');\n    const [transformLeft, setTransformLeft] = useSyncState(0, (next, prev) => {\n      if (tabPositionTopOrBottom.value && props.onTabScroll) {\n        props.onTabScroll({\n          direction: next > prev ? 'left' : 'right'\n        });\n      }\n    });\n    const [transformTop, setTransformTop] = useSyncState(0, (next, prev) => {\n      if (!tabPositionTopOrBottom.value && props.onTabScroll) {\n        props.onTabScroll({\n          direction: next > prev ? 'top' : 'bottom'\n        });\n      }\n    });\n    const [wrapperScrollWidth, setWrapperScrollWidth] = useState(0);\n    const [wrapperScrollHeight, setWrapperScrollHeight] = useState(0);\n    const [wrapperWidth, setWrapperWidth] = useState(null);\n    const [wrapperHeight, setWrapperHeight] = useState(null);\n    const [addWidth, setAddWidth] = useState(0);\n    const [addHeight, setAddHeight] = useState(0);\n    const [tabSizes, setTabSizes] = useRafState(new Map());\n    const tabOffsets = useOffsets(tabs, tabSizes);\n    // ========================== Util =========================\n    const operationsHiddenClassName = computed(() => `${prefixCls.value}-nav-operations-hidden`);\n    const transformMin = shallowRef(0);\n    const transformMax = shallowRef(0);\n    watchEffect(() => {\n      if (!tabPositionTopOrBottom.value) {\n        transformMin.value = Math.min(0, wrapperHeight.value - wrapperScrollHeight.value);\n        transformMax.value = 0;\n      } else if (props.rtl) {\n        transformMin.value = 0;\n        transformMax.value = Math.max(0, wrapperScrollWidth.value - wrapperWidth.value);\n      } else {\n        transformMin.value = Math.min(0, wrapperWidth.value - wrapperScrollWidth.value);\n        transformMax.value = 0;\n      }\n    });\n    const alignInRange = value => {\n      if (value < transformMin.value) {\n        return transformMin.value;\n      }\n      if (value > transformMax.value) {\n        return transformMax.value;\n      }\n      return value;\n    };\n    // ========================= Mobile ========================\n    const touchMovingRef = shallowRef();\n    const [lockAnimation, setLockAnimation] = useState();\n    const doLockAnimation = () => {\n      setLockAnimation(Date.now());\n    };\n    const clearTouchMoving = () => {\n      clearTimeout(touchMovingRef.value);\n    };\n    const doMove = (setState, offset) => {\n      setState(value => {\n        const newValue = alignInRange(value + offset);\n        return newValue;\n      });\n    };\n    useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {\n      if (tabPositionTopOrBottom.value) {\n        // Skip scroll if place is enough\n        if (wrapperWidth.value >= wrapperScrollWidth.value) {\n          return false;\n        }\n        doMove(setTransformLeft, offsetX);\n      } else {\n        if (wrapperHeight.value >= wrapperScrollHeight.value) {\n          return false;\n        }\n        doMove(setTransformTop, offsetY);\n      }\n      clearTouchMoving();\n      doLockAnimation();\n      return true;\n    });\n    watch(lockAnimation, () => {\n      clearTouchMoving();\n      if (lockAnimation.value) {\n        touchMovingRef.value = setTimeout(() => {\n          setLockAnimation(0);\n        }, 100);\n      }\n    });\n    // ========================= Scroll ========================\n    const scrollToTab = function () {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : props.activeKey;\n      const tabOffset = tabOffsets.value.get(key) || {\n        width: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0\n      };\n      if (tabPositionTopOrBottom.value) {\n        // ============ Align with top & bottom ============\n        let newTransform = transformLeft.value;\n        // RTL\n        if (props.rtl) {\n          if (tabOffset.right < transformLeft.value) {\n            newTransform = tabOffset.right;\n          } else if (tabOffset.right + tabOffset.width > transformLeft.value + wrapperWidth.value) {\n            newTransform = tabOffset.right + tabOffset.width - wrapperWidth.value;\n          }\n        }\n        // LTR\n        else if (tabOffset.left < -transformLeft.value) {\n          newTransform = -tabOffset.left;\n        } else if (tabOffset.left + tabOffset.width > -transformLeft.value + wrapperWidth.value) {\n          newTransform = -(tabOffset.left + tabOffset.width - wrapperWidth.value);\n        }\n        setTransformTop(0);\n        setTransformLeft(alignInRange(newTransform));\n      } else {\n        // ============ Align with left & right ============\n        let newTransform = transformTop.value;\n        if (tabOffset.top < -transformTop.value) {\n          newTransform = -tabOffset.top;\n        } else if (tabOffset.top + tabOffset.height > -transformTop.value + wrapperHeight.value) {\n          newTransform = -(tabOffset.top + tabOffset.height - wrapperHeight.value);\n        }\n        setTransformLeft(0);\n        setTransformTop(alignInRange(newTransform));\n      }\n    };\n    const visibleStart = shallowRef(0);\n    const visibleEnd = shallowRef(0);\n    watchEffect(() => {\n      let unit;\n      let position;\n      let transformSize;\n      let basicSize;\n      let tabContentSize;\n      let addSize;\n      const tabOffsetsValue = tabOffsets.value;\n      if (['top', 'bottom'].includes(props.tabPosition)) {\n        unit = 'width';\n        basicSize = wrapperWidth.value;\n        tabContentSize = wrapperScrollWidth.value;\n        addSize = addWidth.value;\n        position = props.rtl ? 'right' : 'left';\n        transformSize = Math.abs(transformLeft.value);\n      } else {\n        unit = 'height';\n        basicSize = wrapperHeight.value;\n        tabContentSize = wrapperScrollWidth.value;\n        addSize = addHeight.value;\n        position = 'top';\n        transformSize = -transformTop.value;\n      }\n      let mergedBasicSize = basicSize;\n      if (tabContentSize + addSize > basicSize && tabContentSize < basicSize) {\n        mergedBasicSize = basicSize - addSize;\n      }\n      const tabsVal = tabs.value;\n      if (!tabsVal.length) {\n        return [visibleStart.value, visibleEnd.value] = [0, 0];\n      }\n      const len = tabsVal.length;\n      let endIndex = len;\n      for (let i = 0; i < len; i += 1) {\n        const offset = tabOffsetsValue.get(tabsVal[i].key) || DEFAULT_SIZE;\n        if (offset[position] + offset[unit] > transformSize + mergedBasicSize) {\n          endIndex = i - 1;\n          break;\n        }\n      }\n      let startIndex = 0;\n      for (let i = len - 1; i >= 0; i -= 1) {\n        const offset = tabOffsetsValue.get(tabsVal[i].key) || DEFAULT_SIZE;\n        if (offset[position] < transformSize) {\n          startIndex = i + 1;\n          break;\n        }\n      }\n      return [visibleStart.value, visibleEnd.value] = [startIndex, endIndex];\n    });\n    const onListHolderResize = () => {\n      var _a, _b, _c, _d, _e;\n      // Update wrapper records\n      const offsetWidth = ((_a = tabsWrapperRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth) || 0;\n      const offsetHeight = ((_b = tabsWrapperRef.value) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;\n      const addDom = ((_c = innerAddButtonRef.value) === null || _c === void 0 ? void 0 : _c.$el) || {};\n      const newAddWidth = addDom.offsetWidth || 0;\n      const newAddHeight = addDom.offsetHeight || 0;\n      setWrapperWidth(offsetWidth);\n      setWrapperHeight(offsetHeight);\n      setAddWidth(newAddWidth);\n      setAddHeight(newAddHeight);\n      const newWrapperScrollWidth = (((_d = tabListRef.value) === null || _d === void 0 ? void 0 : _d.offsetWidth) || 0) - newAddWidth;\n      const newWrapperScrollHeight = (((_e = tabListRef.value) === null || _e === void 0 ? void 0 : _e.offsetHeight) || 0) - newAddHeight;\n      setWrapperScrollWidth(newWrapperScrollWidth);\n      setWrapperScrollHeight(newWrapperScrollHeight);\n      // Update buttons records\n      setTabSizes(() => {\n        const newSizes = new Map();\n        tabs.value.forEach(_ref2 => {\n          let {\n            key\n          } = _ref2;\n          const btnRef = btnRefs.value.get(key);\n          const btnNode = (btnRef === null || btnRef === void 0 ? void 0 : btnRef.$el) || btnRef;\n          if (btnNode) {\n            newSizes.set(key, {\n              width: btnNode.offsetWidth,\n              height: btnNode.offsetHeight,\n              left: btnNode.offsetLeft,\n              top: btnNode.offsetTop\n            });\n          }\n        });\n        return newSizes;\n      });\n    };\n    // ======================== Dropdown =======================\n    const hiddenTabs = computed(() => [...tabs.value.slice(0, visibleStart.value), ...tabs.value.slice(visibleEnd.value + 1)]);\n    // =================== Link & Operations ===================\n    const [inkStyle, setInkStyle] = useState();\n    const activeTabOffset = computed(() => tabOffsets.value.get(props.activeKey));\n    // Delay set ink style to avoid remove tab blink\n    const inkBarRafRef = shallowRef();\n    const cleanInkBarRaf = () => {\n      raf.cancel(inkBarRafRef.value);\n    };\n    watch([activeTabOffset, tabPositionTopOrBottom, () => props.rtl], () => {\n      const newInkStyle = {};\n      if (activeTabOffset.value) {\n        if (tabPositionTopOrBottom.value) {\n          if (props.rtl) {\n            newInkStyle.right = toPx(activeTabOffset.value.right);\n          } else {\n            newInkStyle.left = toPx(activeTabOffset.value.left);\n          }\n          newInkStyle.width = toPx(activeTabOffset.value.width);\n        } else {\n          newInkStyle.top = toPx(activeTabOffset.value.top);\n          newInkStyle.height = toPx(activeTabOffset.value.height);\n        }\n      }\n      cleanInkBarRaf();\n      inkBarRafRef.value = raf(() => {\n        setInkStyle(newInkStyle);\n      });\n    });\n    watch([() => props.activeKey, activeTabOffset, tabOffsets, tabPositionTopOrBottom], () => {\n      scrollToTab();\n    }, {\n      flush: 'post'\n    });\n    watch([() => props.rtl, () => props.tabBarGutter, () => props.activeKey, () => tabs.value], () => {\n      onListHolderResize();\n    }, {\n      flush: 'post'\n    });\n    const ExtraContent = _ref3 => {\n      let {\n        position,\n        prefixCls,\n        extra\n      } = _ref3;\n      if (!extra) return null;\n      const content = extra === null || extra === void 0 ? void 0 : extra({\n        position\n      });\n      return content ? _createVNode(\"div\", {\n        \"class\": `${prefixCls}-extra-content`\n      }, [content]) : null;\n    };\n    onBeforeUnmount(() => {\n      clearTouchMoving();\n      cleanInkBarRaf();\n    });\n    return () => {\n      const {\n        id,\n        animated,\n        activeKey,\n        rtl,\n        editable,\n        locale,\n        tabPosition,\n        tabBarGutter,\n        onTabClick\n      } = props;\n      const {\n        class: className,\n        style\n      } = attrs;\n      const pre = prefixCls.value;\n      // ========================= Render ========================\n      const hasDropdown = !!hiddenTabs.value.length;\n      const wrapPrefix = `${pre}-nav-wrap`;\n      let pingLeft;\n      let pingRight;\n      let pingTop;\n      let pingBottom;\n      if (tabPositionTopOrBottom.value) {\n        if (rtl) {\n          pingRight = transformLeft.value > 0;\n          pingLeft = transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;\n        } else {\n          pingLeft = transformLeft.value < 0;\n          pingRight = -transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;\n        }\n      } else {\n        pingTop = transformTop.value < 0;\n        pingBottom = -transformTop.value + wrapperHeight.value < wrapperScrollHeight.value;\n      }\n      const tabNodeStyle = {};\n      if (tabPosition === 'top' || tabPosition === 'bottom') {\n        tabNodeStyle[rtl ? 'marginRight' : 'marginLeft'] = typeof tabBarGutter === 'number' ? `${tabBarGutter}px` : tabBarGutter;\n      } else {\n        tabNodeStyle.marginTop = typeof tabBarGutter === 'number' ? `${tabBarGutter}px` : tabBarGutter;\n      }\n      const tabNodes = tabs.value.map((tab, i) => {\n        const {\n          key\n        } = tab;\n        return _createVNode(TabNode, {\n          \"id\": id,\n          \"prefixCls\": pre,\n          \"key\": key,\n          \"tab\": tab,\n          \"style\": i === 0 ? undefined : tabNodeStyle,\n          \"closable\": tab.closable,\n          \"editable\": editable,\n          \"active\": key === activeKey,\n          \"removeAriaLabel\": locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,\n          \"ref\": setRef(key),\n          \"onClick\": e => {\n            onTabClick(key, e);\n          },\n          \"onFocus\": () => {\n            scrollToTab(key);\n            doLockAnimation();\n            if (!tabsWrapperRef.value) {\n              return;\n            }\n            // Focus element will make scrollLeft change which we should reset back\n            if (!rtl) {\n              tabsWrapperRef.value.scrollLeft = 0;\n            }\n            tabsWrapperRef.value.scrollTop = 0;\n          }\n        }, slots);\n      });\n      return _createVNode(\"div\", {\n        \"role\": \"tablist\",\n        \"class\": classNames(`${pre}-nav`, className),\n        \"style\": style,\n        \"onKeydown\": () => {\n          // No need animation when use keyboard\n          doLockAnimation();\n        }\n      }, [_createVNode(ExtraContent, {\n        \"position\": \"left\",\n        \"prefixCls\": pre,\n        \"extra\": slots.leftExtra\n      }, null), _createVNode(ResizeObserver, {\n        \"onResize\": onListHolderResize\n      }, {\n        default: () => [_createVNode(\"div\", {\n          \"class\": classNames(wrapPrefix, {\n            [`${wrapPrefix}-ping-left`]: pingLeft,\n            [`${wrapPrefix}-ping-right`]: pingRight,\n            [`${wrapPrefix}-ping-top`]: pingTop,\n            [`${wrapPrefix}-ping-bottom`]: pingBottom\n          }),\n          \"ref\": tabsWrapperRef\n        }, [_createVNode(ResizeObserver, {\n          \"onResize\": onListHolderResize\n        }, {\n          default: () => [_createVNode(\"div\", {\n            \"ref\": tabListRef,\n            \"class\": `${pre}-nav-list`,\n            \"style\": {\n              transform: `translate(${transformLeft.value}px, ${transformTop.value}px)`,\n              transition: lockAnimation.value ? 'none' : undefined\n            }\n          }, [tabNodes, _createVNode(AddButton, {\n            \"ref\": innerAddButtonRef,\n            \"prefixCls\": pre,\n            \"locale\": locale,\n            \"editable\": editable,\n            \"style\": _extends(_extends({}, tabNodes.length === 0 ? undefined : tabNodeStyle), {\n              visibility: hasDropdown ? 'hidden' : null\n            })\n          }, null), _createVNode(\"div\", {\n            \"class\": classNames(`${pre}-ink-bar`, {\n              [`${pre}-ink-bar-animated`]: animated.inkBar\n            }),\n            \"style\": inkStyle.value\n          }, null)])]\n        })])]\n      }), _createVNode(OperationNode, _objectSpread(_objectSpread({}, props), {}, {\n        \"removeAriaLabel\": locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,\n        \"ref\": operationsRef,\n        \"prefixCls\": pre,\n        \"tabs\": hiddenTabs.value,\n        \"class\": !hasDropdown && operationsHiddenClassName.value\n      }), pick(slots, ['moreIcon'])), _createVNode(ExtraContent, {\n        \"position\": \"right\",\n        \"prefixCls\": pre,\n        \"extra\": slots.rightExtra\n      }, null), _createVNode(ExtraContent, {\n        \"position\": \"right\",\n        \"prefixCls\": pre,\n        \"extra\": slots.tabBarExtraContent\n      }, null)]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}