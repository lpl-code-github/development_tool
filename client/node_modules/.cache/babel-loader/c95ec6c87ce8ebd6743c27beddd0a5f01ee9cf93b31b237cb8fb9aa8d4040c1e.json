{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\n// import supportsPassive from '../../../_util/supportsPassive';\nexport function clamp(number, lowerBound, upperBound) {\n  return Math.max(lowerBound, Math.min(number, upperBound));\n}\nexport const safePreventDefault = event => {\n  const passiveEvents = ['touchstart', 'touchmove', 'wheel'];\n  if (!passiveEvents.includes(event.type)) {\n    event.preventDefault();\n  }\n};\nexport const getOnDemandLazySlides = spec => {\n  const onDemandSlides = [];\n  const startIndex = lazyStartIndex(spec);\n  const endIndex = lazyEndIndex(spec);\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n  return onDemandSlides;\n};\n// return list of slides that need to be present\nexport const getRequiredLazySlides = spec => {\n  const requiredSlides = [];\n  const startIndex = lazyStartIndex(spec);\n  const endIndex = lazyEndIndex(spec);\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n  return requiredSlides;\n};\n// startIndex that needs to be present\nexport const lazyStartIndex = spec => spec.currentSlide - lazySlidesOnLeft(spec);\nexport const lazyEndIndex = spec => spec.currentSlide + lazySlidesOnRight(spec);\nexport const lazySlidesOnLeft = spec => spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\nexport const lazySlidesOnRight = spec => spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n// get width of an element\nexport const getWidth = elem => elem && elem.offsetWidth || 0;\nexport const getHeight = elem => elem && elem.offsetHeight || 0;\nexport const getSwipeDirection = function (touchObject) {\n  let verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let swipeAngle;\n  const xDist = touchObject.startX - touchObject.curX;\n  const yDist = touchObject.startY - touchObject.curY;\n  const r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return 'left';\n  }\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return 'right';\n  }\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return 'up';\n    } else {\n      return 'down';\n    }\n  }\n  return 'vertical';\n};\n// whether or not we can go next\nexport const canGoNext = spec => {\n  let canGo = true;\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n  return canGo;\n};\n// given an object and a list of keys, return new object with given keys\nexport const extractObject = (spec, keys) => {\n  const newObject = {};\n  keys.forEach(key => newObject[key] = spec[key]);\n  return newObject;\n};\n// get initialized state\nexport const initializedState = spec => {\n  // spec also contains listRef, trackRef\n  const slideCount = spec.children.length;\n  const listNode = spec.listRef;\n  const listWidth = Math.ceil(getWidth(listNode));\n  const trackNode = spec.trackRef;\n  const trackWidth = Math.ceil(getWidth(trackNode));\n  let slideWidth;\n  if (!spec.vertical) {\n    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n    if (typeof spec.centerPadding === 'string' && spec.centerPadding.slice(-1) === '%') {\n      centerPaddingAdj *= listWidth / 100;\n    }\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n  const slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n  const listHeight = slideHeight * spec.slidesToShow;\n  let currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n  let lazyLoadedList = spec.lazyLoadedList || [];\n  const slidesToLoad = getOnDemandLazySlides(_extends(_extends({}, spec), {\n    currentSlide,\n    lazyLoadedList\n  }), spec);\n  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n  const state = {\n    slideCount,\n    slideWidth,\n    listWidth,\n    trackWidth,\n    currentSlide,\n    slideHeight,\n    listHeight,\n    lazyLoadedList\n  };\n  if (spec.autoplaying === null && spec.autoplay) {\n    state['autoplaying'] = 'playing';\n  }\n  return state;\n};\nexport const slideHandler = spec => {\n  const {\n    waitForAnimate,\n    animating,\n    fade,\n    infinite,\n    index,\n    slideCount,\n    lazyLoad,\n    currentSlide,\n    centerMode,\n    slidesToScroll,\n    slidesToShow,\n    useCSS\n  } = spec;\n  let {\n    lazyLoadedList\n  } = spec;\n  if (waitForAnimate && animating) return {};\n  let animationSlide = index;\n  let finalSlide;\n  let animationLeft;\n  let finalLeft;\n  let state = {};\n  let nextState = {};\n  const targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList = lazyLoadedList.concat(animationSlide);\n    }\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList,\n      targetSlide: animationSlide\n    };\n    nextState = {\n      animating: false,\n      targetSlide: animationSlide\n    };\n  } else {\n    finalSlide = animationSlide;\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) {\n        finalSlide = slideCount - slideCount % slidesToScroll;\n      }\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n    if (!infinite && animationSlide + slidesToShow >= slideCount) {\n      finalSlide = slideCount - slidesToShow;\n    }\n    animationLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: finalSlide\n    }));\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n    if (lazyLoad) {\n      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_extends(_extends({}, spec), {\n        currentSlide: animationSlide\n      })));\n    }\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        lazyLoadedList,\n        targetSlide\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_extends(_extends({}, spec), {\n          left: animationLeft\n        })),\n        lazyLoadedList,\n        targetSlide\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        swipeLeft: null,\n        targetSlide\n      };\n    }\n  }\n  return {\n    state,\n    nextState\n  };\n};\nexport const changeSlide = (spec, options) => {\n  let previousInt, slideOffset, targetSlide;\n  const {\n    slidesToScroll,\n    slidesToShow,\n    slideCount,\n    currentSlide,\n    targetSlide: previousTargetSlide,\n    lazyLoad,\n    infinite\n  } = spec;\n  const unevenOffset = slideCount % slidesToScroll !== 0;\n  const indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n  if (options.message === 'previous') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide - slidesToScroll;\n    }\n  } else if (options.message === 'next') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide + slidesToScroll;\n    }\n  } else if (options.message === 'dots') {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n  } else if (options.message === 'children') {\n    // Click on the slides\n    targetSlide = options.index;\n    if (infinite) {\n      const direction = siblingDirection(_extends(_extends({}, spec), {\n        targetSlide\n      }));\n      if (targetSlide > options.currentSlide && direction === 'left') {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === 'right') {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === 'index') {\n    targetSlide = Number(options.index);\n  }\n  return targetSlide;\n};\nexport const keyHandler = (e, accessibility, rtl) => {\n  if (e.target.tagName.match('TEXTAREA|INPUT|SELECT') || !accessibility) {\n    return '';\n  }\n  if (e.keyCode === 37) return rtl ? 'next' : 'previous';\n  if (e.keyCode === 39) return rtl ? 'previous' : 'next';\n  return '';\n};\nexport const swipeStart = (e, swipe, draggable) => {\n  e.target.tagName === 'IMG' && safePreventDefault(e);\n  if (!swipe || !draggable && e.type.indexOf('mouse') !== -1) return '';\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport const swipeMove = (e, spec) => {\n  // spec also contains, trackRef and slideIndex\n  const {\n    scrolling,\n    animating,\n    vertical,\n    swipeToSlide,\n    verticalSwiping,\n    rtl,\n    currentSlide,\n    edgeFriction,\n    edgeDragged,\n    onEdge,\n    swiped,\n    swiping,\n    slideCount,\n    slidesToScroll,\n    infinite,\n    touchObject,\n    swipeEvent,\n    listHeight,\n    listWidth\n  } = spec;\n  if (scrolling) return;\n  if (animating) return safePreventDefault(e);\n  if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);\n  let swipeLeft;\n  let state = {};\n  const curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  const verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  let positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n  if (verticalSwiping) {\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  }\n  const dotCount = Math.ceil(slideCount / slidesToScroll);\n  const swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  let touchSwipeLength = touchObject.swipeLength;\n  if (!infinite) {\n    if (currentSlide === 0 && (swipeDirection === 'right' || swipeDirection === 'down') || currentSlide + 1 >= dotCount && (swipeDirection === 'left' || swipeDirection === 'up') || !canGoNext(spec) && (swipeDirection === 'left' || swipeDirection === 'up')) {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state['edgeDragged'] = true;\n      }\n    }\n  }\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state['swiped'] = true;\n  }\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n  state = _extends(_extends({}, state), {\n    touchObject,\n    swipeLeft,\n    trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n      left: swipeLeft\n    }))\n  });\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n  if (touchObject.swipeLength > 10) {\n    state['swiping'] = true;\n    safePreventDefault(e);\n  }\n  return state;\n};\nexport const swipeEnd = (e, spec) => {\n  const {\n    dragging,\n    swipe,\n    touchObject,\n    listWidth,\n    touchThreshold,\n    verticalSwiping,\n    listHeight,\n    swipeToSlide,\n    scrolling,\n    onSwipe,\n    targetSlide,\n    currentSlide,\n    infinite\n  } = spec;\n  if (!dragging) {\n    if (swipe) safePreventDefault(e);\n    return {};\n  }\n  const minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  const swipeDirection = getSwipeDirection(touchObject, verticalSwiping);\n  // reset the state of touch related state variables.\n  const state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n  if (scrolling) {\n    return state;\n  }\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n  if (touchObject.swipeLength > minSwipe) {\n    safePreventDefault(e);\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n    let slideCount, newSlide;\n    let activeSlide = infinite ? currentSlide : targetSlide;\n    switch (swipeDirection) {\n      case 'left':\n      case 'up':\n        newSlide = activeSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 0;\n        break;\n      case 'right':\n      case 'down':\n        newSlide = activeSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 1;\n        break;\n      default:\n        slideCount = activeSlide;\n    }\n    state['triggerSlideHandler'] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    const currentLeft = getTrackLeft(spec);\n    state['trackStyle'] = getTrackAnimateCSS(_extends(_extends({}, spec), {\n      left: currentLeft\n    }));\n  }\n  return state;\n};\nexport const getNavigableIndexes = spec => {\n  const max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  let counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  const indexes = [];\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n  return indexes;\n};\nexport const checkNavigable = (spec, index) => {\n  const navigables = getNavigableIndexes(spec);\n  let prevNavigable = 0;\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (const n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n      prevNavigable = navigables[n];\n    }\n  }\n  return index;\n};\nexport const getSlideCount = spec => {\n  const centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n  if (spec.swipeToSlide) {\n    let swipedSlide;\n    const slickList = spec.listRef;\n    const slides = slickList.querySelectorAll && slickList.querySelectorAll('.slick-slide') || [];\n    Array.from(slides).every(slide => {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n      return true;\n    });\n    if (!swipedSlide) {\n      return 0;\n    }\n    const currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    const slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nexport const checkSpecKeys = (spec, keysArray) => keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true) ? null : console.error('Keys Missing:', spec);\nexport const getTrackCSS = spec => {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth']);\n  let trackWidth, trackHeight;\n  const trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n  let style = {\n    opacity: 1,\n    transition: '',\n    WebkitTransition: ''\n  };\n  if (spec.useTransform) {\n    const WebkitTransform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    const transform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    const msTransform = !spec.vertical ? 'translateX(' + spec.left + 'px)' : 'translateY(' + spec.left + 'px)';\n    style = _extends(_extends({}, style), {\n      WebkitTransform,\n      transform,\n      msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style['top'] = spec.left;\n    } else {\n      style['left'] = spec.left;\n    }\n  }\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth + 'px';\n  if (trackHeight) style.height = trackHeight + 'px';\n  // Fallback for IE8\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + 'px';\n    } else {\n      style.marginTop = spec.left + 'px';\n    }\n  }\n  return style;\n};\nexport const getTrackAnimateCSS = spec => {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth', 'speed', 'cssEase']);\n  const style = getTrackCSS(spec);\n  // useCSS is true by default so it can be undefined\n  if (spec.useTransform) {\n    style.WebkitTransition = '-webkit-transform ' + spec.speed + 'ms ' + spec.cssEase;\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase;\n    } else {\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase;\n    }\n  }\n  return style;\n};\nexport const getTrackLeft = spec => {\n  if (spec.unslick) {\n    return 0;\n  }\n  checkSpecKeys(spec, ['slideIndex', 'trackRef', 'infinite', 'centerMode', 'slideCount', 'slidesToShow', 'slidesToScroll', 'slideWidth', 'listWidth', 'variableWidth', 'slideHeight']);\n  const {\n    slideIndex,\n    trackRef,\n    infinite,\n    centerMode,\n    slideCount,\n    slidesToShow,\n    slidesToScroll,\n    slideWidth,\n    listWidth,\n    variableWidth,\n    slideHeight,\n    fade,\n    vertical\n  } = spec;\n  let slideOffset = 0;\n  let targetLeft;\n  let targetSlide;\n  let verticalOffset = 0;\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n  let slidesToOffset = 0;\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    }\n    // shift current slide to center of the frame\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n  if (variableWidth === true) {\n    let targetSlideIndex;\n    const trackElem = trackRef;\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n  return targetLeft;\n};\nexport const getPreClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexport const getPostClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  return spec.slideCount;\n};\nexport const getTotalSlides = spec => spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\nexport const siblingDirection = spec => {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return 'left';\n    }\n    return 'right';\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return 'right';\n    }\n    return 'left';\n  }\n};\nexport const slidesOnRight = _ref => {\n  let {\n    slidesToShow,\n    centerMode,\n    rtl,\n    centerPadding\n  } = _ref;\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    let right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n  if (rtl) {\n    return 0;\n  }\n  return slidesToShow - 1;\n};\nexport const slidesOnLeft = _ref2 => {\n  let {\n    slidesToShow,\n    centerMode,\n    rtl,\n    centerPadding\n  } = _ref2;\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    let left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n  return 0;\n};\nexport const canUseDOM = () => !!(typeof window !== 'undefined' && window.document && window.document.createElement);","map":{"version":3,"names":["_extends","clamp","number","lowerBound","upperBound","Math","max","min","safePreventDefault","event","passiveEvents","includes","type","preventDefault","getOnDemandLazySlides","spec","onDemandSlides","startIndex","lazyStartIndex","endIndex","lazyEndIndex","slideIndex","lazyLoadedList","indexOf","push","getRequiredLazySlides","requiredSlides","currentSlide","lazySlidesOnLeft","lazySlidesOnRight","centerMode","floor","slidesToShow","parseInt","centerPadding","getWidth","elem","offsetWidth","getHeight","offsetHeight","getSwipeDirection","touchObject","verticalSwiping","arguments","length","undefined","swipeAngle","xDist","startX","curX","yDist","startY","curY","r","atan2","round","PI","abs","canGoNext","canGo","infinite","slideCount","extractObject","keys","newObject","forEach","key","initializedState","children","listNode","listRef","listWidth","ceil","trackNode","trackRef","trackWidth","slideWidth","vertical","centerPaddingAdj","slice","slideHeight","querySelector","listHeight","initialSlide","rtl","slidesToLoad","concat","state","autoplaying","autoplay","slideHandler","waitForAnimate","animating","fade","index","lazyLoad","slidesToScroll","useCSS","animationSlide","finalSlide","animationLeft","finalLeft","nextState","targetSlide","getTrackLeft","trackStyle","getTrackCSS","left","getTrackAnimateCSS","swipeLeft","changeSlide","options","previousInt","slideOffset","previousTargetSlide","unevenOffset","indexOffset","message","direction","siblingDirection","Number","keyHandler","e","accessibility","target","tagName","match","keyCode","swipeStart","swipe","draggable","dragging","touches","pageX","clientX","pageY","clientY","swipeMove","scrolling","swipeToSlide","edgeFriction","edgeDragged","onEdge","swiped","swiping","swipeEvent","curLeft","swipeLength","sqrt","pow","verticalSwipeLength","positionOffset","dotCount","swipeDirection","touchSwipeLength","swipeEnd","touchThreshold","onSwipe","minSwipe","newSlide","activeSlide","getSlideCount","checkNavigable","currentLeft","getNavigableIndexes","breakpoint","counter","indexes","navigables","prevNavigable","n","centerOffset","swipedSlide","slickList","slides","querySelectorAll","Array","from","every","slide","offsetLeft","offsetTop","currentIndex","slidesTraversed","dataset","checkSpecKeys","keysArray","reduce","value","hasOwnProperty","console","error","trackHeight","trackChildren","getTotalSlides","style","opacity","transition","WebkitTransition","useTransform","WebkitTransform","transform","msTransform","width","height","window","addEventListener","attachEvent","marginLeft","marginTop","speed","cssEase","unslick","variableWidth","targetLeft","verticalOffset","slidesToOffset","getPreClones","targetSlideIndex","trackElem","childNodes","getPostClones","slidesOnRight","slidesOnLeft","_ref","right","_ref2","canUseDOM","document","createElement"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-slick/utils/innerSliderUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n// import supportsPassive from '../../../_util/supportsPassive';\nexport function clamp(number, lowerBound, upperBound) {\n  return Math.max(lowerBound, Math.min(number, upperBound));\n}\nexport const safePreventDefault = event => {\n  const passiveEvents = ['touchstart', 'touchmove', 'wheel'];\n  if (!passiveEvents.includes(event.type)) {\n    event.preventDefault();\n  }\n};\nexport const getOnDemandLazySlides = spec => {\n  const onDemandSlides = [];\n  const startIndex = lazyStartIndex(spec);\n  const endIndex = lazyEndIndex(spec);\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n  return onDemandSlides;\n};\n// return list of slides that need to be present\nexport const getRequiredLazySlides = spec => {\n  const requiredSlides = [];\n  const startIndex = lazyStartIndex(spec);\n  const endIndex = lazyEndIndex(spec);\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n  return requiredSlides;\n};\n// startIndex that needs to be present\nexport const lazyStartIndex = spec => spec.currentSlide - lazySlidesOnLeft(spec);\nexport const lazyEndIndex = spec => spec.currentSlide + lazySlidesOnRight(spec);\nexport const lazySlidesOnLeft = spec => spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\nexport const lazySlidesOnRight = spec => spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;\n// get width of an element\nexport const getWidth = elem => elem && elem.offsetWidth || 0;\nexport const getHeight = elem => elem && elem.offsetHeight || 0;\nexport const getSwipeDirection = function (touchObject) {\n  let verticalSwiping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let swipeAngle;\n  const xDist = touchObject.startX - touchObject.curX;\n  const yDist = touchObject.startY - touchObject.curY;\n  const r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return 'left';\n  }\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return 'right';\n  }\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return 'up';\n    } else {\n      return 'down';\n    }\n  }\n  return 'vertical';\n};\n// whether or not we can go next\nexport const canGoNext = spec => {\n  let canGo = true;\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n  return canGo;\n};\n// given an object and a list of keys, return new object with given keys\nexport const extractObject = (spec, keys) => {\n  const newObject = {};\n  keys.forEach(key => newObject[key] = spec[key]);\n  return newObject;\n};\n// get initialized state\nexport const initializedState = spec => {\n  // spec also contains listRef, trackRef\n  const slideCount = spec.children.length;\n  const listNode = spec.listRef;\n  const listWidth = Math.ceil(getWidth(listNode));\n  const trackNode = spec.trackRef;\n  const trackWidth = Math.ceil(getWidth(trackNode));\n  let slideWidth;\n  if (!spec.vertical) {\n    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n    if (typeof spec.centerPadding === 'string' && spec.centerPadding.slice(-1) === '%') {\n      centerPaddingAdj *= listWidth / 100;\n    }\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n  const slideHeight = listNode && getHeight(listNode.querySelector('[data-index=\"0\"]'));\n  const listHeight = slideHeight * spec.slidesToShow;\n  let currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n  let lazyLoadedList = spec.lazyLoadedList || [];\n  const slidesToLoad = getOnDemandLazySlides(_extends(_extends({}, spec), {\n    currentSlide,\n    lazyLoadedList\n  }), spec);\n  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);\n  const state = {\n    slideCount,\n    slideWidth,\n    listWidth,\n    trackWidth,\n    currentSlide,\n    slideHeight,\n    listHeight,\n    lazyLoadedList\n  };\n  if (spec.autoplaying === null && spec.autoplay) {\n    state['autoplaying'] = 'playing';\n  }\n  return state;\n};\nexport const slideHandler = spec => {\n  const {\n    waitForAnimate,\n    animating,\n    fade,\n    infinite,\n    index,\n    slideCount,\n    lazyLoad,\n    currentSlide,\n    centerMode,\n    slidesToScroll,\n    slidesToShow,\n    useCSS\n  } = spec;\n  let {\n    lazyLoadedList\n  } = spec;\n  if (waitForAnimate && animating) return {};\n  let animationSlide = index;\n  let finalSlide;\n  let animationLeft;\n  let finalLeft;\n  let state = {};\n  let nextState = {};\n  const targetSlide = infinite ? index : clamp(index, 0, slideCount - 1);\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList = lazyLoadedList.concat(animationSlide);\n    }\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList,\n      targetSlide: animationSlide\n    };\n    nextState = {\n      animating: false,\n      targetSlide: animationSlide\n    };\n  } else {\n    finalSlide = animationSlide;\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) {\n        finalSlide = slideCount - slideCount % slidesToScroll;\n      }\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n    if (!infinite && animationSlide + slidesToShow >= slideCount) {\n      finalSlide = slideCount - slidesToShow;\n    }\n    animationLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_extends(_extends({}, spec), {\n      slideIndex: finalSlide\n    }));\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n    if (lazyLoad) {\n      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_extends(_extends({}, spec), {\n        currentSlide: animationSlide\n      })));\n    }\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        lazyLoadedList,\n        targetSlide\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_extends(_extends({}, spec), {\n          left: animationLeft\n        })),\n        lazyLoadedList,\n        targetSlide\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n          left: finalLeft\n        })),\n        swipeLeft: null,\n        targetSlide\n      };\n    }\n  }\n  return {\n    state,\n    nextState\n  };\n};\nexport const changeSlide = (spec, options) => {\n  let previousInt, slideOffset, targetSlide;\n  const {\n    slidesToScroll,\n    slidesToShow,\n    slideCount,\n    currentSlide,\n    targetSlide: previousTargetSlide,\n    lazyLoad,\n    infinite\n  } = spec;\n  const unevenOffset = slideCount % slidesToScroll !== 0;\n  const indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n  if (options.message === 'previous') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide - slidesToScroll;\n    }\n  } else if (options.message === 'next') {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n    if (!infinite) {\n      targetSlide = previousTargetSlide + slidesToScroll;\n    }\n  } else if (options.message === 'dots') {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n  } else if (options.message === 'children') {\n    // Click on the slides\n    targetSlide = options.index;\n    if (infinite) {\n      const direction = siblingDirection(_extends(_extends({}, spec), {\n        targetSlide\n      }));\n      if (targetSlide > options.currentSlide && direction === 'left') {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === 'right') {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === 'index') {\n    targetSlide = Number(options.index);\n  }\n  return targetSlide;\n};\nexport const keyHandler = (e, accessibility, rtl) => {\n  if (e.target.tagName.match('TEXTAREA|INPUT|SELECT') || !accessibility) {\n    return '';\n  }\n  if (e.keyCode === 37) return rtl ? 'next' : 'previous';\n  if (e.keyCode === 39) return rtl ? 'previous' : 'next';\n  return '';\n};\nexport const swipeStart = (e, swipe, draggable) => {\n  e.target.tagName === 'IMG' && safePreventDefault(e);\n  if (!swipe || !draggable && e.type.indexOf('mouse') !== -1) return '';\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport const swipeMove = (e, spec) => {\n  // spec also contains, trackRef and slideIndex\n  const {\n    scrolling,\n    animating,\n    vertical,\n    swipeToSlide,\n    verticalSwiping,\n    rtl,\n    currentSlide,\n    edgeFriction,\n    edgeDragged,\n    onEdge,\n    swiped,\n    swiping,\n    slideCount,\n    slidesToScroll,\n    infinite,\n    touchObject,\n    swipeEvent,\n    listHeight,\n    listWidth\n  } = spec;\n  if (scrolling) return;\n  if (animating) return safePreventDefault(e);\n  if (vertical && swipeToSlide && verticalSwiping) safePreventDefault(e);\n  let swipeLeft;\n  let state = {};\n  const curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  const verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  let positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n  if (verticalSwiping) {\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  }\n  const dotCount = Math.ceil(slideCount / slidesToScroll);\n  const swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  let touchSwipeLength = touchObject.swipeLength;\n  if (!infinite) {\n    if (currentSlide === 0 && (swipeDirection === 'right' || swipeDirection === 'down') || currentSlide + 1 >= dotCount && (swipeDirection === 'left' || swipeDirection === 'up') || !canGoNext(spec) && (swipeDirection === 'left' || swipeDirection === 'up')) {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state['edgeDragged'] = true;\n      }\n    }\n  }\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state['swiped'] = true;\n  }\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n  state = _extends(_extends({}, state), {\n    touchObject,\n    swipeLeft,\n    trackStyle: getTrackCSS(_extends(_extends({}, spec), {\n      left: swipeLeft\n    }))\n  });\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n  if (touchObject.swipeLength > 10) {\n    state['swiping'] = true;\n    safePreventDefault(e);\n  }\n  return state;\n};\nexport const swipeEnd = (e, spec) => {\n  const {\n    dragging,\n    swipe,\n    touchObject,\n    listWidth,\n    touchThreshold,\n    verticalSwiping,\n    listHeight,\n    swipeToSlide,\n    scrolling,\n    onSwipe,\n    targetSlide,\n    currentSlide,\n    infinite\n  } = spec;\n  if (!dragging) {\n    if (swipe) safePreventDefault(e);\n    return {};\n  }\n  const minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  const swipeDirection = getSwipeDirection(touchObject, verticalSwiping);\n  // reset the state of touch related state variables.\n  const state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n  if (scrolling) {\n    return state;\n  }\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n  if (touchObject.swipeLength > minSwipe) {\n    safePreventDefault(e);\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n    let slideCount, newSlide;\n    let activeSlide = infinite ? currentSlide : targetSlide;\n    switch (swipeDirection) {\n      case 'left':\n      case 'up':\n        newSlide = activeSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 0;\n        break;\n      case 'right':\n      case 'down':\n        newSlide = activeSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state['currentDirection'] = 1;\n        break;\n      default:\n        slideCount = activeSlide;\n    }\n    state['triggerSlideHandler'] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    const currentLeft = getTrackLeft(spec);\n    state['trackStyle'] = getTrackAnimateCSS(_extends(_extends({}, spec), {\n      left: currentLeft\n    }));\n  }\n  return state;\n};\nexport const getNavigableIndexes = spec => {\n  const max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  let counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  const indexes = [];\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n  return indexes;\n};\nexport const checkNavigable = (spec, index) => {\n  const navigables = getNavigableIndexes(spec);\n  let prevNavigable = 0;\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (const n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n      prevNavigable = navigables[n];\n    }\n  }\n  return index;\n};\nexport const getSlideCount = spec => {\n  const centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n  if (spec.swipeToSlide) {\n    let swipedSlide;\n    const slickList = spec.listRef;\n    const slides = slickList.querySelectorAll && slickList.querySelectorAll('.slick-slide') || [];\n    Array.from(slides).every(slide => {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n      return true;\n    });\n    if (!swipedSlide) {\n      return 0;\n    }\n    const currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    const slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nexport const checkSpecKeys = (spec, keysArray) => keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true) ? null : console.error('Keys Missing:', spec);\nexport const getTrackCSS = spec => {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth']);\n  let trackWidth, trackHeight;\n  const trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n  let style = {\n    opacity: 1,\n    transition: '',\n    WebkitTransition: ''\n  };\n  if (spec.useTransform) {\n    const WebkitTransform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    const transform = !spec.vertical ? 'translate3d(' + spec.left + 'px, 0px, 0px)' : 'translate3d(0px, ' + spec.left + 'px, 0px)';\n    const msTransform = !spec.vertical ? 'translateX(' + spec.left + 'px)' : 'translateY(' + spec.left + 'px)';\n    style = _extends(_extends({}, style), {\n      WebkitTransform,\n      transform,\n      msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style['top'] = spec.left;\n    } else {\n      style['left'] = spec.left;\n    }\n  }\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth + 'px';\n  if (trackHeight) style.height = trackHeight + 'px';\n  // Fallback for IE8\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + 'px';\n    } else {\n      style.marginTop = spec.left + 'px';\n    }\n  }\n  return style;\n};\nexport const getTrackAnimateCSS = spec => {\n  checkSpecKeys(spec, ['left', 'variableWidth', 'slideCount', 'slidesToShow', 'slideWidth', 'speed', 'cssEase']);\n  const style = getTrackCSS(spec);\n  // useCSS is true by default so it can be undefined\n  if (spec.useTransform) {\n    style.WebkitTransition = '-webkit-transform ' + spec.speed + 'ms ' + spec.cssEase;\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase;\n    } else {\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase;\n    }\n  }\n  return style;\n};\nexport const getTrackLeft = spec => {\n  if (spec.unslick) {\n    return 0;\n  }\n  checkSpecKeys(spec, ['slideIndex', 'trackRef', 'infinite', 'centerMode', 'slideCount', 'slidesToShow', 'slidesToScroll', 'slideWidth', 'listWidth', 'variableWidth', 'slideHeight']);\n  const {\n    slideIndex,\n    trackRef,\n    infinite,\n    centerMode,\n    slideCount,\n    slidesToShow,\n    slidesToScroll,\n    slideWidth,\n    listWidth,\n    variableWidth,\n    slideHeight,\n    fade,\n    vertical\n  } = spec;\n  let slideOffset = 0;\n  let targetLeft;\n  let targetSlide;\n  let verticalOffset = 0;\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n  let slidesToOffset = 0;\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    }\n    // shift current slide to center of the frame\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n  if (variableWidth === true) {\n    let targetSlideIndex;\n    const trackElem = trackRef;\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n  return targetLeft;\n};\nexport const getPreClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexport const getPostClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  return spec.slideCount;\n};\nexport const getTotalSlides = spec => spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\nexport const siblingDirection = spec => {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return 'left';\n    }\n    return 'right';\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return 'right';\n    }\n    return 'left';\n  }\n};\nexport const slidesOnRight = _ref => {\n  let {\n    slidesToShow,\n    centerMode,\n    rtl,\n    centerPadding\n  } = _ref;\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    let right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n  if (rtl) {\n    return 0;\n  }\n  return slidesToShow - 1;\n};\nexport const slidesOnLeft = _ref2 => {\n  let {\n    slidesToShow,\n    centerMode,\n    rtl,\n    centerPadding\n  } = _ref2;\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    let left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n  return 0;\n};\nexport const canUseDOM = () => !!(typeof window !== 'undefined' && window.document && window.document.createElement);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}