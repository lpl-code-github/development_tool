{"ast":null,"code":"const ctx = '@@InfiniteScroll';\nlet throttle = function (fn, delay) {\n  let now, lastExec, timer, context, args; //eslint-disable-line\n\n  let execute = function () {\n    fn.apply(context, args);\n    lastExec = now;\n  };\n  return function () {\n    context = this;\n    args = arguments;\n    now = Date.now();\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    if (lastExec) {\n      let diff = delay - (now - lastExec);\n      if (diff < 0) {\n        execute();\n      } else {\n        timer = setTimeout(() => {\n          execute();\n        }, diff);\n      }\n    } else {\n      execute();\n    }\n  };\n};\nlet getScrollTop = function (element) {\n  if (element === window) {\n    return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);\n  }\n  return element.scrollTop;\n};\nlet getComputedStyle = document.defaultView.getComputedStyle;\nlet getScrollEventTarget = function (element) {\n  let currentNode = element;\n  // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome\n  while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {\n    let overflowY = getComputedStyle(currentNode).overflowY;\n    let overflowYStyle = currentNode.style.overflowY;\n    if (overflowY === 'scroll' || overflowY === 'auto' || overflowYStyle === 'auto') {\n      return currentNode;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return currentNode;\n};\nlet getVisibleHeight = function (element) {\n  if (element === window) {\n    return document.documentElement.clientHeight;\n  }\n  return element.clientHeight;\n};\nlet getElementTop = function (element) {\n  if (element === window) {\n    return getScrollTop(window);\n  }\n  return element.getBoundingClientRect().top + getScrollTop(window);\n};\nlet isAttached = function (element) {\n  let currentNode = element.parentNode;\n  while (currentNode) {\n    if (currentNode.tagName === 'HTML') {\n      return true;\n    }\n    if (currentNode.nodeType === 11) {\n      return false;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return false;\n};\nlet doBind = function () {\n  if (this.binded) return; // eslint-disable-line\n  this.binded = true;\n  let directive = this;\n  let element = directive.el;\n  let throttleDelayExpr = element.getAttribute('infinite-scroll-throttle-delay');\n  let throttleDelay = 200;\n  if (throttleDelayExpr) {\n    throttleDelay = Number(directive.vm[throttleDelayExpr] || throttleDelayExpr);\n    if (isNaN(throttleDelay) || throttleDelay < 0) {\n      throttleDelay = 200;\n    }\n  }\n  directive.throttleDelay = throttleDelay;\n  directive.scrollEventTarget = getScrollEventTarget(element);\n  directive.scrollListener = throttle(doCheck.bind(directive), directive.throttleDelay);\n  directive.scrollEventTarget.addEventListener('scroll', directive.scrollListener);\n  this.vm.$on('hook:beforeDestroy', function () {\n    directive.scrollEventTarget.removeEventListener('scroll', directive.scrollListener);\n  });\n  let disabledExpr = element.getAttribute('infinite-scroll-disabled');\n  let disabled = false;\n  console.log('disabledExpr', disabledExpr);\n  if (disabledExpr) {\n    this.vm.$watch(disabledExpr, function (value) {\n      directive.disabled = value;\n      if (!value && directive.immediateCheck) {\n        doCheck.call(directive);\n      }\n    });\n    disabled = Boolean(directive.vm[disabledExpr]);\n  }\n  directive.disabled = disabled;\n  let distanceExpr = element.getAttribute('infinite-scroll-distance');\n  let distance = 0;\n  if (distanceExpr) {\n    distance = Number(directive.vm[distanceExpr] || distanceExpr);\n    if (isNaN(distance)) {\n      distance = 0;\n    }\n  }\n  directive.distance = distance;\n  let immediateCheckExpr = element.getAttribute('infinite-scroll-immediate-check');\n  let immediateCheck = true;\n  if (immediateCheckExpr) {\n    immediateCheck = Boolean(directive.vm[immediateCheckExpr]);\n  }\n  directive.immediateCheck = immediateCheck;\n  if (immediateCheck) {\n    doCheck.call(directive);\n  }\n  let eventName = element.getAttribute('infinite-scroll-listen-for-event');\n  if (eventName) {\n    directive.vm.$on(eventName, function () {\n      doCheck.call(directive);\n    });\n  }\n};\nconst doCheck = function (force) {\n  let scrollEventTarget = this.scrollEventTarget;\n  let element = this.el;\n  let distance = this.distance;\n  if (force !== true && this.disabled) return; //eslint-disable-line\n  let viewportScrollTop = getScrollTop(scrollEventTarget);\n  let viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);\n  let shouldTrigger = false;\n  if (scrollEventTarget === element) {\n    shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;\n  } else {\n    let elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;\n    shouldTrigger = viewportBottom + distance >= elementBottom;\n  }\n  if (shouldTrigger && this.expression) {\n    this.expression();\n  }\n};\nexport default {\n  bind(el, binding, vnode) {\n    el[ctx] = {\n      el,\n      vm: vnode.context,\n      expression: binding.value\n    };\n    const args = arguments;\n    doBind.call(el[ctx]);\n    el[ctx].vm.$nextTick().then(function () {\n      if (isAttached(el)) {\n        doBind.call(el[ctx], args);\n      }\n      el[ctx].bindTryCount = 0;\n      const tryBind = function () {\n        if (el[ctx].bindTryCount > 10) return; //eslint-disable-line\n        el[ctx].bindTryCount++;\n        if (isAttached(el)) {\n          doBind.call(el[ctx], args);\n        } else {\n          setTimeout(tryBind, 50);\n        }\n      };\n      tryBind();\n    });\n  },\n  unbind(el) {\n    if (el && el[ctx] && el[ctx].scrollEventTarget) {\n      el[ctx].scrollEventTarget.removeEventListener('scroll', el[ctx].scrollListener);\n    }\n  }\n};","map":{"version":3,"names":["ctx","throttle","fn","delay","now","lastExec","timer","context","args","execute","apply","arguments","Date","clearTimeout","diff","setTimeout","getScrollTop","element","window","Math","max","pageYOffset","document","documentElement","scrollTop","getComputedStyle","defaultView","getScrollEventTarget","currentNode","tagName","nodeType","overflowY","overflowYStyle","style","parentNode","getVisibleHeight","clientHeight","getElementTop","getBoundingClientRect","top","isAttached","doBind","binded","directive","el","throttleDelayExpr","getAttribute","throttleDelay","Number","vm","isNaN","scrollEventTarget","scrollListener","doCheck","bind","addEventListener","$on","removeEventListener","disabledExpr","disabled","console","log","$watch","value","immediateCheck","call","Boolean","distanceExpr","distance","immediateCheckExpr","eventName","force","viewportScrollTop","viewportBottom","shouldTrigger","scrollHeight","elementBottom","offsetHeight","expression","binding","vnode","$nextTick","then","bindTryCount","tryBind","unbind"],"sources":["/Users/lpl/Teamsupport/development_tool/client/src/assets/js/directive.js"],"sourcesContent":["const ctx = '@@InfiniteScroll';\n\nlet throttle = function (fn, delay) {\n    let now, lastExec, timer, context, args; //eslint-disable-line\n\n    let execute = function () {\n        fn.apply(context, args);\n        lastExec = now;\n    };\n\n    return function () {\n        context = this;\n        args = arguments;\n        now = Date.now();\n\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        if (lastExec) {\n            let diff = delay - (now - lastExec);\n            if (diff < 0) {\n                execute();\n            } else {\n                timer = setTimeout(() => {\n                    execute();\n                }, diff);\n            }\n        } else {\n            execute();\n        }\n    };\n};\n\nlet getScrollTop = function (element) {\n    if (element === window) {\n        return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);\n    }\n\n    return element.scrollTop;\n};\n\nlet getComputedStyle = document.defaultView.getComputedStyle;\n\nlet getScrollEventTarget = function (element) {\n    let currentNode = element;\n    // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome\n    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {\n        let overflowY = getComputedStyle(currentNode).overflowY;\n        let overflowYStyle = currentNode.style.overflowY\n        if (overflowY === 'scroll' || overflowY === 'auto' || overflowYStyle === 'auto') {\n            return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n    }\n    return currentNode;\n};\n\nlet getVisibleHeight = function (element) {\n    if (element === window) {\n        return document.documentElement.clientHeight;\n    }\n\n    return element.clientHeight;\n};\n\nlet getElementTop = function (element) {\n    if (element === window) {\n        return getScrollTop(window);\n    }\n    return element.getBoundingClientRect().top + getScrollTop(window);\n};\n\nlet isAttached = function (element) {\n    let currentNode = element.parentNode;\n    while (currentNode) {\n        if (currentNode.tagName === 'HTML') {\n            return true;\n        }\n        if (currentNode.nodeType === 11) {\n            return false;\n        }\n        currentNode = currentNode.parentNode;\n    }\n    return false;\n};\n\nlet doBind = function () {\n    if (this.binded) return; // eslint-disable-line\n    this.binded = true;\n\n    let directive = this;\n    let element = directive.el;\n\n    let throttleDelayExpr = element.getAttribute('infinite-scroll-throttle-delay');\n    let throttleDelay = 200;\n    if (throttleDelayExpr) {\n        throttleDelay = Number(directive.vm[throttleDelayExpr] || throttleDelayExpr);\n        if (isNaN(throttleDelay) || throttleDelay < 0) {\n            throttleDelay = 200;\n        }\n    }\n    directive.throttleDelay = throttleDelay;\n\n    directive.scrollEventTarget = getScrollEventTarget(element);\n    directive.scrollListener = throttle(doCheck.bind(directive), directive.throttleDelay);\n    directive.scrollEventTarget.addEventListener('scroll', directive.scrollListener);\n\n    this.vm.$on('hook:beforeDestroy', function () {\n        directive.scrollEventTarget.removeEventListener('scroll', directive.scrollListener);\n    });\n\n    let disabledExpr = element.getAttribute('infinite-scroll-disabled');\n    let disabled = false;\n    console.log('disabledExpr', disabledExpr)\n    if (disabledExpr) {\n        this.vm.$watch(disabledExpr, function (value) {\n            directive.disabled = value;\n            if (!value && directive.immediateCheck) {\n                doCheck.call(directive);\n            }\n        });\n        disabled = Boolean(directive.vm[disabledExpr]);\n    }\n    directive.disabled = disabled;\n\n    let distanceExpr = element.getAttribute('infinite-scroll-distance');\n    let distance = 0;\n    if (distanceExpr) {\n        distance = Number(directive.vm[distanceExpr] || distanceExpr);\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n    }\n    directive.distance = distance;\n\n    let immediateCheckExpr = element.getAttribute('infinite-scroll-immediate-check');\n    let immediateCheck = true;\n    if (immediateCheckExpr) {\n        immediateCheck = Boolean(directive.vm[immediateCheckExpr]);\n    }\n    directive.immediateCheck = immediateCheck;\n\n    if (immediateCheck) {\n        doCheck.call(directive);\n    }\n\n    let eventName = element.getAttribute('infinite-scroll-listen-for-event');\n    if (eventName) {\n        directive.vm.$on(eventName, function () {\n            doCheck.call(directive);\n        });\n    }\n};\n\nconst doCheck = function (force) {\n    let scrollEventTarget = this.scrollEventTarget;\n    let element = this.el;\n    let distance = this.distance;\n\n    if (force !== true && this.disabled) return; //eslint-disable-line\n    let viewportScrollTop = getScrollTop(scrollEventTarget);\n    let viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);\n\n    let shouldTrigger = false;\n\n    if (scrollEventTarget === element) {\n        shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;\n    } else {\n        let elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;\n\n        shouldTrigger = viewportBottom + distance >= elementBottom;\n    }\n\n    if (shouldTrigger && this.expression) {\n        this.expression();\n    }\n};\n\nexport default {\n    bind (el, binding, vnode) {\n        el[ctx] = {\n            el,\n            vm: vnode.context,\n            expression: binding.value\n        };\n        const args = arguments;\n\n        doBind.call(el[ctx]);\n        el[ctx].vm.$nextTick().then(function () {\n            if (isAttached(el)) {\n                doBind.call(el[ctx], args);\n            }\n\n            el[ctx].bindTryCount = 0;\n\n            const tryBind = function () {\n                if (el[ctx].bindTryCount > 10) return; //eslint-disable-line\n                el[ctx].bindTryCount++;\n                if (isAttached(el)) {\n                    doBind.call(el[ctx], args);\n                } else {\n                    setTimeout(tryBind, 50);\n                }\n            };\n            tryBind();\n        });\n    },\n\n    unbind (el) {\n        if (el && el[ctx] && el[ctx].scrollEventTarget) {\n            el[ctx].scrollEventTarget.removeEventListener('scroll', el[ctx].scrollListener);\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}