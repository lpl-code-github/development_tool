{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { resolveDirective as _resolveDirective, createVNode as _createVNode } from \"vue\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { computed, defineComponent, shallowRef, watch } from 'vue';\nimport ResizeObserver from '../vc-resize-observer';\nimport classNames from '../_util/classNames';\nimport PropTypes from '../_util/vue-types';\nimport { OverflowContextProvider } from './context';\nimport Item from './Item';\nimport RawItem from './RawItem';\nconst RESPONSIVE = 'responsive';\nconst INVALIDATE = 'invalidate';\nfunction defaultRenderRest(omittedItems) {\n  return `+ ${omittedItems.length} ...`;\n}\nconst overflowProps = () => {\n  return {\n    id: String,\n    prefixCls: String,\n    data: Array,\n    itemKey: [String, Number, Function],\n    /** Used for `responsive`. It will limit render node to avoid perf issue */\n    itemWidth: {\n      type: Number,\n      default: 10\n    },\n    renderItem: Function,\n    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */\n    renderRawItem: Function,\n    maxCount: [Number, String],\n    renderRest: Function,\n    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */\n    renderRawRest: Function,\n    suffix: PropTypes.any,\n    component: String,\n    itemComponent: PropTypes.any,\n    /** @private This API may be refactor since not well design */\n    onVisibleChange: Function,\n    /** When set to `full`, ssr will render full items by default and remove at client side */\n    ssr: String,\n    onMousedown: Function\n  };\n};\nconst Overflow = defineComponent({\n  name: 'Overflow',\n  inheritAttrs: false,\n  props: overflowProps(),\n  emits: ['visibleChange'],\n  setup(props, _ref) {\n    let {\n      attrs,\n      emit,\n      slots\n    } = _ref;\n    const fullySSR = computed(() => props.ssr === 'full');\n    const containerWidth = shallowRef(null);\n    const mergedContainerWidth = computed(() => containerWidth.value || 0);\n    const itemWidths = shallowRef(new Map());\n    const prevRestWidth = shallowRef(0);\n    const restWidth = shallowRef(0);\n    const suffixWidth = shallowRef(0);\n    const suffixFixedStart = shallowRef(null);\n    const displayCount = shallowRef(null);\n    const mergedDisplayCount = computed(() => {\n      if (displayCount.value === null && fullySSR.value) {\n        return Number.MAX_SAFE_INTEGER;\n      }\n      return displayCount.value || 0;\n    });\n    const restReady = shallowRef(false);\n    const itemPrefixCls = computed(() => `${props.prefixCls}-item`);\n    // Always use the max width to avoid blink\n    const mergedRestWidth = computed(() => Math.max(prevRestWidth.value, restWidth.value));\n    // ================================= Data =================================\n    const isResponsive = computed(() => !!(props.data.length && props.maxCount === RESPONSIVE));\n    const invalidate = computed(() => props.maxCount === INVALIDATE);\n    /**\n     * When is `responsive`, we will always render rest node to get the real width of it for calculation\n     */\n    const showRest = computed(() => isResponsive.value || typeof props.maxCount === 'number' && props.data.length > props.maxCount);\n    const mergedData = computed(() => {\n      let items = props.data;\n      if (isResponsive.value) {\n        if (containerWidth.value === null && fullySSR.value) {\n          items = props.data;\n        } else {\n          items = props.data.slice(0, Math.min(props.data.length, mergedContainerWidth.value / props.itemWidth));\n        }\n      } else if (typeof props.maxCount === 'number') {\n        items = props.data.slice(0, props.maxCount);\n      }\n      return items;\n    });\n    const omittedItems = computed(() => {\n      if (isResponsive.value) {\n        return props.data.slice(mergedDisplayCount.value + 1);\n      }\n      return props.data.slice(mergedData.value.length);\n    });\n    // ================================= Item =================================\n    const getKey = (item, index) => {\n      var _a;\n      if (typeof props.itemKey === 'function') {\n        return props.itemKey(item);\n      }\n      return (_a = props.itemKey && (item === null || item === void 0 ? void 0 : item[props.itemKey])) !== null && _a !== void 0 ? _a : index;\n    };\n    const mergedRenderItem = computed(() => props.renderItem || (item => item));\n    const updateDisplayCount = (count, notReady) => {\n      displayCount.value = count;\n      if (!notReady) {\n        restReady.value = count < props.data.length - 1;\n        emit('visibleChange', count);\n      }\n    };\n    // ================================= Size =================================\n    const onOverflowResize = (_, element) => {\n      containerWidth.value = element.clientWidth;\n    };\n    const registerSize = (key, width) => {\n      const clone = new Map(itemWidths.value);\n      if (width === null) {\n        clone.delete(key);\n      } else {\n        clone.set(key, width);\n      }\n      itemWidths.value = clone;\n    };\n    const registerOverflowSize = (_, width) => {\n      prevRestWidth.value = restWidth.value;\n      restWidth.value = width;\n    };\n    const registerSuffixSize = (_, width) => {\n      suffixWidth.value = width;\n    };\n    // ================================ Effect ================================\n    const getItemWidth = index => {\n      return itemWidths.value.get(getKey(mergedData.value[index], index));\n    };\n    watch([mergedContainerWidth, itemWidths, restWidth, suffixWidth, () => props.itemKey, mergedData], () => {\n      if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {\n        let totalWidth = suffixWidth.value;\n        const len = mergedData.value.length;\n        const lastIndex = len - 1;\n        // When data count change to 0, reset this since not loop will reach\n        if (!len) {\n          updateDisplayCount(0);\n          suffixFixedStart.value = null;\n          return;\n        }\n        for (let i = 0; i < len; i += 1) {\n          const currentItemWidth = getItemWidth(i);\n          // Break since data not ready\n          if (currentItemWidth === undefined) {\n            updateDisplayCount(i - 1, true);\n            break;\n          }\n          // Find best match\n          totalWidth += currentItemWidth;\n          if (\n          // Only one means `totalWidth` is the final width\n          lastIndex === 0 && totalWidth <= mergedContainerWidth.value ||\n          // Last two width will be the final width\n          i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value) {\n            // Additional check if match the end\n            updateDisplayCount(lastIndex);\n            suffixFixedStart.value = null;\n            break;\n          } else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {\n            // Can not hold all the content to show rest\n            updateDisplayCount(i - 1);\n            suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;\n            break;\n          }\n        }\n        if (props.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) {\n          suffixFixedStart.value = null;\n        }\n      }\n    });\n    return () => {\n      // ================================ Render ================================\n      const displayRest = restReady.value && !!omittedItems.value.length;\n      const {\n        itemComponent,\n        renderRawItem,\n        renderRawRest,\n        renderRest,\n        prefixCls = 'rc-overflow',\n        suffix,\n        component: Component = 'div',\n        id,\n        onMousedown\n      } = props;\n      const {\n          class: className,\n          style\n        } = attrs,\n        restAttrs = __rest(attrs, [\"class\", \"style\"]);\n      let suffixStyle = {};\n      if (suffixFixedStart.value !== null && isResponsive.value) {\n        suffixStyle = {\n          position: 'absolute',\n          left: `${suffixFixedStart.value}px`,\n          top: 0\n        };\n      }\n      const itemSharedProps = {\n        prefixCls: itemPrefixCls.value,\n        responsive: isResponsive.value,\n        component: itemComponent,\n        invalidate: invalidate.value\n      };\n      // >>>>> Choice render fun by `renderRawItem`\n      const internalRenderItemNode = renderRawItem ? (item, index) => {\n        const key = getKey(item, index);\n        return _createVNode(OverflowContextProvider, {\n          \"key\": key,\n          \"value\": _extends(_extends({}, itemSharedProps), {\n            order: index,\n            item,\n            itemKey: key,\n            registerSize,\n            display: index <= mergedDisplayCount.value\n          })\n        }, {\n          default: () => [renderRawItem(item, index)]\n        });\n      } : (item, index) => {\n        const key = getKey(item, index);\n        return _createVNode(Item, _objectSpread(_objectSpread({}, itemSharedProps), {}, {\n          \"order\": index,\n          \"key\": key,\n          \"item\": item,\n          \"renderItem\": mergedRenderItem.value,\n          \"itemKey\": key,\n          \"registerSize\": registerSize,\n          \"display\": index <= mergedDisplayCount.value\n        }), null);\n      };\n      // >>>>> Rest node\n      let restNode = () => null;\n      const restContextProps = {\n        order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,\n        className: `${itemPrefixCls.value} ${itemPrefixCls.value}-rest`,\n        registerSize: registerOverflowSize,\n        display: displayRest\n      };\n      if (!renderRawRest) {\n        const mergedRenderRest = renderRest || defaultRenderRest;\n        restNode = () => _createVNode(Item, _objectSpread(_objectSpread({}, itemSharedProps), restContextProps), {\n          default: () => typeof mergedRenderRest === 'function' ? mergedRenderRest(omittedItems.value) : mergedRenderRest\n        });\n      } else if (renderRawRest) {\n        restNode = () => _createVNode(OverflowContextProvider, {\n          \"value\": _extends(_extends({}, itemSharedProps), restContextProps)\n        }, {\n          default: () => [renderRawRest(omittedItems.value)]\n        });\n      }\n      const overflowNode = () => {\n        var _a;\n        return _createVNode(Component, _objectSpread({\n          \"id\": id,\n          \"class\": classNames(!invalidate.value && prefixCls, className),\n          \"style\": style,\n          \"onMousedown\": onMousedown\n        }, restAttrs), {\n          default: () => [mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && _createVNode(Item, _objectSpread(_objectSpread({}, itemSharedProps), {}, {\n            \"order\": mergedDisplayCount.value,\n            \"class\": `${itemPrefixCls.value}-suffix`,\n            \"registerSize\": registerSuffixSize,\n            \"display\": true,\n            \"style\": suffixStyle\n          }), {\n            default: () => suffix\n          }), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]\n        });\n      };\n      // 使用 disabled  避免结构不一致 导致子组件 rerender\n      return _createVNode(ResizeObserver, {\n        \"disabled\": !isResponsive.value,\n        \"onResize\": onOverflowResize\n      }, {\n        default: overflowNode\n      });\n    };\n  }\n});\nOverflow.Item = RawItem;\nOverflow.RESPONSIVE = RESPONSIVE;\nOverflow.INVALIDATE = INVALIDATE;\nexport default Overflow;","map":{"version":3,"names":["_objectSpread","_extends","resolveDirective","_resolveDirective","createVNode","_createVNode","__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","computed","defineComponent","shallowRef","watch","ResizeObserver","classNames","PropTypes","OverflowContextProvider","Item","RawItem","RESPONSIVE","INVALIDATE","defaultRenderRest","omittedItems","overflowProps","id","String","prefixCls","data","Array","itemKey","Number","Function","itemWidth","type","default","renderItem","renderRawItem","maxCount","renderRest","renderRawRest","suffix","any","component","itemComponent","onVisibleChange","ssr","onMousedown","Overflow","name","inheritAttrs","props","emits","setup","_ref","attrs","emit","slots","fullySSR","containerWidth","mergedContainerWidth","value","itemWidths","Map","prevRestWidth","restWidth","suffixWidth","suffixFixedStart","displayCount","mergedDisplayCount","MAX_SAFE_INTEGER","restReady","itemPrefixCls","mergedRestWidth","Math","max","isResponsive","invalidate","showRest","mergedData","items","slice","min","getKey","item","index","_a","mergedRenderItem","updateDisplayCount","count","notReady","onOverflowResize","_","element","clientWidth","registerSize","key","width","clone","delete","set","registerOverflowSize","registerSuffixSize","getItemWidth","get","totalWidth","len","lastIndex","currentItemWidth","undefined","displayRest","Component","class","className","style","restAttrs","suffixStyle","position","left","top","itemSharedProps","responsive","internalRenderItemNode","order","display","restNode","restContextProps","mergedRenderRest","overflowNode","map"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-overflow/Overflow.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { resolveDirective as _resolveDirective, createVNode as _createVNode } from \"vue\";\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { computed, defineComponent, shallowRef, watch } from 'vue';\nimport ResizeObserver from '../vc-resize-observer';\nimport classNames from '../_util/classNames';\nimport PropTypes from '../_util/vue-types';\nimport { OverflowContextProvider } from './context';\nimport Item from './Item';\nimport RawItem from './RawItem';\nconst RESPONSIVE = 'responsive';\nconst INVALIDATE = 'invalidate';\nfunction defaultRenderRest(omittedItems) {\n  return `+ ${omittedItems.length} ...`;\n}\nconst overflowProps = () => {\n  return {\n    id: String,\n    prefixCls: String,\n    data: Array,\n    itemKey: [String, Number, Function],\n    /** Used for `responsive`. It will limit render node to avoid perf issue */\n    itemWidth: {\n      type: Number,\n      default: 10\n    },\n    renderItem: Function,\n    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */\n    renderRawItem: Function,\n    maxCount: [Number, String],\n    renderRest: Function,\n    /** @private Do not use in your production. Render raw node that need wrap Item by developer self */\n    renderRawRest: Function,\n    suffix: PropTypes.any,\n    component: String,\n    itemComponent: PropTypes.any,\n    /** @private This API may be refactor since not well design */\n    onVisibleChange: Function,\n    /** When set to `full`, ssr will render full items by default and remove at client side */\n    ssr: String,\n    onMousedown: Function\n  };\n};\nconst Overflow = defineComponent({\n  name: 'Overflow',\n  inheritAttrs: false,\n  props: overflowProps(),\n  emits: ['visibleChange'],\n  setup(props, _ref) {\n    let {\n      attrs,\n      emit,\n      slots\n    } = _ref;\n    const fullySSR = computed(() => props.ssr === 'full');\n    const containerWidth = shallowRef(null);\n    const mergedContainerWidth = computed(() => containerWidth.value || 0);\n    const itemWidths = shallowRef(new Map());\n    const prevRestWidth = shallowRef(0);\n    const restWidth = shallowRef(0);\n    const suffixWidth = shallowRef(0);\n    const suffixFixedStart = shallowRef(null);\n    const displayCount = shallowRef(null);\n    const mergedDisplayCount = computed(() => {\n      if (displayCount.value === null && fullySSR.value) {\n        return Number.MAX_SAFE_INTEGER;\n      }\n      return displayCount.value || 0;\n    });\n    const restReady = shallowRef(false);\n    const itemPrefixCls = computed(() => `${props.prefixCls}-item`);\n    // Always use the max width to avoid blink\n    const mergedRestWidth = computed(() => Math.max(prevRestWidth.value, restWidth.value));\n    // ================================= Data =================================\n    const isResponsive = computed(() => !!(props.data.length && props.maxCount === RESPONSIVE));\n    const invalidate = computed(() => props.maxCount === INVALIDATE);\n    /**\n     * When is `responsive`, we will always render rest node to get the real width of it for calculation\n     */\n    const showRest = computed(() => isResponsive.value || typeof props.maxCount === 'number' && props.data.length > props.maxCount);\n    const mergedData = computed(() => {\n      let items = props.data;\n      if (isResponsive.value) {\n        if (containerWidth.value === null && fullySSR.value) {\n          items = props.data;\n        } else {\n          items = props.data.slice(0, Math.min(props.data.length, mergedContainerWidth.value / props.itemWidth));\n        }\n      } else if (typeof props.maxCount === 'number') {\n        items = props.data.slice(0, props.maxCount);\n      }\n      return items;\n    });\n    const omittedItems = computed(() => {\n      if (isResponsive.value) {\n        return props.data.slice(mergedDisplayCount.value + 1);\n      }\n      return props.data.slice(mergedData.value.length);\n    });\n    // ================================= Item =================================\n    const getKey = (item, index) => {\n      var _a;\n      if (typeof props.itemKey === 'function') {\n        return props.itemKey(item);\n      }\n      return (_a = props.itemKey && (item === null || item === void 0 ? void 0 : item[props.itemKey])) !== null && _a !== void 0 ? _a : index;\n    };\n    const mergedRenderItem = computed(() => props.renderItem || (item => item));\n    const updateDisplayCount = (count, notReady) => {\n      displayCount.value = count;\n      if (!notReady) {\n        restReady.value = count < props.data.length - 1;\n        emit('visibleChange', count);\n      }\n    };\n    // ================================= Size =================================\n    const onOverflowResize = (_, element) => {\n      containerWidth.value = element.clientWidth;\n    };\n    const registerSize = (key, width) => {\n      const clone = new Map(itemWidths.value);\n      if (width === null) {\n        clone.delete(key);\n      } else {\n        clone.set(key, width);\n      }\n      itemWidths.value = clone;\n    };\n    const registerOverflowSize = (_, width) => {\n      prevRestWidth.value = restWidth.value;\n      restWidth.value = width;\n    };\n    const registerSuffixSize = (_, width) => {\n      suffixWidth.value = width;\n    };\n    // ================================ Effect ================================\n    const getItemWidth = index => {\n      return itemWidths.value.get(getKey(mergedData.value[index], index));\n    };\n    watch([mergedContainerWidth, itemWidths, restWidth, suffixWidth, () => props.itemKey, mergedData], () => {\n      if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {\n        let totalWidth = suffixWidth.value;\n        const len = mergedData.value.length;\n        const lastIndex = len - 1;\n        // When data count change to 0, reset this since not loop will reach\n        if (!len) {\n          updateDisplayCount(0);\n          suffixFixedStart.value = null;\n          return;\n        }\n        for (let i = 0; i < len; i += 1) {\n          const currentItemWidth = getItemWidth(i);\n          // Break since data not ready\n          if (currentItemWidth === undefined) {\n            updateDisplayCount(i - 1, true);\n            break;\n          }\n          // Find best match\n          totalWidth += currentItemWidth;\n          if (\n          // Only one means `totalWidth` is the final width\n          lastIndex === 0 && totalWidth <= mergedContainerWidth.value ||\n          // Last two width will be the final width\n          i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value) {\n            // Additional check if match the end\n            updateDisplayCount(lastIndex);\n            suffixFixedStart.value = null;\n            break;\n          } else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {\n            // Can not hold all the content to show rest\n            updateDisplayCount(i - 1);\n            suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;\n            break;\n          }\n        }\n        if (props.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) {\n          suffixFixedStart.value = null;\n        }\n      }\n    });\n    return () => {\n      // ================================ Render ================================\n      const displayRest = restReady.value && !!omittedItems.value.length;\n      const {\n        itemComponent,\n        renderRawItem,\n        renderRawRest,\n        renderRest,\n        prefixCls = 'rc-overflow',\n        suffix,\n        component: Component = 'div',\n        id,\n        onMousedown\n      } = props;\n      const {\n          class: className,\n          style\n        } = attrs,\n        restAttrs = __rest(attrs, [\"class\", \"style\"]);\n      let suffixStyle = {};\n      if (suffixFixedStart.value !== null && isResponsive.value) {\n        suffixStyle = {\n          position: 'absolute',\n          left: `${suffixFixedStart.value}px`,\n          top: 0\n        };\n      }\n      const itemSharedProps = {\n        prefixCls: itemPrefixCls.value,\n        responsive: isResponsive.value,\n        component: itemComponent,\n        invalidate: invalidate.value\n      };\n      // >>>>> Choice render fun by `renderRawItem`\n      const internalRenderItemNode = renderRawItem ? (item, index) => {\n        const key = getKey(item, index);\n        return _createVNode(OverflowContextProvider, {\n          \"key\": key,\n          \"value\": _extends(_extends({}, itemSharedProps), {\n            order: index,\n            item,\n            itemKey: key,\n            registerSize,\n            display: index <= mergedDisplayCount.value\n          })\n        }, {\n          default: () => [renderRawItem(item, index)]\n        });\n      } : (item, index) => {\n        const key = getKey(item, index);\n        return _createVNode(Item, _objectSpread(_objectSpread({}, itemSharedProps), {}, {\n          \"order\": index,\n          \"key\": key,\n          \"item\": item,\n          \"renderItem\": mergedRenderItem.value,\n          \"itemKey\": key,\n          \"registerSize\": registerSize,\n          \"display\": index <= mergedDisplayCount.value\n        }), null);\n      };\n      // >>>>> Rest node\n      let restNode = () => null;\n      const restContextProps = {\n        order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,\n        className: `${itemPrefixCls.value} ${itemPrefixCls.value}-rest`,\n        registerSize: registerOverflowSize,\n        display: displayRest\n      };\n      if (!renderRawRest) {\n        const mergedRenderRest = renderRest || defaultRenderRest;\n        restNode = () => _createVNode(Item, _objectSpread(_objectSpread({}, itemSharedProps), restContextProps), {\n          default: () => typeof mergedRenderRest === 'function' ? mergedRenderRest(omittedItems.value) : mergedRenderRest\n        });\n      } else if (renderRawRest) {\n        restNode = () => _createVNode(OverflowContextProvider, {\n          \"value\": _extends(_extends({}, itemSharedProps), restContextProps)\n        }, {\n          default: () => [renderRawRest(omittedItems.value)]\n        });\n      }\n      const overflowNode = () => {\n        var _a;\n        return _createVNode(Component, _objectSpread({\n          \"id\": id,\n          \"class\": classNames(!invalidate.value && prefixCls, className),\n          \"style\": style,\n          \"onMousedown\": onMousedown\n        }, restAttrs), {\n          default: () => [mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && _createVNode(Item, _objectSpread(_objectSpread({}, itemSharedProps), {}, {\n            \"order\": mergedDisplayCount.value,\n            \"class\": `${itemPrefixCls.value}-suffix`,\n            \"registerSize\": registerSuffixSize,\n            \"display\": true,\n            \"style\": suffixStyle\n          }), {\n            default: () => suffix\n          }), (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]\n        });\n      };\n      // 使用 disabled  避免结构不一致 导致子组件 rerender\n      return _createVNode(ResizeObserver, {\n        \"disabled\": !isResponsive.value,\n        \"onResize\": onOverflowResize\n      }, {\n        default: overflowNode\n      });\n    };\n  }\n});\nOverflow.Item = RawItem;\nOverflow.RESPONSIVE = RESPONSIVE;\nOverflow.INVALIDATE = INVALIDATE;\nexport default Overflow;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}