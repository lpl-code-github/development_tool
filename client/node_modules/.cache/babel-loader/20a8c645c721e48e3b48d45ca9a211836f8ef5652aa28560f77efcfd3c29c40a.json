{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, watch, computed, watchEffect } from 'vue';\nimport { qrProps } from './interface';\nimport qrcodegen from './qrcodegen';\nconst ERROR_LEVEL_MAP = {\n  L: qrcodegen.QrCode.Ecc.LOW,\n  M: qrcodegen.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen.QrCode.Ecc.QUARTILE,\n  H: qrcodegen.QrCode.Ecc.HIGH\n};\nconst DEFAULT_SIZE = 128;\nconst DEFAULT_LEVEL = 'L';\nconst DEFAULT_BGCOLOR = '#FFFFFF';\nconst DEFAULT_FGCOLOR = '#000000';\nconst DEFAULT_INCLUDEMARGIN = false;\nconst SPEC_MARGIN_SIZE = 4;\nconst DEFAULT_MARGIN_SIZE = 0;\n// This is *very* rough estimate of max amount of QRCode allowed to be covered.\n// It is \"wrong\" in a lot of ways (area is a terrible way to estimate, it\n// really should be number of modules covered), but if for some reason we don't\n// get an explicit height or width, I'd rather default to something than throw.\nconst DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules) {\n  let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ops = [];\n  modules.forEach(function (row, y) {\n    let start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        // M0 0h7v1H0z injects the space with the move and drops the comma,\n        // saving a char per operation\n        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);\n        start = null;\n        return;\n      }\n      // end of row, clean up or skip\n      if (x === row.length - 1) {\n        if (!cell) {\n          // We would have closed the op above already so this can only mean\n          // 2+ light modules in a row.\n          return;\n        }\n        if (start === null) {\n          // Just a single dark module.\n          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n        } else {\n          // Otherwise finish the current line.\n          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n}\n// We could just do this in generatePath, except that we want to support\n// non-Path2D canvas, so we need to keep it an explicit step.\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map((row, y) => {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map((cell, x) => {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  const numCells = cells.length + margin * 2;\n  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  const scale = numCells / size;\n  const w = (imageSettings.width || defaultSize) * scale;\n  const h = (imageSettings.height || defaultSize) * scale;\n  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  let excavation = null;\n  if (imageSettings.excavate) {\n    const floorX = Math.floor(x);\n    const floorY = Math.floor(y);\n    const ceilW = Math.ceil(w + x - floorX);\n    const ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n  return {\n    x,\n    y,\n    h,\n    w,\n    excavation\n  };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.floor(marginSize);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n// For canvas we're going to switch our drawing mode based on whether or not\n// the environment supports Path2D. We only need the constructor to be\n// supported, but Edge doesn't actually support the path (string) type\n// argument. Luckily it also doesn't support the addPath() method. We can\n// treat that as the same thing.\nconst SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nexport const QRCodeCanvas = defineComponent({\n  name: 'QRCodeCanvas',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number\n  }),\n  setup(props, _ref) {\n    let {\n      attrs,\n      expose\n    } = _ref;\n    const imgSrc = computed(() => {\n      var _a;\n      return (_a = props.imageSettings) === null || _a === void 0 ? void 0 : _a.src;\n    });\n    const _canvas = shallowRef(null);\n    const _image = shallowRef(null);\n    const isImgLoaded = shallowRef(false);\n    expose({\n      toDataURL: (type, quality) => {\n        var _a;\n        return (_a = _canvas.value) === null || _a === void 0 ? void 0 : _a.toDataURL(type, quality);\n      }\n    });\n    watchEffect(() => {\n      const {\n        value,\n        size = DEFAULT_SIZE,\n        level = DEFAULT_LEVEL,\n        bgColor = DEFAULT_BGCOLOR,\n        fgColor = DEFAULT_FGCOLOR,\n        includeMargin = DEFAULT_INCLUDEMARGIN,\n        marginSize,\n        imageSettings\n      } = props;\n      if (_canvas.value != null) {\n        const canvas = _canvas.value;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n          return;\n        }\n        let cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n        const margin = getMarginSize(includeMargin, marginSize);\n        const numCells = cells.length + margin * 2;\n        const calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n        const image = _image.value;\n        const haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n          }\n        }\n        // We're going to scale this so that the number of drawable units\n        // matches the number of cells. This avoids rounding issues, but does\n        // result in some potentially unwanted single pixel issues between\n        // blocks, only in environments that don't support Path2D.\n        const pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        const scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        // Draw solid background, only paint dark modules.\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          // $FlowFixMe: Path2D c'tor doesn't support args yet.\n          ctx.fill(new Path2D(generatePath(cells, margin)));\n        } else {\n          cells.forEach(function (row, rdx) {\n            row.forEach(function (cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n        }\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(imgSrc, () => {\n      isImgLoaded.value = false;\n    });\n    return () => {\n      var _a;\n      const size = (_a = props.size) !== null && _a !== void 0 ? _a : DEFAULT_SIZE;\n      const canvasStyle = {\n        height: `${size}px`,\n        width: `${size}px`\n      };\n      let img = null;\n      if (imgSrc.value != null) {\n        img = _createVNode(\"img\", {\n          \"src\": imgSrc.value,\n          \"key\": imgSrc.value,\n          \"style\": {\n            display: 'none'\n          },\n          \"onLoad\": () => {\n            isImgLoaded.value = true;\n          },\n          \"ref\": _image\n        }, null);\n      }\n      return _createVNode(_Fragment, null, [_createVNode(\"canvas\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"style\": [canvasStyle, attrs.style],\n        \"ref\": _canvas\n      }), null), img]);\n    };\n  }\n});\nexport const QRCodeSVG = defineComponent({\n  name: 'QRCodeSVG',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    color: String,\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number,\n    title: String\n  }),\n  setup(props) {\n    let cells = null;\n    let margin = null;\n    let numCells = null;\n    let calculatedImageSettings = null;\n    let fgPath = null;\n    let image = null;\n    watchEffect(() => {\n      const {\n        value,\n        size = DEFAULT_SIZE,\n        level = DEFAULT_LEVEL,\n        includeMargin = DEFAULT_INCLUDEMARGIN,\n        marginSize,\n        imageSettings\n      } = props;\n      cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n      margin = getMarginSize(includeMargin, marginSize);\n      numCells = cells.length + margin * 2;\n      calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n      if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n          cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = _createVNode(\"image\", {\n          \"xlink:href\": imageSettings.src,\n          \"height\": calculatedImageSettings.h,\n          \"width\": calculatedImageSettings.w,\n          \"x\": calculatedImageSettings.x + margin,\n          \"y\": calculatedImageSettings.y + margin,\n          \"preserveAspectRatio\": \"none\"\n        }, null);\n      }\n      // Drawing strategy: instead of a rect per module, we're going to create a\n      // single path for the dark modules and layer that on top of a light rect,\n      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's\n      // way faster than DOM ops.\n      // For level 1, 441 nodes -> 2\n      // For level 40, 31329 -> 2\n      fgPath = generatePath(cells, margin);\n    });\n    return () => {\n      const bgColor = props.bgColor && DEFAULT_BGCOLOR;\n      const fgColor = props.fgColor && DEFAULT_FGCOLOR;\n      return _createVNode(\"svg\", {\n        \"height\": props.size,\n        \"width\": props.size,\n        \"viewBox\": `0 0 ${numCells} ${numCells}`\n      }, [!!props.title && _createVNode(\"title\", null, [props.title]), _createVNode(\"path\", {\n        \"fill\": bgColor,\n        \"d\": `M0,0 h${numCells}v${numCells}H0z`,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), _createVNode(\"path\", {\n        \"fill\": fgColor,\n        \"d\": fgPath,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), image]);\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","Fragment","_Fragment","createVNode","_createVNode","defineComponent","shallowRef","watch","computed","watchEffect","qrProps","qrcodegen","ERROR_LEVEL_MAP","L","QrCode","Ecc","LOW","M","MEDIUM","Q","QUARTILE","H","HIGH","DEFAULT_SIZE","DEFAULT_LEVEL","DEFAULT_BGCOLOR","DEFAULT_FGCOLOR","DEFAULT_INCLUDEMARGIN","SPEC_MARGIN_SIZE","DEFAULT_MARGIN_SIZE","DEFAULT_IMG_SCALE","generatePath","modules","margin","arguments","length","undefined","ops","forEach","row","y","start","cell","x","push","join","excavateModules","excavation","slice","map","h","w","getImageSettings","cells","size","imageSettings","numCells","defaultSize","Math","floor","scale","width","height","excavate","floorX","floorY","ceilW","ceil","ceilH","getMarginSize","includeMargin","marginSize","SUPPORTS_PATH2D","Path2D","addPath","e","QRCodeCanvas","name","inheritAttrs","props","level","String","bgColor","fgColor","Number","setup","_ref","attrs","expose","imgSrc","_a","src","_canvas","_image","isImgLoaded","toDataURL","type","quality","value","canvas","ctx","getContext","encodeText","getModules","calculatedImageSettings","image","haveImageToRender","complete","naturalHeight","naturalWidth","pixelRatio","window","devicePixelRatio","fillStyle","fillRect","fill","rdx","cdx","drawImage","flush","canvasStyle","img","display","onLoad","style","QRCodeSVG","color","title","fgPath"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/qrcode/QRCode.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, watch, computed, watchEffect } from 'vue';\nimport { qrProps } from './interface';\nimport qrcodegen from './qrcodegen';\nconst ERROR_LEVEL_MAP = {\n  L: qrcodegen.QrCode.Ecc.LOW,\n  M: qrcodegen.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen.QrCode.Ecc.QUARTILE,\n  H: qrcodegen.QrCode.Ecc.HIGH\n};\nconst DEFAULT_SIZE = 128;\nconst DEFAULT_LEVEL = 'L';\nconst DEFAULT_BGCOLOR = '#FFFFFF';\nconst DEFAULT_FGCOLOR = '#000000';\nconst DEFAULT_INCLUDEMARGIN = false;\nconst SPEC_MARGIN_SIZE = 4;\nconst DEFAULT_MARGIN_SIZE = 0;\n// This is *very* rough estimate of max amount of QRCode allowed to be covered.\n// It is \"wrong\" in a lot of ways (area is a terrible way to estimate, it\n// really should be number of modules covered), but if for some reason we don't\n// get an explicit height or width, I'd rather default to something than throw.\nconst DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules) {\n  let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ops = [];\n  modules.forEach(function (row, y) {\n    let start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        // M0 0h7v1H0z injects the space with the move and drops the comma,\n        // saving a char per operation\n        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);\n        start = null;\n        return;\n      }\n      // end of row, clean up or skip\n      if (x === row.length - 1) {\n        if (!cell) {\n          // We would have closed the op above already so this can only mean\n          // 2+ light modules in a row.\n          return;\n        }\n        if (start === null) {\n          // Just a single dark module.\n          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n        } else {\n          // Otherwise finish the current line.\n          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);\n        }\n        return;\n      }\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join('');\n}\n// We could just do this in generatePath, except that we want to support\n// non-Path2D canvas, so we need to keep it an explicit step.\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map((row, y) => {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n    return row.map((cell, x) => {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n      return false;\n    });\n  });\n}\nfunction getImageSettings(cells, size, margin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n  const numCells = cells.length + margin * 2;\n  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  const scale = numCells / size;\n  const w = (imageSettings.width || defaultSize) * scale;\n  const h = (imageSettings.height || defaultSize) * scale;\n  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  let excavation = null;\n  if (imageSettings.excavate) {\n    const floorX = Math.floor(x);\n    const floorY = Math.floor(y);\n    const ceilW = Math.ceil(w + x - floorX);\n    const ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n  return {\n    x,\n    y,\n    h,\n    w,\n    excavation\n  };\n}\nfunction getMarginSize(includeMargin, marginSize) {\n  if (marginSize != null) {\n    return Math.floor(marginSize);\n  }\n  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;\n}\n// For canvas we're going to switch our drawing mode based on whether or not\n// the environment supports Path2D. We only need the constructor to be\n// supported, but Edge doesn't actually support the path (string) type\n// argument. Luckily it also doesn't support the addPath() method. We can\n// treat that as the same thing.\nconst SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n  return true;\n}();\nexport const QRCodeCanvas = defineComponent({\n  name: 'QRCodeCanvas',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number\n  }),\n  setup(props, _ref) {\n    let {\n      attrs,\n      expose\n    } = _ref;\n    const imgSrc = computed(() => {\n      var _a;\n      return (_a = props.imageSettings) === null || _a === void 0 ? void 0 : _a.src;\n    });\n    const _canvas = shallowRef(null);\n    const _image = shallowRef(null);\n    const isImgLoaded = shallowRef(false);\n    expose({\n      toDataURL: (type, quality) => {\n        var _a;\n        return (_a = _canvas.value) === null || _a === void 0 ? void 0 : _a.toDataURL(type, quality);\n      }\n    });\n    watchEffect(() => {\n      const {\n        value,\n        size = DEFAULT_SIZE,\n        level = DEFAULT_LEVEL,\n        bgColor = DEFAULT_BGCOLOR,\n        fgColor = DEFAULT_FGCOLOR,\n        includeMargin = DEFAULT_INCLUDEMARGIN,\n        marginSize,\n        imageSettings\n      } = props;\n      if (_canvas.value != null) {\n        const canvas = _canvas.value;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n          return;\n        }\n        let cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n        const margin = getMarginSize(includeMargin, marginSize);\n        const numCells = cells.length + margin * 2;\n        const calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n        const image = _image.value;\n        const haveImageToRender = isImgLoaded.value && calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n        if (haveImageToRender) {\n          if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n          }\n        }\n        // We're going to scale this so that the number of drawable units\n        // matches the number of cells. This avoids rounding issues, but does\n        // result in some potentially unwanted single pixel issues between\n        // blocks, only in environments that don't support Path2D.\n        const pixelRatio = window.devicePixelRatio || 1;\n        canvas.height = canvas.width = size * pixelRatio;\n        const scale = size / numCells * pixelRatio;\n        ctx.scale(scale, scale);\n        // Draw solid background, only paint dark modules.\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, numCells, numCells);\n        ctx.fillStyle = fgColor;\n        if (SUPPORTS_PATH2D) {\n          // $FlowFixMe: Path2D c'tor doesn't support args yet.\n          ctx.fill(new Path2D(generatePath(cells, margin)));\n        } else {\n          cells.forEach(function (row, rdx) {\n            row.forEach(function (cell, cdx) {\n              if (cell) {\n                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n              }\n            });\n          });\n        }\n        if (haveImageToRender) {\n          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n        }\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(imgSrc, () => {\n      isImgLoaded.value = false;\n    });\n    return () => {\n      var _a;\n      const size = (_a = props.size) !== null && _a !== void 0 ? _a : DEFAULT_SIZE;\n      const canvasStyle = {\n        height: `${size}px`,\n        width: `${size}px`\n      };\n      let img = null;\n      if (imgSrc.value != null) {\n        img = _createVNode(\"img\", {\n          \"src\": imgSrc.value,\n          \"key\": imgSrc.value,\n          \"style\": {\n            display: 'none'\n          },\n          \"onLoad\": () => {\n            isImgLoaded.value = true;\n          },\n          \"ref\": _image\n        }, null);\n      }\n      return _createVNode(_Fragment, null, [_createVNode(\"canvas\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"style\": [canvasStyle, attrs.style],\n        \"ref\": _canvas\n      }), null), img]);\n    };\n  }\n});\nexport const QRCodeSVG = defineComponent({\n  name: 'QRCodeSVG',\n  inheritAttrs: false,\n  props: _extends(_extends({}, qrProps()), {\n    color: String,\n    level: String,\n    bgColor: String,\n    fgColor: String,\n    marginSize: Number,\n    title: String\n  }),\n  setup(props) {\n    let cells = null;\n    let margin = null;\n    let numCells = null;\n    let calculatedImageSettings = null;\n    let fgPath = null;\n    let image = null;\n    watchEffect(() => {\n      const {\n        value,\n        size = DEFAULT_SIZE,\n        level = DEFAULT_LEVEL,\n        includeMargin = DEFAULT_INCLUDEMARGIN,\n        marginSize,\n        imageSettings\n      } = props;\n      cells = qrcodegen.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n      margin = getMarginSize(includeMargin, marginSize);\n      numCells = cells.length + margin * 2;\n      calculatedImageSettings = getImageSettings(cells, size, margin, imageSettings);\n      if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n          cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = _createVNode(\"image\", {\n          \"xlink:href\": imageSettings.src,\n          \"height\": calculatedImageSettings.h,\n          \"width\": calculatedImageSettings.w,\n          \"x\": calculatedImageSettings.x + margin,\n          \"y\": calculatedImageSettings.y + margin,\n          \"preserveAspectRatio\": \"none\"\n        }, null);\n      }\n      // Drawing strategy: instead of a rect per module, we're going to create a\n      // single path for the dark modules and layer that on top of a light rect,\n      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's\n      // way faster than DOM ops.\n      // For level 1, 441 nodes -> 2\n      // For level 40, 31329 -> 2\n      fgPath = generatePath(cells, margin);\n    });\n    return () => {\n      const bgColor = props.bgColor && DEFAULT_BGCOLOR;\n      const fgColor = props.fgColor && DEFAULT_FGCOLOR;\n      return _createVNode(\"svg\", {\n        \"height\": props.size,\n        \"width\": props.size,\n        \"viewBox\": `0 0 ${numCells} ${numCells}`\n      }, [!!props.title && _createVNode(\"title\", null, [props.title]), _createVNode(\"path\", {\n        \"fill\": bgColor,\n        \"d\": `M0,0 h${numCells}v${numCells}H0z`,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), _createVNode(\"path\", {\n        \"fill\": fgColor,\n        \"d\": fgPath,\n        \"shape-rendering\": \"crispEdges\"\n      }, null), image]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}