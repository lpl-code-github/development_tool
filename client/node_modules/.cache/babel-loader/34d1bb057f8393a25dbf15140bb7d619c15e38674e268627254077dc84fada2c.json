{"ast":null,"code":"import { nextTick, defineComponent, ref, computed, onMounted, onUpdated, watch, onUnmounted } from 'vue';\nimport { alignElement, alignPoint } from 'dom-align';\nimport addEventListener from '../vc-util/Dom/addEventListener';\nimport { cloneElement } from '../_util/vnode';\nimport isVisible from '../vc-util/Dom/isVisible';\nimport { isSamePoint, restoreFocus, monitorResize } from './util';\nimport useBuffer from './hooks/useBuffer';\nimport isEqual from 'lodash-es/isEqual';\nexport const alignProps = {\n  align: Object,\n  target: [Object, Function],\n  onAlign: Function,\n  monitorBufferTime: Number,\n  monitorWindowResize: Boolean,\n  disabled: Boolean\n};\nfunction getElement(func) {\n  if (typeof func !== 'function') return null;\n  return func();\n}\nfunction getPoint(point) {\n  if (typeof point !== 'object' || !point) return null;\n  return point;\n}\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Align',\n  props: alignProps,\n  emits: ['align'],\n  setup(props, _ref) {\n    let {\n      expose,\n      slots\n    } = _ref;\n    const cacheRef = ref({});\n    const nodeRef = ref();\n    const [forceAlign, cancelForceAlign] = useBuffer(() => {\n      const {\n        disabled: latestDisabled,\n        target: latestTarget,\n        align: latestAlign,\n        onAlign: latestOnAlign\n      } = props;\n      if (!latestDisabled && latestTarget && nodeRef.value) {\n        const source = nodeRef.value;\n        let result;\n        const element = getElement(latestTarget);\n        const point = getPoint(latestTarget);\n        cacheRef.value.element = element;\n        cacheRef.value.point = point;\n        cacheRef.value.align = latestAlign;\n        // IE lose focus after element realign\n        // We should record activeElement and restore later\n        const {\n          activeElement\n        } = document;\n        // We only align when element is visible\n        if (element && isVisible(element)) {\n          result = alignElement(source, element, latestAlign);\n        } else if (point) {\n          result = alignPoint(source, point, latestAlign);\n        }\n        restoreFocus(activeElement, source);\n        if (latestOnAlign && result) {\n          latestOnAlign(source, result);\n        }\n        return true;\n      }\n      return false;\n    }, computed(() => props.monitorBufferTime));\n    // ===================== Effect =====================\n    // Listen for target updated\n    const resizeMonitor = ref({\n      cancel: () => {}\n    });\n    // Listen for source updated\n    const sourceResizeMonitor = ref({\n      cancel: () => {}\n    });\n    const goAlign = () => {\n      const target = props.target;\n      const element = getElement(target);\n      const point = getPoint(target);\n      if (nodeRef.value !== sourceResizeMonitor.value.element) {\n        sourceResizeMonitor.value.cancel();\n        sourceResizeMonitor.value.element = nodeRef.value;\n        sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign);\n      }\n      if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual(cacheRef.value.align, props.align)) {\n        forceAlign();\n        // Add resize observer\n        if (resizeMonitor.value.element !== element) {\n          resizeMonitor.value.cancel();\n          resizeMonitor.value.element = element;\n          resizeMonitor.value.cancel = monitorResize(element, forceAlign);\n        }\n      }\n    };\n    onMounted(() => {\n      nextTick(() => {\n        goAlign();\n      });\n    });\n    onUpdated(() => {\n      nextTick(() => {\n        goAlign();\n      });\n    });\n    // Listen for disabled change\n    watch(() => props.disabled, disabled => {\n      if (!disabled) {\n        forceAlign();\n      } else {\n        cancelForceAlign();\n      }\n    }, {\n      immediate: true,\n      flush: 'post'\n    });\n    // Listen for window resize\n    const winResizeRef = ref(null);\n    watch(() => props.monitorWindowResize, monitorWindowResize => {\n      if (monitorWindowResize) {\n        if (!winResizeRef.value) {\n          winResizeRef.value = addEventListener(window, 'resize', forceAlign);\n        }\n      } else if (winResizeRef.value) {\n        winResizeRef.value.remove();\n        winResizeRef.value = null;\n      }\n    }, {\n      flush: 'post'\n    });\n    onUnmounted(() => {\n      resizeMonitor.value.cancel();\n      sourceResizeMonitor.value.cancel();\n      if (winResizeRef.value) winResizeRef.value.remove();\n      cancelForceAlign();\n    });\n    expose({\n      forceAlign: () => forceAlign(true)\n    });\n    return () => {\n      const child = slots === null || slots === void 0 ? void 0 : slots.default();\n      if (child) {\n        return cloneElement(child[0], {\n          ref: nodeRef\n        }, true, true);\n      }\n      return null;\n    };\n  }\n});","map":{"version":3,"names":["nextTick","defineComponent","ref","computed","onMounted","onUpdated","watch","onUnmounted","alignElement","alignPoint","addEventListener","cloneElement","isVisible","isSamePoint","restoreFocus","monitorResize","useBuffer","isEqual","alignProps","align","Object","target","Function","onAlign","monitorBufferTime","Number","monitorWindowResize","Boolean","disabled","getElement","func","getPoint","point","compatConfig","MODE","name","props","emits","setup","_ref","expose","slots","cacheRef","nodeRef","forceAlign","cancelForceAlign","latestDisabled","latestTarget","latestAlign","latestOnAlign","value","source","result","element","activeElement","document","resizeMonitor","cancel","sourceResizeMonitor","goAlign","immediate","flush","winResizeRef","window","remove","child","default"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-align/Align.js"],"sourcesContent":["import { nextTick, defineComponent, ref, computed, onMounted, onUpdated, watch, onUnmounted } from 'vue';\nimport { alignElement, alignPoint } from 'dom-align';\nimport addEventListener from '../vc-util/Dom/addEventListener';\nimport { cloneElement } from '../_util/vnode';\nimport isVisible from '../vc-util/Dom/isVisible';\nimport { isSamePoint, restoreFocus, monitorResize } from './util';\nimport useBuffer from './hooks/useBuffer';\nimport isEqual from 'lodash-es/isEqual';\nexport const alignProps = {\n  align: Object,\n  target: [Object, Function],\n  onAlign: Function,\n  monitorBufferTime: Number,\n  monitorWindowResize: Boolean,\n  disabled: Boolean\n};\nfunction getElement(func) {\n  if (typeof func !== 'function') return null;\n  return func();\n}\nfunction getPoint(point) {\n  if (typeof point !== 'object' || !point) return null;\n  return point;\n}\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Align',\n  props: alignProps,\n  emits: ['align'],\n  setup(props, _ref) {\n    let {\n      expose,\n      slots\n    } = _ref;\n    const cacheRef = ref({});\n    const nodeRef = ref();\n    const [forceAlign, cancelForceAlign] = useBuffer(() => {\n      const {\n        disabled: latestDisabled,\n        target: latestTarget,\n        align: latestAlign,\n        onAlign: latestOnAlign\n      } = props;\n      if (!latestDisabled && latestTarget && nodeRef.value) {\n        const source = nodeRef.value;\n        let result;\n        const element = getElement(latestTarget);\n        const point = getPoint(latestTarget);\n        cacheRef.value.element = element;\n        cacheRef.value.point = point;\n        cacheRef.value.align = latestAlign;\n        // IE lose focus after element realign\n        // We should record activeElement and restore later\n        const {\n          activeElement\n        } = document;\n        // We only align when element is visible\n        if (element && isVisible(element)) {\n          result = alignElement(source, element, latestAlign);\n        } else if (point) {\n          result = alignPoint(source, point, latestAlign);\n        }\n        restoreFocus(activeElement, source);\n        if (latestOnAlign && result) {\n          latestOnAlign(source, result);\n        }\n        return true;\n      }\n      return false;\n    }, computed(() => props.monitorBufferTime));\n    // ===================== Effect =====================\n    // Listen for target updated\n    const resizeMonitor = ref({\n      cancel: () => {}\n    });\n    // Listen for source updated\n    const sourceResizeMonitor = ref({\n      cancel: () => {}\n    });\n    const goAlign = () => {\n      const target = props.target;\n      const element = getElement(target);\n      const point = getPoint(target);\n      if (nodeRef.value !== sourceResizeMonitor.value.element) {\n        sourceResizeMonitor.value.cancel();\n        sourceResizeMonitor.value.element = nodeRef.value;\n        sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign);\n      }\n      if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual(cacheRef.value.align, props.align)) {\n        forceAlign();\n        // Add resize observer\n        if (resizeMonitor.value.element !== element) {\n          resizeMonitor.value.cancel();\n          resizeMonitor.value.element = element;\n          resizeMonitor.value.cancel = monitorResize(element, forceAlign);\n        }\n      }\n    };\n    onMounted(() => {\n      nextTick(() => {\n        goAlign();\n      });\n    });\n    onUpdated(() => {\n      nextTick(() => {\n        goAlign();\n      });\n    });\n    // Listen for disabled change\n    watch(() => props.disabled, disabled => {\n      if (!disabled) {\n        forceAlign();\n      } else {\n        cancelForceAlign();\n      }\n    }, {\n      immediate: true,\n      flush: 'post'\n    });\n    // Listen for window resize\n    const winResizeRef = ref(null);\n    watch(() => props.monitorWindowResize, monitorWindowResize => {\n      if (monitorWindowResize) {\n        if (!winResizeRef.value) {\n          winResizeRef.value = addEventListener(window, 'resize', forceAlign);\n        }\n      } else if (winResizeRef.value) {\n        winResizeRef.value.remove();\n        winResizeRef.value = null;\n      }\n    }, {\n      flush: 'post'\n    });\n    onUnmounted(() => {\n      resizeMonitor.value.cancel();\n      sourceResizeMonitor.value.cancel();\n      if (winResizeRef.value) winResizeRef.value.remove();\n      cancelForceAlign();\n    });\n    expose({\n      forceAlign: () => forceAlign(true)\n    });\n    return () => {\n      const child = slots === null || slots === void 0 ? void 0 : slots.default();\n      if (child) {\n        return cloneElement(child[0], {\n          ref: nodeRef\n        }, true, true);\n      }\n      return null;\n    };\n  }\n});"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,eAAe,EAAEC,GAAG,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,SAAS,EAAEC,KAAK,EAAEC,WAAW,QAAQ,KAAK;AACxG,SAASC,YAAY,EAAEC,UAAU,QAAQ,WAAW;AACpD,OAAOC,gBAAgB,MAAM,iCAAiC;AAC9D,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,OAAOC,SAAS,MAAM,0BAA0B;AAChD,SAASC,WAAW,EAAEC,YAAY,EAAEC,aAAa,QAAQ,QAAQ;AACjE,OAAOC,SAAS,MAAM,mBAAmB;AACzC,OAAOC,OAAO,MAAM,mBAAmB;AACvC,OAAO,MAAMC,UAAU,GAAG;EACxBC,KAAK,EAAEC,MAAM;EACbC,MAAM,EAAE,CAACD,MAAM,EAAEE,QAAQ,CAAC;EAC1BC,OAAO,EAAED,QAAQ;EACjBE,iBAAiB,EAAEC,MAAM;EACzBC,mBAAmB,EAAEC,OAAO;EAC5BC,QAAQ,EAAED;AACZ,CAAC;AACD,SAASE,UAAUA,CAACC,IAAI,EAAE;EACxB,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE,OAAO,IAAI;EAC3C,OAAOA,IAAI,CAAC,CAAC;AACf;AACA,SAASC,QAAQA,CAACC,KAAK,EAAE;EACvB,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAACA,KAAK,EAAE,OAAO,IAAI;EACpD,OAAOA,KAAK;AACd;AACA,eAAe/B,eAAe,CAAC;EAC7BgC,YAAY,EAAE;IACZC,IAAI,EAAE;EACR,CAAC;EACDC,IAAI,EAAE,OAAO;EACbC,KAAK,EAAElB,UAAU;EACjBmB,KAAK,EAAE,CAAC,OAAO,CAAC;EAChBC,KAAKA,CAACF,KAAK,EAAEG,IAAI,EAAE;IACjB,IAAI;MACFC,MAAM;MACNC;IACF,CAAC,GAAGF,IAAI;IACR,MAAMG,QAAQ,GAAGxC,GAAG,CAAC,CAAC,CAAC,CAAC;IACxB,MAAMyC,OAAO,GAAGzC,GAAG,CAAC,CAAC;IACrB,MAAM,CAAC0C,UAAU,EAAEC,gBAAgB,CAAC,GAAG7B,SAAS,CAAC,MAAM;MACrD,MAAM;QACJY,QAAQ,EAAEkB,cAAc;QACxBzB,MAAM,EAAE0B,YAAY;QACpB5B,KAAK,EAAE6B,WAAW;QAClBzB,OAAO,EAAE0B;MACX,CAAC,GAAGb,KAAK;MACT,IAAI,CAACU,cAAc,IAAIC,YAAY,IAAIJ,OAAO,CAACO,KAAK,EAAE;QACpD,MAAMC,MAAM,GAAGR,OAAO,CAACO,KAAK;QAC5B,IAAIE,MAAM;QACV,MAAMC,OAAO,GAAGxB,UAAU,CAACkB,YAAY,CAAC;QACxC,MAAMf,KAAK,GAAGD,QAAQ,CAACgB,YAAY,CAAC;QACpCL,QAAQ,CAACQ,KAAK,CAACG,OAAO,GAAGA,OAAO;QAChCX,QAAQ,CAACQ,KAAK,CAAClB,KAAK,GAAGA,KAAK;QAC5BU,QAAQ,CAACQ,KAAK,CAAC/B,KAAK,GAAG6B,WAAW;QAClC;QACA;QACA,MAAM;UACJM;QACF,CAAC,GAAGC,QAAQ;QACZ;QACA,IAAIF,OAAO,IAAIzC,SAAS,CAACyC,OAAO,CAAC,EAAE;UACjCD,MAAM,GAAG5C,YAAY,CAAC2C,MAAM,EAAEE,OAAO,EAAEL,WAAW,CAAC;QACrD,CAAC,MAAM,IAAIhB,KAAK,EAAE;UAChBoB,MAAM,GAAG3C,UAAU,CAAC0C,MAAM,EAAEnB,KAAK,EAAEgB,WAAW,CAAC;QACjD;QACAlC,YAAY,CAACwC,aAAa,EAAEH,MAAM,CAAC;QACnC,IAAIF,aAAa,IAAIG,MAAM,EAAE;UAC3BH,aAAa,CAACE,MAAM,EAAEC,MAAM,CAAC;QAC/B;QACA,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC,EAAEjD,QAAQ,CAAC,MAAMiC,KAAK,CAACZ,iBAAiB,CAAC,CAAC;IAC3C;IACA;IACA,MAAMgC,aAAa,GAAGtD,GAAG,CAAC;MACxBuD,MAAM,EAAEA,CAAA,KAAM,CAAC;IACjB,CAAC,CAAC;IACF;IACA,MAAMC,mBAAmB,GAAGxD,GAAG,CAAC;MAC9BuD,MAAM,EAAEA,CAAA,KAAM,CAAC;IACjB,CAAC,CAAC;IACF,MAAME,OAAO,GAAGA,CAAA,KAAM;MACpB,MAAMtC,MAAM,GAAGe,KAAK,CAACf,MAAM;MAC3B,MAAMgC,OAAO,GAAGxB,UAAU,CAACR,MAAM,CAAC;MAClC,MAAMW,KAAK,GAAGD,QAAQ,CAACV,MAAM,CAAC;MAC9B,IAAIsB,OAAO,CAACO,KAAK,KAAKQ,mBAAmB,CAACR,KAAK,CAACG,OAAO,EAAE;QACvDK,mBAAmB,CAACR,KAAK,CAACO,MAAM,CAAC,CAAC;QAClCC,mBAAmB,CAACR,KAAK,CAACG,OAAO,GAAGV,OAAO,CAACO,KAAK;QACjDQ,mBAAmB,CAACR,KAAK,CAACO,MAAM,GAAG1C,aAAa,CAAC4B,OAAO,CAACO,KAAK,EAAEN,UAAU,CAAC;MAC7E;MACA,IAAIF,QAAQ,CAACQ,KAAK,CAACG,OAAO,KAAKA,OAAO,IAAI,CAACxC,WAAW,CAAC6B,QAAQ,CAACQ,KAAK,CAAClB,KAAK,EAAEA,KAAK,CAAC,IAAI,CAACf,OAAO,CAACyB,QAAQ,CAACQ,KAAK,CAAC/B,KAAK,EAAEiB,KAAK,CAACjB,KAAK,CAAC,EAAE;QAClIyB,UAAU,CAAC,CAAC;QACZ;QACA,IAAIY,aAAa,CAACN,KAAK,CAACG,OAAO,KAAKA,OAAO,EAAE;UAC3CG,aAAa,CAACN,KAAK,CAACO,MAAM,CAAC,CAAC;UAC5BD,aAAa,CAACN,KAAK,CAACG,OAAO,GAAGA,OAAO;UACrCG,aAAa,CAACN,KAAK,CAACO,MAAM,GAAG1C,aAAa,CAACsC,OAAO,EAAET,UAAU,CAAC;QACjE;MACF;IACF,CAAC;IACDxC,SAAS,CAAC,MAAM;MACdJ,QAAQ,CAAC,MAAM;QACb2D,OAAO,CAAC,CAAC;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;IACFtD,SAAS,CAAC,MAAM;MACdL,QAAQ,CAAC,MAAM;QACb2D,OAAO,CAAC,CAAC;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;IACF;IACArD,KAAK,CAAC,MAAM8B,KAAK,CAACR,QAAQ,EAAEA,QAAQ,IAAI;MACtC,IAAI,CAACA,QAAQ,EAAE;QACbgB,UAAU,CAAC,CAAC;MACd,CAAC,MAAM;QACLC,gBAAgB,CAAC,CAAC;MACpB;IACF,CAAC,EAAE;MACDe,SAAS,EAAE,IAAI;MACfC,KAAK,EAAE;IACT,CAAC,CAAC;IACF;IACA,MAAMC,YAAY,GAAG5D,GAAG,CAAC,IAAI,CAAC;IAC9BI,KAAK,CAAC,MAAM8B,KAAK,CAACV,mBAAmB,EAAEA,mBAAmB,IAAI;MAC5D,IAAIA,mBAAmB,EAAE;QACvB,IAAI,CAACoC,YAAY,CAACZ,KAAK,EAAE;UACvBY,YAAY,CAACZ,KAAK,GAAGxC,gBAAgB,CAACqD,MAAM,EAAE,QAAQ,EAAEnB,UAAU,CAAC;QACrE;MACF,CAAC,MAAM,IAAIkB,YAAY,CAACZ,KAAK,EAAE;QAC7BY,YAAY,CAACZ,KAAK,CAACc,MAAM,CAAC,CAAC;QAC3BF,YAAY,CAACZ,KAAK,GAAG,IAAI;MAC3B;IACF,CAAC,EAAE;MACDW,KAAK,EAAE;IACT,CAAC,CAAC;IACFtD,WAAW,CAAC,MAAM;MAChBiD,aAAa,CAACN,KAAK,CAACO,MAAM,CAAC,CAAC;MAC5BC,mBAAmB,CAACR,KAAK,CAACO,MAAM,CAAC,CAAC;MAClC,IAAIK,YAAY,CAACZ,KAAK,EAAEY,YAAY,CAACZ,KAAK,CAACc,MAAM,CAAC,CAAC;MACnDnB,gBAAgB,CAAC,CAAC;IACpB,CAAC,CAAC;IACFL,MAAM,CAAC;MACLI,UAAU,EAAEA,CAAA,KAAMA,UAAU,CAAC,IAAI;IACnC,CAAC,CAAC;IACF,OAAO,MAAM;MACX,MAAMqB,KAAK,GAAGxB,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACyB,OAAO,CAAC,CAAC;MAC3E,IAAID,KAAK,EAAE;QACT,OAAOtD,YAAY,CAACsD,KAAK,CAAC,CAAC,CAAC,EAAE;UAC5B/D,GAAG,EAAEyC;QACP,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;MAChB;MACA,OAAO,IAAI;IACb,CAAC;EACH;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}