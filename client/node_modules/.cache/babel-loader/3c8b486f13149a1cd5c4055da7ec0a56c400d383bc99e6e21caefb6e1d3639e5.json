{"ast":null,"code":"import raf from '../../_util/raf';\nexport default function useScrollTo(containerRef, mergedData, heights, props, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  let scroll;\n  return arg => {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    }\n    // Normal scroll logic\n    raf.cancel(scroll);\n    const data = mergedData.value;\n    const itemHeight = props.itemHeight;\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && typeof arg === 'object') {\n      let index;\n      const {\n        align\n      } = arg;\n      if ('index' in arg) {\n        ({\n          index\n        } = arg);\n      } else {\n        index = data.findIndex(item => getKey(item) === arg.key);\n      }\n      const {\n        offset = 0\n      } = arg;\n      // We will retry 3 times in case dynamic height shaking\n      const syncScroll = (times, targetAlign) => {\n        if (times < 0 || !containerRef.value) return;\n        const height = containerRef.value.clientHeight;\n        let needCollectHeight = false;\n        let newTargetAlign = targetAlign;\n        // Go to next frame if height not exist\n        if (height) {\n          const mergedAlign = targetAlign || align;\n          // Get top & bottom\n          let stackTop = 0;\n          let itemTop = 0;\n          let itemBottom = 0;\n          const maxLen = Math.min(data.length, index);\n          for (let i = 0; i <= maxLen; i += 1) {\n            const key = getKey(data[i]);\n            itemTop = stackTop;\n            const cacheHeight = heights.get(key);\n            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n            stackTop = itemBottom;\n            if (i === index && cacheHeight === undefined) {\n              needCollectHeight = true;\n            }\n          }\n          const scrollTop = containerRef.value.scrollTop;\n          // Scroll to\n          let targetTop = null;\n          switch (mergedAlign) {\n            case 'top':\n              targetTop = itemTop - offset;\n              break;\n            case 'bottom':\n              targetTop = itemBottom - height + offset;\n              break;\n            default:\n              {\n                const scrollBottom = scrollTop + height;\n                if (itemTop < scrollTop) {\n                  newTargetAlign = 'top';\n                } else if (itemBottom > scrollBottom) {\n                  newTargetAlign = 'bottom';\n                }\n              }\n          }\n          if (targetTop !== null && targetTop !== scrollTop) {\n            syncScrollTop(targetTop);\n          }\n        }\n        // We will retry since element may not sync height as it described\n        scroll = raf(() => {\n          if (needCollectHeight) {\n            collectHeight();\n          }\n          syncScroll(times - 1, newTargetAlign);\n        }, 2);\n      };\n      syncScroll(5);\n    }\n  };\n}","map":{"version":3,"names":["raf","useScrollTo","containerRef","mergedData","heights","props","getKey","collectHeight","syncScrollTop","triggerFlash","scroll","arg","undefined","cancel","data","value","itemHeight","index","align","findIndex","item","key","offset","syncScroll","times","targetAlign","height","clientHeight","needCollectHeight","newTargetAlign","mergedAlign","stackTop","itemTop","itemBottom","maxLen","Math","min","length","i","cacheHeight","get","scrollTop","targetTop","scrollBottom"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-virtual-list/hooks/useScrollTo.js"],"sourcesContent":["import raf from '../../_util/raf';\nexport default function useScrollTo(containerRef, mergedData, heights, props, getKey, collectHeight, syncScrollTop, triggerFlash) {\n  let scroll;\n  return arg => {\n    // When not argument provided, we think dev may want to show the scrollbar\n    if (arg === null || arg === undefined) {\n      triggerFlash();\n      return;\n    }\n    // Normal scroll logic\n    raf.cancel(scroll);\n    const data = mergedData.value;\n    const itemHeight = props.itemHeight;\n    if (typeof arg === 'number') {\n      syncScrollTop(arg);\n    } else if (arg && typeof arg === 'object') {\n      let index;\n      const {\n        align\n      } = arg;\n      if ('index' in arg) {\n        ({\n          index\n        } = arg);\n      } else {\n        index = data.findIndex(item => getKey(item) === arg.key);\n      }\n      const {\n        offset = 0\n      } = arg;\n      // We will retry 3 times in case dynamic height shaking\n      const syncScroll = (times, targetAlign) => {\n        if (times < 0 || !containerRef.value) return;\n        const height = containerRef.value.clientHeight;\n        let needCollectHeight = false;\n        let newTargetAlign = targetAlign;\n        // Go to next frame if height not exist\n        if (height) {\n          const mergedAlign = targetAlign || align;\n          // Get top & bottom\n          let stackTop = 0;\n          let itemTop = 0;\n          let itemBottom = 0;\n          const maxLen = Math.min(data.length, index);\n          for (let i = 0; i <= maxLen; i += 1) {\n            const key = getKey(data[i]);\n            itemTop = stackTop;\n            const cacheHeight = heights.get(key);\n            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);\n            stackTop = itemBottom;\n            if (i === index && cacheHeight === undefined) {\n              needCollectHeight = true;\n            }\n          }\n          const scrollTop = containerRef.value.scrollTop;\n          // Scroll to\n          let targetTop = null;\n          switch (mergedAlign) {\n            case 'top':\n              targetTop = itemTop - offset;\n              break;\n            case 'bottom':\n              targetTop = itemBottom - height + offset;\n              break;\n            default:\n              {\n                const scrollBottom = scrollTop + height;\n                if (itemTop < scrollTop) {\n                  newTargetAlign = 'top';\n                } else if (itemBottom > scrollBottom) {\n                  newTargetAlign = 'bottom';\n                }\n              }\n          }\n          if (targetTop !== null && targetTop !== scrollTop) {\n            syncScrollTop(targetTop);\n          }\n        }\n        // We will retry since element may not sync height as it described\n        scroll = raf(() => {\n          if (needCollectHeight) {\n            collectHeight();\n          }\n          syncScroll(times - 1, newTargetAlign);\n        }, 2);\n      };\n      syncScroll(5);\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}