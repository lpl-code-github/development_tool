{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, onMounted, onBeforeUnmount, computed } from 'vue';\nimport classNames from '../_util/classNames';\nimport useResponsiveObserve, { responsiveArray } from '../_util/responsiveObserve';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport useFlexGapSupport from '../_util/hooks/useFlexGapSupport';\nimport useProvideRow from './context';\nimport { useRowStyle } from './style';\nimport { someType } from '../_util/type';\nconst RowAligns = ['top', 'middle', 'bottom', 'stretch'];\nconst RowJustify = ['start', 'end', 'center', 'space-around', 'space-between', 'space-evenly'];\nexport const rowProps = () => ({\n  align: someType([String, Object]),\n  justify: someType([String, Object]),\n  prefixCls: String,\n  gutter: someType([Number, Array, Object], 0),\n  wrap: {\n    type: Boolean,\n    default: undefined\n  }\n});\nconst ARow = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'ARow',\n  inheritAttrs: false,\n  props: rowProps(),\n  setup(props, _ref) {\n    let {\n      slots,\n      attrs\n    } = _ref;\n    const {\n      prefixCls,\n      direction\n    } = useConfigInject('row', props);\n    const [wrapSSR, hashId] = useRowStyle(prefixCls);\n    let token;\n    const responsiveObserve = useResponsiveObserve();\n    const screens = ref({\n      xs: true,\n      sm: true,\n      md: true,\n      lg: true,\n      xl: true,\n      xxl: true\n    });\n    const curScreens = ref({\n      xs: false,\n      sm: false,\n      md: false,\n      lg: false,\n      xl: false,\n      xxl: false\n    });\n    const mergePropsByScreen = oriProp => {\n      return computed(() => {\n        if (typeof props[oriProp] === 'string') {\n          return props[oriProp];\n        }\n        if (typeof props[oriProp] !== 'object') {\n          return '';\n        }\n        for (let i = 0; i < responsiveArray.length; i++) {\n          const breakpoint = responsiveArray[i];\n          // if do not match, do nothing\n          if (!curScreens.value[breakpoint]) continue;\n          const curVal = props[oriProp][breakpoint];\n          if (curVal !== undefined) {\n            return curVal;\n          }\n        }\n        return '';\n      });\n    };\n    const mergeAlign = mergePropsByScreen('align');\n    const mergeJustify = mergePropsByScreen('justify');\n    const supportFlexGap = useFlexGapSupport();\n    onMounted(() => {\n      token = responsiveObserve.value.subscribe(screen => {\n        curScreens.value = screen;\n        const currentGutter = props.gutter || 0;\n        if (!Array.isArray(currentGutter) && typeof currentGutter === 'object' || Array.isArray(currentGutter) && (typeof currentGutter[0] === 'object' || typeof currentGutter[1] === 'object')) {\n          screens.value = screen;\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      responsiveObserve.value.unsubscribe(token);\n    });\n    const gutter = computed(() => {\n      const results = [undefined, undefined];\n      const {\n        gutter = 0\n      } = props;\n      const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, undefined];\n      normalizedGutter.forEach((g, index) => {\n        if (typeof g === 'object') {\n          for (let i = 0; i < responsiveArray.length; i++) {\n            const breakpoint = responsiveArray[i];\n            if (screens.value[breakpoint] && g[breakpoint] !== undefined) {\n              results[index] = g[breakpoint];\n              break;\n            }\n          }\n        } else {\n          results[index] = g;\n        }\n      });\n      return results;\n    });\n    useProvideRow({\n      gutter,\n      supportFlexGap,\n      wrap: computed(() => props.wrap)\n    });\n    const classes = computed(() => classNames(prefixCls.value, {\n      [`${prefixCls.value}-no-wrap`]: props.wrap === false,\n      [`${prefixCls.value}-${mergeJustify.value}`]: mergeJustify.value,\n      [`${prefixCls.value}-${mergeAlign.value}`]: mergeAlign.value,\n      [`${prefixCls.value}-rtl`]: direction.value === 'rtl'\n    }, attrs.class, hashId.value));\n    const rowStyle = computed(() => {\n      const gt = gutter.value;\n      // Add gutter related style\n      const style = {};\n      const horizontalGutter = gt[0] != null && gt[0] > 0 ? `${gt[0] / -2}px` : undefined;\n      const verticalGutter = gt[1] != null && gt[1] > 0 ? `${gt[1] / -2}px` : undefined;\n      if (horizontalGutter) {\n        style.marginLeft = horizontalGutter;\n        style.marginRight = horizontalGutter;\n      }\n      if (supportFlexGap.value) {\n        // Set gap direct if flex gap support\n        style.rowGap = `${gt[1]}px`;\n      } else if (verticalGutter) {\n        style.marginTop = verticalGutter;\n        style.marginBottom = verticalGutter;\n      }\n      return style;\n    });\n    return () => {\n      var _a;\n      return wrapSSR(_createVNode(\"div\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"class\": classes.value,\n        \"style\": _extends(_extends({}, rowStyle.value), attrs.style)\n      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]));\n    };\n  }\n});\nexport default ARow;","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","defineComponent","ref","onMounted","onBeforeUnmount","computed","classNames","useResponsiveObserve","responsiveArray","useConfigInject","useFlexGapSupport","useProvideRow","useRowStyle","someType","RowAligns","RowJustify","rowProps","align","String","Object","justify","prefixCls","gutter","Number","Array","wrap","type","Boolean","default","undefined","ARow","compatConfig","MODE","name","inheritAttrs","props","setup","_ref","slots","attrs","direction","wrapSSR","hashId","token","responsiveObserve","screens","xs","sm","md","lg","xl","xxl","curScreens","mergePropsByScreen","oriProp","i","length","breakpoint","value","curVal","mergeAlign","mergeJustify","supportFlexGap","subscribe","screen","currentGutter","isArray","unsubscribe","results","normalizedGutter","forEach","g","index","classes","class","rowStyle","gt","style","horizontalGutter","verticalGutter","marginLeft","marginRight","rowGap","marginTop","marginBottom","_a","call"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/grid/Row.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, onMounted, onBeforeUnmount, computed } from 'vue';\nimport classNames from '../_util/classNames';\nimport useResponsiveObserve, { responsiveArray } from '../_util/responsiveObserve';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport useFlexGapSupport from '../_util/hooks/useFlexGapSupport';\nimport useProvideRow from './context';\nimport { useRowStyle } from './style';\nimport { someType } from '../_util/type';\nconst RowAligns = ['top', 'middle', 'bottom', 'stretch'];\nconst RowJustify = ['start', 'end', 'center', 'space-around', 'space-between', 'space-evenly'];\nexport const rowProps = () => ({\n  align: someType([String, Object]),\n  justify: someType([String, Object]),\n  prefixCls: String,\n  gutter: someType([Number, Array, Object], 0),\n  wrap: {\n    type: Boolean,\n    default: undefined\n  }\n});\nconst ARow = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'ARow',\n  inheritAttrs: false,\n  props: rowProps(),\n  setup(props, _ref) {\n    let {\n      slots,\n      attrs\n    } = _ref;\n    const {\n      prefixCls,\n      direction\n    } = useConfigInject('row', props);\n    const [wrapSSR, hashId] = useRowStyle(prefixCls);\n    let token;\n    const responsiveObserve = useResponsiveObserve();\n    const screens = ref({\n      xs: true,\n      sm: true,\n      md: true,\n      lg: true,\n      xl: true,\n      xxl: true\n    });\n    const curScreens = ref({\n      xs: false,\n      sm: false,\n      md: false,\n      lg: false,\n      xl: false,\n      xxl: false\n    });\n    const mergePropsByScreen = oriProp => {\n      return computed(() => {\n        if (typeof props[oriProp] === 'string') {\n          return props[oriProp];\n        }\n        if (typeof props[oriProp] !== 'object') {\n          return '';\n        }\n        for (let i = 0; i < responsiveArray.length; i++) {\n          const breakpoint = responsiveArray[i];\n          // if do not match, do nothing\n          if (!curScreens.value[breakpoint]) continue;\n          const curVal = props[oriProp][breakpoint];\n          if (curVal !== undefined) {\n            return curVal;\n          }\n        }\n        return '';\n      });\n    };\n    const mergeAlign = mergePropsByScreen('align');\n    const mergeJustify = mergePropsByScreen('justify');\n    const supportFlexGap = useFlexGapSupport();\n    onMounted(() => {\n      token = responsiveObserve.value.subscribe(screen => {\n        curScreens.value = screen;\n        const currentGutter = props.gutter || 0;\n        if (!Array.isArray(currentGutter) && typeof currentGutter === 'object' || Array.isArray(currentGutter) && (typeof currentGutter[0] === 'object' || typeof currentGutter[1] === 'object')) {\n          screens.value = screen;\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      responsiveObserve.value.unsubscribe(token);\n    });\n    const gutter = computed(() => {\n      const results = [undefined, undefined];\n      const {\n        gutter = 0\n      } = props;\n      const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, undefined];\n      normalizedGutter.forEach((g, index) => {\n        if (typeof g === 'object') {\n          for (let i = 0; i < responsiveArray.length; i++) {\n            const breakpoint = responsiveArray[i];\n            if (screens.value[breakpoint] && g[breakpoint] !== undefined) {\n              results[index] = g[breakpoint];\n              break;\n            }\n          }\n        } else {\n          results[index] = g;\n        }\n      });\n      return results;\n    });\n    useProvideRow({\n      gutter,\n      supportFlexGap,\n      wrap: computed(() => props.wrap)\n    });\n    const classes = computed(() => classNames(prefixCls.value, {\n      [`${prefixCls.value}-no-wrap`]: props.wrap === false,\n      [`${prefixCls.value}-${mergeJustify.value}`]: mergeJustify.value,\n      [`${prefixCls.value}-${mergeAlign.value}`]: mergeAlign.value,\n      [`${prefixCls.value}-rtl`]: direction.value === 'rtl'\n    }, attrs.class, hashId.value));\n    const rowStyle = computed(() => {\n      const gt = gutter.value;\n      // Add gutter related style\n      const style = {};\n      const horizontalGutter = gt[0] != null && gt[0] > 0 ? `${gt[0] / -2}px` : undefined;\n      const verticalGutter = gt[1] != null && gt[1] > 0 ? `${gt[1] / -2}px` : undefined;\n      if (horizontalGutter) {\n        style.marginLeft = horizontalGutter;\n        style.marginRight = horizontalGutter;\n      }\n      if (supportFlexGap.value) {\n        // Set gap direct if flex gap support\n        style.rowGap = `${gt[1]}px`;\n      } else if (verticalGutter) {\n        style.marginTop = verticalGutter;\n        style.marginBottom = verticalGutter;\n      }\n      return style;\n    });\n    return () => {\n      var _a;\n      return wrapSSR(_createVNode(\"div\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"class\": classes.value,\n        \"style\": _extends(_extends({}, rowStyle.value), attrs.style)\n      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]));\n    };\n  }\n});\nexport default ARow;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}