{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { computed, ref, watchEffect } from 'vue';\nimport { useBaseProps } from '../../vc-select';\nimport KeyCode from '../../_util/KeyCode';\nimport { SEARCH_MARK } from '../hooks/useSearchOptions';\nexport default ((context, options, fieldNames, activeValueCells, setActiveValueCells,\n// containerRef: Ref<HTMLElement>,\nonKeyBoardSelect) => {\n  const baseProps = useBaseProps();\n  const rtl = computed(() => baseProps.direction === 'rtl');\n  const [validActiveValueCells, lastActiveIndex, lastActiveOptions] = [ref([]), ref(), ref([])];\n  watchEffect(() => {\n    let activeIndex = -1;\n    let currentOptions = options.value;\n    const mergedActiveIndexes = [];\n    const mergedActiveValueCells = [];\n    const len = activeValueCells.value.length;\n    // Fill validate active value cells and index\n    for (let i = 0; i < len && currentOptions; i += 1) {\n      // Mark the active index for current options\n      const nextActiveIndex = currentOptions.findIndex(option => option[fieldNames.value.value] === activeValueCells.value[i]);\n      if (nextActiveIndex === -1) {\n        break;\n      }\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells.value[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.value.children];\n    }\n    // Fill last active options\n    let activeOptions = options.value;\n    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.value.children];\n    }\n    [validActiveValueCells.value, lastActiveIndex.value, lastActiveOptions.value] = [mergedActiveValueCells, activeIndex, activeOptions];\n  });\n  // Update active value cells and scroll to target element\n  const internalSetActiveValueCells = next => {\n    setActiveValueCells(next);\n  };\n  // Same options offset\n  const offsetActiveOption = offset => {\n    const len = lastActiveOptions.value.length;\n    let currentIndex = lastActiveIndex.value;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (let i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      const option = lastActiveOptions.value[currentIndex];\n      if (option && !option.disabled) {\n        const value = option[fieldNames.value.value];\n        const nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n  // Different options offset\n  const prevColumn = () => {\n    if (validActiveValueCells.value.length > 1) {\n      const nextActiveCells = validActiveValueCells.value.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      baseProps.toggleOpen(false);\n    }\n  };\n  const nextColumn = () => {\n    var _a;\n    const nextOptions = ((_a = lastActiveOptions.value[lastActiveIndex.value]) === null || _a === void 0 ? void 0 : _a[fieldNames.value.children]) || [];\n    const nextOption = nextOptions.find(option => !option.disabled);\n    if (nextOption) {\n      const nextActiveCells = [...validActiveValueCells.value, nextOption[fieldNames.value.value]];\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  context.expose({\n    // scrollTo: treeRef.current?.scrollTo,\n    onKeydown: event => {\n      const {\n        which\n      } = event;\n      switch (which) {\n        // >>> Arrow keys\n        case KeyCode.UP:\n        case KeyCode.DOWN:\n          {\n            let offset = 0;\n            if (which === KeyCode.UP) {\n              offset = -1;\n            } else if (which === KeyCode.DOWN) {\n              offset = 1;\n            }\n            if (offset !== 0) {\n              offsetActiveOption(offset);\n            }\n            break;\n          }\n        case KeyCode.LEFT:\n          {\n            if (rtl.value) {\n              nextColumn();\n            } else {\n              prevColumn();\n            }\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            if (rtl.value) {\n              prevColumn();\n            } else {\n              nextColumn();\n            }\n            break;\n          }\n        case KeyCode.BACKSPACE:\n          {\n            if (!baseProps.searchValue) {\n              prevColumn();\n            }\n            break;\n          }\n        // >>> Select\n        case KeyCode.ENTER:\n          {\n            if (validActiveValueCells.value.length) {\n              const option = lastActiveOptions.value[lastActiveIndex.value];\n              // Search option should revert back of origin options\n              const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];\n              if (originOptions.length) {\n                onKeyBoardSelect(originOptions.map(opt => opt[fieldNames.value.value]), originOptions[originOptions.length - 1]);\n              } else {\n                onKeyBoardSelect(validActiveValueCells.value, option);\n              }\n            }\n            break;\n          }\n        // >>> Close\n        case KeyCode.ESC:\n          {\n            baseProps.toggleOpen(false);\n            if (open) {\n              event.stopPropagation();\n            }\n          }\n      }\n    },\n    onKeyup: () => {}\n  });\n});","map":{"version":3,"names":["computed","ref","watchEffect","useBaseProps","KeyCode","SEARCH_MARK","context","options","fieldNames","activeValueCells","setActiveValueCells","onKeyBoardSelect","baseProps","rtl","direction","validActiveValueCells","lastActiveIndex","lastActiveOptions","activeIndex","currentOptions","value","mergedActiveIndexes","mergedActiveValueCells","len","length","i","nextActiveIndex","findIndex","option","push","children","activeOptions","internalSetActiveValueCells","next","offsetActiveOption","offset","currentIndex","disabled","nextActiveCells","slice","concat","prevColumn","toggleOpen","nextColumn","_a","nextOptions","nextOption","find","expose","onKeydown","event","which","UP","DOWN","LEFT","RIGHT","BACKSPACE","searchValue","ENTER","originOptions","map","opt","ESC","open","stopPropagation","onKeyup"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-cascader/OptionList/useKeyboard.js"],"sourcesContent":["import { computed, ref, watchEffect } from 'vue';\nimport { useBaseProps } from '../../vc-select';\nimport KeyCode from '../../_util/KeyCode';\nimport { SEARCH_MARK } from '../hooks/useSearchOptions';\nexport default ((context, options, fieldNames, activeValueCells, setActiveValueCells,\n// containerRef: Ref<HTMLElement>,\nonKeyBoardSelect) => {\n  const baseProps = useBaseProps();\n  const rtl = computed(() => baseProps.direction === 'rtl');\n  const [validActiveValueCells, lastActiveIndex, lastActiveOptions] = [ref([]), ref(), ref([])];\n  watchEffect(() => {\n    let activeIndex = -1;\n    let currentOptions = options.value;\n    const mergedActiveIndexes = [];\n    const mergedActiveValueCells = [];\n    const len = activeValueCells.value.length;\n    // Fill validate active value cells and index\n    for (let i = 0; i < len && currentOptions; i += 1) {\n      // Mark the active index for current options\n      const nextActiveIndex = currentOptions.findIndex(option => option[fieldNames.value.value] === activeValueCells.value[i]);\n      if (nextActiveIndex === -1) {\n        break;\n      }\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells.value[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.value.children];\n    }\n    // Fill last active options\n    let activeOptions = options.value;\n    for (let i = 0; i < mergedActiveIndexes.length - 1; i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[i]][fieldNames.value.children];\n    }\n    [validActiveValueCells.value, lastActiveIndex.value, lastActiveOptions.value] = [mergedActiveValueCells, activeIndex, activeOptions];\n  });\n  // Update active value cells and scroll to target element\n  const internalSetActiveValueCells = next => {\n    setActiveValueCells(next);\n  };\n  // Same options offset\n  const offsetActiveOption = offset => {\n    const len = lastActiveOptions.value.length;\n    let currentIndex = lastActiveIndex.value;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (let i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      const option = lastActiveOptions.value[currentIndex];\n      if (option && !option.disabled) {\n        const value = option[fieldNames.value.value];\n        const nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n  // Different options offset\n  const prevColumn = () => {\n    if (validActiveValueCells.value.length > 1) {\n      const nextActiveCells = validActiveValueCells.value.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      baseProps.toggleOpen(false);\n    }\n  };\n  const nextColumn = () => {\n    var _a;\n    const nextOptions = ((_a = lastActiveOptions.value[lastActiveIndex.value]) === null || _a === void 0 ? void 0 : _a[fieldNames.value.children]) || [];\n    const nextOption = nextOptions.find(option => !option.disabled);\n    if (nextOption) {\n      const nextActiveCells = [...validActiveValueCells.value, nextOption[fieldNames.value.value]];\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  context.expose({\n    // scrollTo: treeRef.current?.scrollTo,\n    onKeydown: event => {\n      const {\n        which\n      } = event;\n      switch (which) {\n        // >>> Arrow keys\n        case KeyCode.UP:\n        case KeyCode.DOWN:\n          {\n            let offset = 0;\n            if (which === KeyCode.UP) {\n              offset = -1;\n            } else if (which === KeyCode.DOWN) {\n              offset = 1;\n            }\n            if (offset !== 0) {\n              offsetActiveOption(offset);\n            }\n            break;\n          }\n        case KeyCode.LEFT:\n          {\n            if (rtl.value) {\n              nextColumn();\n            } else {\n              prevColumn();\n            }\n            break;\n          }\n        case KeyCode.RIGHT:\n          {\n            if (rtl.value) {\n              prevColumn();\n            } else {\n              nextColumn();\n            }\n            break;\n          }\n        case KeyCode.BACKSPACE:\n          {\n            if (!baseProps.searchValue) {\n              prevColumn();\n            }\n            break;\n          }\n        // >>> Select\n        case KeyCode.ENTER:\n          {\n            if (validActiveValueCells.value.length) {\n              const option = lastActiveOptions.value[lastActiveIndex.value];\n              // Search option should revert back of origin options\n              const originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];\n              if (originOptions.length) {\n                onKeyBoardSelect(originOptions.map(opt => opt[fieldNames.value.value]), originOptions[originOptions.length - 1]);\n              } else {\n                onKeyBoardSelect(validActiveValueCells.value, option);\n              }\n            }\n            break;\n          }\n        // >>> Close\n        case KeyCode.ESC:\n          {\n            baseProps.toggleOpen(false);\n            if (open) {\n              event.stopPropagation();\n            }\n          }\n      }\n    },\n    onKeyup: () => {}\n  });\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}