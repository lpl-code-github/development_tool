{"ast":null,"code":"/* eslint-disable max-classes-per-file */\nimport { getNumberPrecision, isE, num2str, trimNumber, validateNumber } from './numberUtil';\nimport { supportBigInt } from './supportUtil';\nfunction isEmpty(value) {\n  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();\n}\n/**\n * We can remove this when IE not support anymore\n */\nexport class NumberDecimal {\n  constructor(value) {\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    this.number = Number(value);\n  }\n  negate() {\n    return new NumberDecimal(-this.toNumber());\n  }\n  add(value) {\n    if (this.isInvalidate()) {\n      return new NumberDecimal(value);\n    }\n    const target = Number(value);\n    if (Number.isNaN(target)) {\n      return this;\n    }\n    const number = this.number + target;\n    // [Legacy] Back to safe integer\n    if (number > Number.MAX_SAFE_INTEGER) {\n      return new NumberDecimal(Number.MAX_SAFE_INTEGER);\n    }\n    if (number < Number.MIN_SAFE_INTEGER) {\n      return new NumberDecimal(Number.MIN_SAFE_INTEGER);\n    }\n    const maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));\n    return new NumberDecimal(number.toFixed(maxPrecision));\n  }\n  isEmpty() {\n    return this.empty;\n  }\n  isNaN() {\n    return Number.isNaN(this.number);\n  }\n  isInvalidate() {\n    return this.isEmpty() || this.isNaN();\n  }\n  equals(target) {\n    return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());\n  }\n  lessEquals(target) {\n    return this.add(target.negate().toString()).toNumber() <= 0;\n  }\n  toNumber() {\n    return this.number;\n  }\n  toString() {\n    let safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!safe) {\n      return this.origin;\n    }\n    if (this.isInvalidate()) {\n      return '';\n    }\n    return num2str(this.number);\n  }\n}\nexport class BigIntDecimal {\n  constructor(value) {\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    // Act like Number convert\n    if (value === '-' || Number.isNaN(value)) {\n      this.nan = true;\n      return;\n    }\n    let mergedValue = value;\n    // We need convert back to Number since it require `toFixed` to handle this\n    if (isE(mergedValue)) {\n      mergedValue = Number(mergedValue);\n    }\n    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);\n    if (validateNumber(mergedValue)) {\n      const trimRet = trimNumber(mergedValue);\n      this.negative = trimRet.negative;\n      const numbers = trimRet.trimStr.split('.');\n      this.integer = BigInt(numbers[0]);\n      const decimalStr = numbers[1] || '0';\n      this.decimal = BigInt(decimalStr);\n      this.decimalLen = decimalStr.length;\n    } else {\n      this.nan = true;\n    }\n  }\n  getMark() {\n    return this.negative ? '-' : '';\n  }\n  getIntegerStr() {\n    return this.integer.toString();\n  }\n  getDecimalStr() {\n    return this.decimal.toString().padStart(this.decimalLen, '0');\n  }\n  /**\n   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000\n   * This is used for add function only.\n   */\n  alignDecimal(decimalLength) {\n    const str = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(decimalLength, '0')}`;\n    return BigInt(str);\n  }\n  negate() {\n    const clone = new BigIntDecimal(this.toString());\n    clone.negative = !clone.negative;\n    return clone;\n  }\n  add(value) {\n    if (this.isInvalidate()) {\n      return new BigIntDecimal(value);\n    }\n    const offset = new BigIntDecimal(value);\n    if (offset.isInvalidate()) {\n      return this;\n    }\n    const maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);\n    const myAlignedDecimal = this.alignDecimal(maxDecimalLength);\n    const offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);\n    const valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();\n    // We need fill string length back to `maxDecimalLength` to avoid parser failed\n    const {\n      negativeStr,\n      trimStr\n    } = trimNumber(valueStr);\n    const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;\n    return new BigIntDecimal(`${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`);\n  }\n  isEmpty() {\n    return this.empty;\n  }\n  isNaN() {\n    return this.nan;\n  }\n  isInvalidate() {\n    return this.isEmpty() || this.isNaN();\n  }\n  equals(target) {\n    return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());\n  }\n  lessEquals(target) {\n    return this.add(target.negate().toString()).toNumber() <= 0;\n  }\n  toNumber() {\n    if (this.isNaN()) {\n      return NaN;\n    }\n    return Number(this.toString());\n  }\n  toString() {\n    let safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!safe) {\n      return this.origin;\n    }\n    if (this.isInvalidate()) {\n      return '';\n    }\n    return trimNumber(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr;\n  }\n}\nexport default function getMiniDecimal(value) {\n  // We use BigInt here.\n  // Will fallback to Number if not support.\n  if (supportBigInt()) {\n    return new BigIntDecimal(value);\n  }\n  return new NumberDecimal(value);\n}\n/**\n * Align the logic of toFixed to around like 1.5 => 2.\n * If set `cutOnly`, will just remove the over decimal part.\n */\nexport function toFixed(numStr, separatorStr, precision) {\n  let cutOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (numStr === '') {\n    return '';\n  }\n  const {\n    negativeStr,\n    integerStr,\n    decimalStr\n  } = trimNumber(numStr);\n  const precisionDecimalStr = `${separatorStr}${decimalStr}`;\n  const numberWithoutDecimal = `${negativeStr}${integerStr}`;\n  if (precision >= 0) {\n    // We will get last + 1 number to check if need advanced number\n    const advancedNum = Number(decimalStr[precision]);\n    if (advancedNum >= 5 && !cutOnly) {\n      const advancedDecimal = getMiniDecimal(numStr).add(`${negativeStr}0.${'0'.repeat(precision)}${10 - advancedNum}`);\n      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);\n    }\n    if (precision === 0) {\n      return numberWithoutDecimal;\n    }\n    return `${numberWithoutDecimal}${separatorStr}${decimalStr.padEnd(precision, '0').slice(0, precision)}`;\n  }\n  if (precisionDecimalStr === '.0') {\n    return numberWithoutDecimal;\n  }\n  return `${numberWithoutDecimal}${precisionDecimalStr}`;\n}","map":{"version":3,"names":["getNumberPrecision","isE","num2str","trimNumber","validateNumber","supportBigInt","isEmpty","value","Number","isNaN","String","trim","NumberDecimal","constructor","origin","empty","number","negate","toNumber","add","isInvalidate","target","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","maxPrecision","Math","max","toFixed","equals","lessEquals","toString","safe","arguments","length","undefined","BigIntDecimal","nan","mergedValue","trimRet","negative","numbers","trimStr","split","integer","BigInt","decimalStr","decimal","decimalLen","getMark","getIntegerStr","getDecimalStr","padStart","alignDecimal","decimalLength","str","padEnd","clone","offset","maxDecimalLength","myAlignedDecimal","offsetAlignedDecimal","valueStr","negativeStr","hydrateValueStr","slice","NaN","fullStr","getMiniDecimal","numStr","separatorStr","precision","cutOnly","integerStr","precisionDecimalStr","numberWithoutDecimal","advancedNum","advancedDecimal","repeat"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/input-number/src/utils/MiniDecimal.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\nimport { getNumberPrecision, isE, num2str, trimNumber, validateNumber } from './numberUtil';\nimport { supportBigInt } from './supportUtil';\nfunction isEmpty(value) {\n  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();\n}\n/**\n * We can remove this when IE not support anymore\n */\nexport class NumberDecimal {\n  constructor(value) {\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    this.number = Number(value);\n  }\n  negate() {\n    return new NumberDecimal(-this.toNumber());\n  }\n  add(value) {\n    if (this.isInvalidate()) {\n      return new NumberDecimal(value);\n    }\n    const target = Number(value);\n    if (Number.isNaN(target)) {\n      return this;\n    }\n    const number = this.number + target;\n    // [Legacy] Back to safe integer\n    if (number > Number.MAX_SAFE_INTEGER) {\n      return new NumberDecimal(Number.MAX_SAFE_INTEGER);\n    }\n    if (number < Number.MIN_SAFE_INTEGER) {\n      return new NumberDecimal(Number.MIN_SAFE_INTEGER);\n    }\n    const maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));\n    return new NumberDecimal(number.toFixed(maxPrecision));\n  }\n  isEmpty() {\n    return this.empty;\n  }\n  isNaN() {\n    return Number.isNaN(this.number);\n  }\n  isInvalidate() {\n    return this.isEmpty() || this.isNaN();\n  }\n  equals(target) {\n    return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());\n  }\n  lessEquals(target) {\n    return this.add(target.negate().toString()).toNumber() <= 0;\n  }\n  toNumber() {\n    return this.number;\n  }\n  toString() {\n    let safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!safe) {\n      return this.origin;\n    }\n    if (this.isInvalidate()) {\n      return '';\n    }\n    return num2str(this.number);\n  }\n}\nexport class BigIntDecimal {\n  constructor(value) {\n    this.origin = '';\n    if (isEmpty(value)) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    // Act like Number convert\n    if (value === '-' || Number.isNaN(value)) {\n      this.nan = true;\n      return;\n    }\n    let mergedValue = value;\n    // We need convert back to Number since it require `toFixed` to handle this\n    if (isE(mergedValue)) {\n      mergedValue = Number(mergedValue);\n    }\n    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);\n    if (validateNumber(mergedValue)) {\n      const trimRet = trimNumber(mergedValue);\n      this.negative = trimRet.negative;\n      const numbers = trimRet.trimStr.split('.');\n      this.integer = BigInt(numbers[0]);\n      const decimalStr = numbers[1] || '0';\n      this.decimal = BigInt(decimalStr);\n      this.decimalLen = decimalStr.length;\n    } else {\n      this.nan = true;\n    }\n  }\n  getMark() {\n    return this.negative ? '-' : '';\n  }\n  getIntegerStr() {\n    return this.integer.toString();\n  }\n  getDecimalStr() {\n    return this.decimal.toString().padStart(this.decimalLen, '0');\n  }\n  /**\n   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000\n   * This is used for add function only.\n   */\n  alignDecimal(decimalLength) {\n    const str = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(decimalLength, '0')}`;\n    return BigInt(str);\n  }\n  negate() {\n    const clone = new BigIntDecimal(this.toString());\n    clone.negative = !clone.negative;\n    return clone;\n  }\n  add(value) {\n    if (this.isInvalidate()) {\n      return new BigIntDecimal(value);\n    }\n    const offset = new BigIntDecimal(value);\n    if (offset.isInvalidate()) {\n      return this;\n    }\n    const maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);\n    const myAlignedDecimal = this.alignDecimal(maxDecimalLength);\n    const offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);\n    const valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();\n    // We need fill string length back to `maxDecimalLength` to avoid parser failed\n    const {\n      negativeStr,\n      trimStr\n    } = trimNumber(valueStr);\n    const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;\n    return new BigIntDecimal(`${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`);\n  }\n  isEmpty() {\n    return this.empty;\n  }\n  isNaN() {\n    return this.nan;\n  }\n  isInvalidate() {\n    return this.isEmpty() || this.isNaN();\n  }\n  equals(target) {\n    return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());\n  }\n  lessEquals(target) {\n    return this.add(target.negate().toString()).toNumber() <= 0;\n  }\n  toNumber() {\n    if (this.isNaN()) {\n      return NaN;\n    }\n    return Number(this.toString());\n  }\n  toString() {\n    let safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!safe) {\n      return this.origin;\n    }\n    if (this.isInvalidate()) {\n      return '';\n    }\n    return trimNumber(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr;\n  }\n}\nexport default function getMiniDecimal(value) {\n  // We use BigInt here.\n  // Will fallback to Number if not support.\n  if (supportBigInt()) {\n    return new BigIntDecimal(value);\n  }\n  return new NumberDecimal(value);\n}\n/**\n * Align the logic of toFixed to around like 1.5 => 2.\n * If set `cutOnly`, will just remove the over decimal part.\n */\nexport function toFixed(numStr, separatorStr, precision) {\n  let cutOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (numStr === '') {\n    return '';\n  }\n  const {\n    negativeStr,\n    integerStr,\n    decimalStr\n  } = trimNumber(numStr);\n  const precisionDecimalStr = `${separatorStr}${decimalStr}`;\n  const numberWithoutDecimal = `${negativeStr}${integerStr}`;\n  if (precision >= 0) {\n    // We will get last + 1 number to check if need advanced number\n    const advancedNum = Number(decimalStr[precision]);\n    if (advancedNum >= 5 && !cutOnly) {\n      const advancedDecimal = getMiniDecimal(numStr).add(`${negativeStr}0.${'0'.repeat(precision)}${10 - advancedNum}`);\n      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);\n    }\n    if (precision === 0) {\n      return numberWithoutDecimal;\n    }\n    return `${numberWithoutDecimal}${separatorStr}${decimalStr.padEnd(precision, '0').slice(0, precision)}`;\n  }\n  if (precisionDecimalStr === '.0') {\n    return numberWithoutDecimal;\n  }\n  return `${numberWithoutDecimal}${precisionDecimalStr}`;\n}"],"mappings":"AAAA;AACA,SAASA,kBAAkB,EAAEC,GAAG,EAAEC,OAAO,EAAEC,UAAU,EAAEC,cAAc,QAAQ,cAAc;AAC3F,SAASC,aAAa,QAAQ,eAAe;AAC7C,SAASC,OAAOA,CAACC,KAAK,EAAE;EACtB,OAAO,CAACA,KAAK,IAAIA,KAAK,KAAK,CAAC,IAAI,CAACC,MAAM,CAACC,KAAK,CAACF,KAAK,CAAC,IAAI,CAACG,MAAM,CAACH,KAAK,CAAC,CAACI,IAAI,CAAC,CAAC;AAC/E;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EACzBC,WAAWA,CAACN,KAAK,EAAE;IACjB,IAAI,CAACO,MAAM,GAAG,EAAE;IAChB,IAAIR,OAAO,CAACC,KAAK,CAAC,EAAE;MAClB,IAAI,CAACQ,KAAK,GAAG,IAAI;MACjB;IACF;IACA,IAAI,CAACD,MAAM,GAAGJ,MAAM,CAACH,KAAK,CAAC;IAC3B,IAAI,CAACS,MAAM,GAAGR,MAAM,CAACD,KAAK,CAAC;EAC7B;EACAU,MAAMA,CAAA,EAAG;IACP,OAAO,IAAIL,aAAa,CAAC,CAAC,IAAI,CAACM,QAAQ,CAAC,CAAC,CAAC;EAC5C;EACAC,GAAGA,CAACZ,KAAK,EAAE;IACT,IAAI,IAAI,CAACa,YAAY,CAAC,CAAC,EAAE;MACvB,OAAO,IAAIR,aAAa,CAACL,KAAK,CAAC;IACjC;IACA,MAAMc,MAAM,GAAGb,MAAM,CAACD,KAAK,CAAC;IAC5B,IAAIC,MAAM,CAACC,KAAK,CAACY,MAAM,CAAC,EAAE;MACxB,OAAO,IAAI;IACb;IACA,MAAML,MAAM,GAAG,IAAI,CAACA,MAAM,GAAGK,MAAM;IACnC;IACA,IAAIL,MAAM,GAAGR,MAAM,CAACc,gBAAgB,EAAE;MACpC,OAAO,IAAIV,aAAa,CAACJ,MAAM,CAACc,gBAAgB,CAAC;IACnD;IACA,IAAIN,MAAM,GAAGR,MAAM,CAACe,gBAAgB,EAAE;MACpC,OAAO,IAAIX,aAAa,CAACJ,MAAM,CAACe,gBAAgB,CAAC;IACnD;IACA,MAAMC,YAAY,GAAGC,IAAI,CAACC,GAAG,CAAC1B,kBAAkB,CAAC,IAAI,CAACgB,MAAM,CAAC,EAAEhB,kBAAkB,CAACqB,MAAM,CAAC,CAAC;IAC1F,OAAO,IAAIT,aAAa,CAACI,MAAM,CAACW,OAAO,CAACH,YAAY,CAAC,CAAC;EACxD;EACAlB,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACS,KAAK;EACnB;EACAN,KAAKA,CAAA,EAAG;IACN,OAAOD,MAAM,CAACC,KAAK,CAAC,IAAI,CAACO,MAAM,CAAC;EAClC;EACAI,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACd,OAAO,CAAC,CAAC,IAAI,IAAI,CAACG,KAAK,CAAC,CAAC;EACvC;EACAmB,MAAMA,CAACP,MAAM,EAAE;IACb,OAAO,IAAI,CAACH,QAAQ,CAAC,CAAC,MAAMG,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACH,QAAQ,CAAC,CAAC,CAAC;EAChG;EACAW,UAAUA,CAACR,MAAM,EAAE;IACjB,OAAO,IAAI,CAACF,GAAG,CAACE,MAAM,CAACJ,MAAM,CAAC,CAAC,CAACa,QAAQ,CAAC,CAAC,CAAC,CAACZ,QAAQ,CAAC,CAAC,IAAI,CAAC;EAC7D;EACAA,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACF,MAAM;EACpB;EACAc,QAAQA,CAAA,EAAG;IACT,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;IACnF,IAAI,CAACD,IAAI,EAAE;MACT,OAAO,IAAI,CAACjB,MAAM;IACpB;IACA,IAAI,IAAI,CAACM,YAAY,CAAC,CAAC,EAAE;MACvB,OAAO,EAAE;IACX;IACA,OAAOlB,OAAO,CAAC,IAAI,CAACc,MAAM,CAAC;EAC7B;AACF;AACA,OAAO,MAAMmB,aAAa,CAAC;EACzBtB,WAAWA,CAACN,KAAK,EAAE;IACjB,IAAI,CAACO,MAAM,GAAG,EAAE;IAChB,IAAIR,OAAO,CAACC,KAAK,CAAC,EAAE;MAClB,IAAI,CAACQ,KAAK,GAAG,IAAI;MACjB;IACF;IACA,IAAI,CAACD,MAAM,GAAGJ,MAAM,CAACH,KAAK,CAAC;IAC3B;IACA,IAAIA,KAAK,KAAK,GAAG,IAAIC,MAAM,CAACC,KAAK,CAACF,KAAK,CAAC,EAAE;MACxC,IAAI,CAAC6B,GAAG,GAAG,IAAI;MACf;IACF;IACA,IAAIC,WAAW,GAAG9B,KAAK;IACvB;IACA,IAAIN,GAAG,CAACoC,WAAW,CAAC,EAAE;MACpBA,WAAW,GAAG7B,MAAM,CAAC6B,WAAW,CAAC;IACnC;IACAA,WAAW,GAAG,OAAOA,WAAW,KAAK,QAAQ,GAAGA,WAAW,GAAGnC,OAAO,CAACmC,WAAW,CAAC;IAClF,IAAIjC,cAAc,CAACiC,WAAW,CAAC,EAAE;MAC/B,MAAMC,OAAO,GAAGnC,UAAU,CAACkC,WAAW,CAAC;MACvC,IAAI,CAACE,QAAQ,GAAGD,OAAO,CAACC,QAAQ;MAChC,MAAMC,OAAO,GAAGF,OAAO,CAACG,OAAO,CAACC,KAAK,CAAC,GAAG,CAAC;MAC1C,IAAI,CAACC,OAAO,GAAGC,MAAM,CAACJ,OAAO,CAAC,CAAC,CAAC,CAAC;MACjC,MAAMK,UAAU,GAAGL,OAAO,CAAC,CAAC,CAAC,IAAI,GAAG;MACpC,IAAI,CAACM,OAAO,GAAGF,MAAM,CAACC,UAAU,CAAC;MACjC,IAAI,CAACE,UAAU,GAAGF,UAAU,CAACZ,MAAM;IACrC,CAAC,MAAM;MACL,IAAI,CAACG,GAAG,GAAG,IAAI;IACjB;EACF;EACAY,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACT,QAAQ,GAAG,GAAG,GAAG,EAAE;EACjC;EACAU,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACN,OAAO,CAACb,QAAQ,CAAC,CAAC;EAChC;EACAoB,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACJ,OAAO,CAAChB,QAAQ,CAAC,CAAC,CAACqB,QAAQ,CAAC,IAAI,CAACJ,UAAU,EAAE,GAAG,CAAC;EAC/D;EACA;AACF;AACA;AACA;EACEK,YAAYA,CAACC,aAAa,EAAE;IAC1B,MAAMC,GAAG,GAAI,GAAE,IAAI,CAACN,OAAO,CAAC,CAAE,GAAE,IAAI,CAACC,aAAa,CAAC,CAAE,GAAE,IAAI,CAACC,aAAa,CAAC,CAAC,CAACK,MAAM,CAACF,aAAa,EAAE,GAAG,CAAE,EAAC;IACxG,OAAOT,MAAM,CAACU,GAAG,CAAC;EACpB;EACArC,MAAMA,CAAA,EAAG;IACP,MAAMuC,KAAK,GAAG,IAAIrB,aAAa,CAAC,IAAI,CAACL,QAAQ,CAAC,CAAC,CAAC;IAChD0B,KAAK,CAACjB,QAAQ,GAAG,CAACiB,KAAK,CAACjB,QAAQ;IAChC,OAAOiB,KAAK;EACd;EACArC,GAAGA,CAACZ,KAAK,EAAE;IACT,IAAI,IAAI,CAACa,YAAY,CAAC,CAAC,EAAE;MACvB,OAAO,IAAIe,aAAa,CAAC5B,KAAK,CAAC;IACjC;IACA,MAAMkD,MAAM,GAAG,IAAItB,aAAa,CAAC5B,KAAK,CAAC;IACvC,IAAIkD,MAAM,CAACrC,YAAY,CAAC,CAAC,EAAE;MACzB,OAAO,IAAI;IACb;IACA,MAAMsC,gBAAgB,GAAGjC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACwB,aAAa,CAAC,CAAC,CAACjB,MAAM,EAAEwB,MAAM,CAACP,aAAa,CAAC,CAAC,CAACjB,MAAM,CAAC;IAC7F,MAAM0B,gBAAgB,GAAG,IAAI,CAACP,YAAY,CAACM,gBAAgB,CAAC;IAC5D,MAAME,oBAAoB,GAAGH,MAAM,CAACL,YAAY,CAACM,gBAAgB,CAAC;IAClE,MAAMG,QAAQ,GAAG,CAACF,gBAAgB,GAAGC,oBAAoB,EAAE9B,QAAQ,CAAC,CAAC;IACrE;IACA,MAAM;MACJgC,WAAW;MACXrB;IACF,CAAC,GAAGtC,UAAU,CAAC0D,QAAQ,CAAC;IACxB,MAAME,eAAe,GAAI,GAAED,WAAY,GAAErB,OAAO,CAACU,QAAQ,CAACO,gBAAgB,GAAG,CAAC,EAAE,GAAG,CAAE,EAAC;IACtF,OAAO,IAAIvB,aAAa,CAAE,GAAE4B,eAAe,CAACC,KAAK,CAAC,CAAC,EAAE,CAACN,gBAAgB,CAAE,IAAGK,eAAe,CAACC,KAAK,CAAC,CAACN,gBAAgB,CAAE,EAAC,CAAC;EACxH;EACApD,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACS,KAAK;EACnB;EACAN,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAAC2B,GAAG;EACjB;EACAhB,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACd,OAAO,CAAC,CAAC,IAAI,IAAI,CAACG,KAAK,CAAC,CAAC;EACvC;EACAmB,MAAMA,CAACP,MAAM,EAAE;IACb,OAAO,IAAI,CAACS,QAAQ,CAAC,CAAC,MAAMT,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACS,QAAQ,CAAC,CAAC,CAAC;EAChG;EACAD,UAAUA,CAACR,MAAM,EAAE;IACjB,OAAO,IAAI,CAACF,GAAG,CAACE,MAAM,CAACJ,MAAM,CAAC,CAAC,CAACa,QAAQ,CAAC,CAAC,CAAC,CAACZ,QAAQ,CAAC,CAAC,IAAI,CAAC;EAC7D;EACAA,QAAQA,CAAA,EAAG;IACT,IAAI,IAAI,CAACT,KAAK,CAAC,CAAC,EAAE;MAChB,OAAOwD,GAAG;IACZ;IACA,OAAOzD,MAAM,CAAC,IAAI,CAACsB,QAAQ,CAAC,CAAC,CAAC;EAChC;EACAA,QAAQA,CAAA,EAAG;IACT,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;IACnF,IAAI,CAACD,IAAI,EAAE;MACT,OAAO,IAAI,CAACjB,MAAM;IACpB;IACA,IAAI,IAAI,CAACM,YAAY,CAAC,CAAC,EAAE;MACvB,OAAO,EAAE;IACX;IACA,OAAOjB,UAAU,CAAE,GAAE,IAAI,CAAC6C,OAAO,CAAC,CAAE,GAAE,IAAI,CAACC,aAAa,CAAC,CAAE,IAAG,IAAI,CAACC,aAAa,CAAC,CAAE,EAAC,CAAC,CAACgB,OAAO;EAC/F;AACF;AACA,eAAe,SAASC,cAAcA,CAAC5D,KAAK,EAAE;EAC5C;EACA;EACA,IAAIF,aAAa,CAAC,CAAC,EAAE;IACnB,OAAO,IAAI8B,aAAa,CAAC5B,KAAK,CAAC;EACjC;EACA,OAAO,IAAIK,aAAa,CAACL,KAAK,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoB,OAAOA,CAACyC,MAAM,EAAEC,YAAY,EAAEC,SAAS,EAAE;EACvD,IAAIC,OAAO,GAAGvC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;EACvF,IAAIoC,MAAM,KAAK,EAAE,EAAE;IACjB,OAAO,EAAE;EACX;EACA,MAAM;IACJN,WAAW;IACXU,UAAU;IACV3B;EACF,CAAC,GAAG1C,UAAU,CAACiE,MAAM,CAAC;EACtB,MAAMK,mBAAmB,GAAI,GAAEJ,YAAa,GAAExB,UAAW,EAAC;EAC1D,MAAM6B,oBAAoB,GAAI,GAAEZ,WAAY,GAAEU,UAAW,EAAC;EAC1D,IAAIF,SAAS,IAAI,CAAC,EAAE;IAClB;IACA,MAAMK,WAAW,GAAGnE,MAAM,CAACqC,UAAU,CAACyB,SAAS,CAAC,CAAC;IACjD,IAAIK,WAAW,IAAI,CAAC,IAAI,CAACJ,OAAO,EAAE;MAChC,MAAMK,eAAe,GAAGT,cAAc,CAACC,MAAM,CAAC,CAACjD,GAAG,CAAE,GAAE2C,WAAY,KAAI,GAAG,CAACe,MAAM,CAACP,SAAS,CAAE,GAAE,EAAE,GAAGK,WAAY,EAAC,CAAC;MACjH,OAAOhD,OAAO,CAACiD,eAAe,CAAC9C,QAAQ,CAAC,CAAC,EAAEuC,YAAY,EAAEC,SAAS,EAAEC,OAAO,CAAC;IAC9E;IACA,IAAID,SAAS,KAAK,CAAC,EAAE;MACnB,OAAOI,oBAAoB;IAC7B;IACA,OAAQ,GAAEA,oBAAqB,GAAEL,YAAa,GAAExB,UAAU,CAACU,MAAM,CAACe,SAAS,EAAE,GAAG,CAAC,CAACN,KAAK,CAAC,CAAC,EAAEM,SAAS,CAAE,EAAC;EACzG;EACA,IAAIG,mBAAmB,KAAK,IAAI,EAAE;IAChC,OAAOC,oBAAoB;EAC7B;EACA,OAAQ,GAAEA,oBAAqB,GAAED,mBAAoB,EAAC;AACxD"},"metadata":{},"sourceType":"module","externalDependencies":[]}