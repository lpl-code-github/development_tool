{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _typeof from 'babel-runtime/helpers/typeof';\nimport _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\n/* eslint no-loop-func: 0*/\nimport warning from 'warning';\nimport omit from 'omit.js';\nimport TreeNode from './TreeNode';\nimport { getSlotOptions, getOptionProps } from '../../_util/props-util';\nvar DRAG_SIDE_RANGE = 0.25;\nvar DRAG_MIN_GAP = 2;\nvar onlyTreeNodeWarned = false;\nexport function warnOnlyTreeNode() {\n  if (onlyTreeNodeWarned) return;\n  onlyTreeNodeWarned = true;\n  warning(false, 'Tree only accept TreeNode as children.');\n}\nexport function arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\nexport function arrAdd(list, value) {\n  var clone = list.slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getPosition(level, index) {\n  return level + '-' + index;\n}\nexport function isTreeNode(node) {\n  return getSlotOptions(node).isTreeNode;\n}\nexport function getNodeChildren() {\n  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return children.filter(isTreeNode);\n}\nexport function isCheckDisabled(node) {\n  var _ref = getOptionProps(node) || {},\n    disabled = _ref.disabled,\n    disableCheckbox = _ref.disableCheckbox,\n    checkable = _ref.checkable;\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\nexport function traverseTreeNodes(treeNodes, callback) {\n  function processNode(node, index, parent) {\n    var children = node ? node.componentOptions.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0;\n\n    // Filter children\n    var childList = getNodeChildren(children);\n\n    // Process node if is not root\n    if (node) {\n      var key = node.key;\n      if (!key && (key === undefined || key === null)) {\n        key = pos;\n      }\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: key,\n        parentPos: parent.node ? parent.pos : null\n      };\n      callback(data);\n    }\n\n    // Process children node\n    childList.forEach(function (subNode, subIndex) {\n      processNode(subNode, subIndex, {\n        node: node,\n        pos: pos\n      });\n    });\n  }\n  processNode(null);\n}\n\n/**\n * Use `rc-util` `toArray` to get the children list which keeps the key.\n * And return single node if children is only one(This can avoid `key` missing check).\n */\nexport function mapChildren() {\n  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var func = arguments[1];\n  var list = children.map(func);\n  if (list.length === 1) {\n    return list[0];\n  }\n  return list;\n}\nexport function getDragNodesKeys(treeNodes, node) {\n  var _getOptionProps = getOptionProps(node),\n    eventKey = _getOptionProps.eventKey,\n    pos = _getOptionProps.pos;\n  var dragNodesKeys = [];\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n    dragNodesKeys.push(key);\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n}\nexport function calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n  var _treeNode$$refs$selec = treeNode.$refs.selectHandle.getBoundingClientRect(),\n    top = _treeNode$$refs$selec.top,\n    bottom = _treeNode$$refs$selec.bottom,\n    height = _treeNode$$refs$selec.height;\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n  if (clientY <= top + des) {\n    return -1;\n  }\n  if (clientY >= bottom - des) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) {\n    return undefined;\n  }\n  var multiple = props.multiple;\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\n\n/**\n * Since React internal will convert key to string,\n * we need do this to avoid `checkStrictly` use number match\n */\n// function keyListToString (keyList) {\n//   if (!keyList) return keyList\n//   return keyList.map(key => String(key))\n// }\n\nvar internalProcessProps = function internalProcessProps() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    props: omit(props, ['on', 'key', 'class', 'className', 'style']),\n    on: props.on || {},\n    'class': props['class'] || props.className,\n    style: props.style,\n    key: props.key\n  };\n};\nexport function convertDataToTree(h, treeData, processor) {\n  if (!treeData) return [];\n  var _ref3 = processor || {},\n    _ref3$processProps = _ref3.processProps,\n    processProps = _ref3$processProps === undefined ? internalProcessProps : _ref3$processProps;\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref4) {\n    var children = _ref4.children,\n      props = _objectWithoutProperties(_ref4, ['children']);\n    var childrenNodes = convertDataToTree(h, children, processor);\n    return h(TreeNode, processProps(props), [childrenNodes]);\n  });\n}\n\n// TODO: ========================= NEW LOGIC =========================\n/**\n * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`\n * @param treeNodes\n * @param processTreeEntity  User can customize the entity\n */\nexport function convertTreeToEntities(treeNodes) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    initWrapper = _ref5.initWrapper,\n    processEntity = _ref5.processEntity,\n    onProcessFinished = _ref5.onProcessFinished;\n  var posEntities = new Map();\n  var keyEntities = new Map();\n  var wrapper = {\n    posEntities: posEntities,\n    keyEntities: keyEntities\n  };\n  if (initWrapper) {\n    wrapper = initWrapper(wrapper) || wrapper;\n  }\n  traverseTreeNodes(treeNodes, function (item) {\n    var node = item.node,\n      index = item.index,\n      pos = item.pos,\n      key = item.key,\n      parentPos = item.parentPos;\n    var entity = {\n      node: node,\n      index: index,\n      key: key,\n      pos: pos\n    };\n    posEntities.set(pos, entity);\n    keyEntities.set(key, entity);\n\n    // Fill children\n    entity.parent = posEntities.get(parentPos);\n    if (entity.parent) {\n      entity.parent.children = entity.parent.children || [];\n      entity.parent.children.push(entity);\n    }\n    if (processEntity) {\n      processEntity(entity, wrapper);\n    }\n  });\n  if (onProcessFinished) {\n    onProcessFinished(wrapper);\n  }\n  return wrapper;\n}\n\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  var keyProps = void 0;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if ((typeof keys === 'undefined' ? 'undefined' : _typeof(keys)) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  // keyProps.checkedKeys = keyListToString(keyProps.checkedKeys)\n  // keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys)\n\n  return keyProps;\n}\n\n/**\n * Conduct check state by the keyList. It will conduct up & from the provided key.\n * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.\n * @param keyList       list of keys\n * @param isCheck       is check the node or not\n * @param keyEntities   parsed by `convertTreeToEntities` function in Tree\n * @param checkStatus   Can pass current checked status for process (usually for uncheck operation)\n * @returns {{checkedKeys: [], halfCheckedKeys: []}}\n */\nexport function conductCheck(keyList, isCheck, keyEntities) {\n  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var checkedKeys = new Map();\n  var halfCheckedKeys = new Map(); // Record the key has some child checked (include child half checked)\n\n  (checkStatus.checkedKeys || []).forEach(function (key) {\n    checkedKeys.set(key, true);\n  });\n  (checkStatus.halfCheckedKeys || []).forEach(function (key) {\n    halfCheckedKeys.set(key, true);\n  });\n\n  // Conduct up\n  function conductUp(key) {\n    if (checkedKeys.get(key) === isCheck) return;\n    var entity = keyEntities.get(key);\n    if (!entity) return;\n    var children = entity.children,\n      parent = entity.parent,\n      node = entity.node;\n    if (isCheckDisabled(node)) return;\n\n    // Check child node checked status\n    var everyChildChecked = true;\n    var someChildChecked = false; // Child checked or half checked\n\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (_ref6) {\n      var childKey = _ref6.key;\n      var childChecked = checkedKeys.get(childKey);\n      var childHalfChecked = halfCheckedKeys.get(childKey);\n      if (childChecked || childHalfChecked) someChildChecked = true;\n      if (!childChecked) everyChildChecked = false;\n    });\n\n    // Update checked status\n    if (isCheck) {\n      checkedKeys.set(key, everyChildChecked);\n    } else {\n      checkedKeys.set(key, false);\n    }\n    halfCheckedKeys.set(key, someChildChecked);\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  // Conduct down\n  function conductDown(key) {\n    if (checkedKeys.get(key) === isCheck) return;\n    var entity = keyEntities.get(key);\n    if (!entity) return;\n    var children = entity.children,\n      node = entity.node;\n    if (isCheckDisabled(node)) return;\n    checkedKeys.set(key, isCheck);\n    (children || []).forEach(function (child) {\n      conductDown(child.key);\n    });\n  }\n  function conduct(key) {\n    var entity = keyEntities.get(key);\n    if (!entity) {\n      warning(false, '\\'' + key + '\\' does not exist in the tree.');\n      return;\n    }\n    var children = entity.children,\n      parent = entity.parent,\n      node = entity.node;\n    checkedKeys.set(key, isCheck);\n    if (isCheckDisabled(node)) return;\n\n    // Conduct down\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (child) {\n      conductDown(child.key);\n    });\n\n    // Conduct up\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n  (keyList || []).forEach(function (key) {\n    conduct(key);\n  });\n  var checkedKeyList = [];\n  var halfCheckedKeyList = [];\n\n  // Fill checked list\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = checkedKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref7 = _step.value;\n      var _ref8 = _slicedToArray(_ref7, 2);\n      var key = _ref8[0];\n      var value = _ref8[1];\n      if (value) {\n        checkedKeyList.push(key);\n      }\n    }\n\n    // Fill half checked list\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n  try {\n    for (var _iterator2 = halfCheckedKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _ref9 = _step2.value;\n      var _ref10 = _slicedToArray(_ref9, 2);\n      var _key = _ref10[0];\n      var _value = _ref10[1];\n      if (!checkedKeys.get(_key) && _value) {\n        halfCheckedKeyList.push(_key);\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n        _iterator2['return']();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n  return {\n    checkedKeys: checkedKeyList,\n    halfCheckedKeys: halfCheckedKeyList\n  };\n}\n\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\nexport function conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Map();\n  function conductUp(key) {\n    if (expandedKeys.get(key)) return;\n    var entity = keyEntities.get(key);\n    if (!entity) return;\n    expandedKeys.set(key, true);\n    var parent = entity.parent,\n      node = entity.node;\n    var props = getOptionProps(node);\n    if (props && props.disabled) return;\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return [].concat(_toConsumableArray(expandedKeys.keys()));\n}\n\n/**\n * Returns only the data- and aria- key/value pairs\n * @param {object} props\n */\nexport function getDataAndAria(props) {\n  return Object.keys(props).reduce(function (prev, key) {\n    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {\n      prev[key] = props[key];\n    }\n    return prev;\n  }, {});\n}","map":{"version":3,"names":["_toConsumableArray","_slicedToArray","_typeof","_objectWithoutProperties","warning","omit","TreeNode","getSlotOptions","getOptionProps","DRAG_SIDE_RANGE","DRAG_MIN_GAP","onlyTreeNodeWarned","warnOnlyTreeNode","arrDel","list","value","clone","slice","index","indexOf","splice","arrAdd","push","posToArr","pos","split","getPosition","level","isTreeNode","node","getNodeChildren","children","arguments","length","undefined","filter","isCheckDisabled","_ref","disabled","disableCheckbox","checkable","traverseTreeNodes","treeNodes","callback","processNode","parent","componentOptions","childList","key","data","parentPos","forEach","subNode","subIndex","mapChildren","func","map","getDragNodesKeys","_getOptionProps","eventKey","dragNodesKeys","_ref2","calcDropPosition","event","treeNode","clientY","_treeNode$$refs$selec","$refs","selectHandle","getBoundingClientRect","top","bottom","height","des","Math","max","calcSelectedKeys","selectedKeys","props","multiple","internalProcessProps","on","className","style","convertDataToTree","h","treeData","processor","_ref3","_ref3$processProps","processProps","Array","isArray","_ref4","childrenNodes","convertTreeToEntities","_ref5","initWrapper","processEntity","onProcessFinished","posEntities","Map","keyEntities","wrapper","item","entity","set","get","parseCheckedKeys","keys","keyProps","checkedKeys","halfCheckedKeys","checked","halfChecked","conductCheck","keyList","isCheck","checkStatus","conductUp","everyChildChecked","someChildChecked","child","_ref6","childKey","childChecked","childHalfChecked","conductDown","conduct","checkedKeyList","halfCheckedKeyList","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","_ref7","_ref8","err","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_ref9","_ref10","_key","_value","conductExpandParent","expandedKeys","concat","getDataAndAria","Object","reduce","prev","substr"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/client/node_modules/ant-design-vue/es/vc-tree/src/util.js"],"sourcesContent":["import _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _typeof from 'babel-runtime/helpers/typeof';\nimport _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\n/* eslint no-loop-func: 0*/\nimport warning from 'warning';\nimport omit from 'omit.js';\nimport TreeNode from './TreeNode';\nimport { getSlotOptions, getOptionProps } from '../../_util/props-util';\nvar DRAG_SIDE_RANGE = 0.25;\nvar DRAG_MIN_GAP = 2;\n\nvar onlyTreeNodeWarned = false;\n\nexport function warnOnlyTreeNode() {\n  if (onlyTreeNodeWarned) return;\n\n  onlyTreeNodeWarned = true;\n  warning(false, 'Tree only accept TreeNode as children.');\n}\n\nexport function arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\n\nexport function arrAdd(list, value) {\n  var clone = list.slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\n\nexport function posToArr(pos) {\n  return pos.split('-');\n}\n\nexport function getPosition(level, index) {\n  return level + '-' + index;\n}\n\nexport function isTreeNode(node) {\n  return getSlotOptions(node).isTreeNode;\n}\n\nexport function getNodeChildren() {\n  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  return children.filter(isTreeNode);\n}\n\nexport function isCheckDisabled(node) {\n  var _ref = getOptionProps(node) || {},\n      disabled = _ref.disabled,\n      disableCheckbox = _ref.disableCheckbox,\n      checkable = _ref.checkable;\n\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\nexport function traverseTreeNodes(treeNodes, callback) {\n  function processNode(node, index, parent) {\n    var children = node ? node.componentOptions.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0;\n\n    // Filter children\n    var childList = getNodeChildren(children);\n\n    // Process node if is not root\n    if (node) {\n      var key = node.key;\n      if (!key && (key === undefined || key === null)) {\n        key = pos;\n      }\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: key,\n        parentPos: parent.node ? parent.pos : null\n      };\n      callback(data);\n    }\n\n    // Process children node\n    childList.forEach(function (subNode, subIndex) {\n      processNode(subNode, subIndex, { node: node, pos: pos });\n    });\n  }\n\n  processNode(null);\n}\n\n/**\n * Use `rc-util` `toArray` to get the children list which keeps the key.\n * And return single node if children is only one(This can avoid `key` missing check).\n */\nexport function mapChildren() {\n  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var func = arguments[1];\n\n  var list = children.map(func);\n  if (list.length === 1) {\n    return list[0];\n  }\n  return list;\n}\n\nexport function getDragNodesKeys(treeNodes, node) {\n  var _getOptionProps = getOptionProps(node),\n      eventKey = _getOptionProps.eventKey,\n      pos = _getOptionProps.pos;\n\n  var dragNodesKeys = [];\n\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n\n    dragNodesKeys.push(key);\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n}\n\nexport function calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n\n  var _treeNode$$refs$selec = treeNode.$refs.selectHandle.getBoundingClientRect(),\n      top = _treeNode$$refs$selec.top,\n      bottom = _treeNode$$refs$selec.bottom,\n      height = _treeNode$$refs$selec.height;\n\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n\n  if (clientY <= top + des) {\n    return -1;\n  }\n  if (clientY >= bottom - des) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) {\n    return undefined;\n  }\n\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\n\n/**\n * Since React internal will convert key to string,\n * we need do this to avoid `checkStrictly` use number match\n */\n// function keyListToString (keyList) {\n//   if (!keyList) return keyList\n//   return keyList.map(key => String(key))\n// }\n\nvar internalProcessProps = function internalProcessProps() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return {\n    props: omit(props, ['on', 'key', 'class', 'className', 'style']),\n    on: props.on || {},\n    'class': props['class'] || props.className,\n    style: props.style,\n    key: props.key\n  };\n};\nexport function convertDataToTree(h, treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref3 = processor || {},\n      _ref3$processProps = _ref3.processProps,\n      processProps = _ref3$processProps === undefined ? internalProcessProps : _ref3$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref4) {\n    var children = _ref4.children,\n        props = _objectWithoutProperties(_ref4, ['children']);\n\n    var childrenNodes = convertDataToTree(h, children, processor);\n    return h(\n      TreeNode,\n      processProps(props),\n      [childrenNodes]\n    );\n  });\n}\n\n// TODO: ========================= NEW LOGIC =========================\n/**\n * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`\n * @param treeNodes\n * @param processTreeEntity  User can customize the entity\n */\nexport function convertTreeToEntities(treeNodes) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      initWrapper = _ref5.initWrapper,\n      processEntity = _ref5.processEntity,\n      onProcessFinished = _ref5.onProcessFinished;\n\n  var posEntities = new Map();\n  var keyEntities = new Map();\n  var wrapper = {\n    posEntities: posEntities,\n    keyEntities: keyEntities\n  };\n\n  if (initWrapper) {\n    wrapper = initWrapper(wrapper) || wrapper;\n  }\n\n  traverseTreeNodes(treeNodes, function (item) {\n    var node = item.node,\n        index = item.index,\n        pos = item.pos,\n        key = item.key,\n        parentPos = item.parentPos;\n\n    var entity = { node: node, index: index, key: key, pos: pos };\n\n    posEntities.set(pos, entity);\n    keyEntities.set(key, entity);\n\n    // Fill children\n    entity.parent = posEntities.get(parentPos);\n    if (entity.parent) {\n      entity.parent.children = entity.parent.children || [];\n      entity.parent.children.push(entity);\n    }\n\n    if (processEntity) {\n      processEntity(entity, wrapper);\n    }\n  });\n\n  if (onProcessFinished) {\n    onProcessFinished(wrapper);\n  }\n\n  return wrapper;\n}\n\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  var keyProps = void 0;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if ((typeof keys === 'undefined' ? 'undefined' : _typeof(keys)) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  // keyProps.checkedKeys = keyListToString(keyProps.checkedKeys)\n  // keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys)\n\n  return keyProps;\n}\n\n/**\n * Conduct check state by the keyList. It will conduct up & from the provided key.\n * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.\n * @param keyList       list of keys\n * @param isCheck       is check the node or not\n * @param keyEntities   parsed by `convertTreeToEntities` function in Tree\n * @param checkStatus   Can pass current checked status for process (usually for uncheck operation)\n * @returns {{checkedKeys: [], halfCheckedKeys: []}}\n */\nexport function conductCheck(keyList, isCheck, keyEntities) {\n  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var checkedKeys = new Map();\n  var halfCheckedKeys = new Map(); // Record the key has some child checked (include child half checked)\n\n  (checkStatus.checkedKeys || []).forEach(function (key) {\n    checkedKeys.set(key, true);\n  });\n\n  (checkStatus.halfCheckedKeys || []).forEach(function (key) {\n    halfCheckedKeys.set(key, true);\n  });\n\n  // Conduct up\n  function conductUp(key) {\n    if (checkedKeys.get(key) === isCheck) return;\n\n    var entity = keyEntities.get(key);\n    if (!entity) return;\n\n    var children = entity.children,\n        parent = entity.parent,\n        node = entity.node;\n\n\n    if (isCheckDisabled(node)) return;\n\n    // Check child node checked status\n    var everyChildChecked = true;\n    var someChildChecked = false; // Child checked or half checked\n\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (_ref6) {\n      var childKey = _ref6.key;\n\n      var childChecked = checkedKeys.get(childKey);\n      var childHalfChecked = halfCheckedKeys.get(childKey);\n\n      if (childChecked || childHalfChecked) someChildChecked = true;\n      if (!childChecked) everyChildChecked = false;\n    });\n\n    // Update checked status\n    if (isCheck) {\n      checkedKeys.set(key, everyChildChecked);\n    } else {\n      checkedKeys.set(key, false);\n    }\n    halfCheckedKeys.set(key, someChildChecked);\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  // Conduct down\n  function conductDown(key) {\n    if (checkedKeys.get(key) === isCheck) return;\n\n    var entity = keyEntities.get(key);\n    if (!entity) return;\n\n    var children = entity.children,\n        node = entity.node;\n\n\n    if (isCheckDisabled(node)) return;\n\n    checkedKeys.set(key, isCheck);\n\n    (children || []).forEach(function (child) {\n      conductDown(child.key);\n    });\n  }\n\n  function conduct(key) {\n    var entity = keyEntities.get(key);\n\n    if (!entity) {\n      warning(false, '\\'' + key + '\\' does not exist in the tree.');\n      return;\n    }\n    var children = entity.children,\n        parent = entity.parent,\n        node = entity.node;\n\n    checkedKeys.set(key, isCheck);\n\n    if (isCheckDisabled(node)) return;\n\n    // Conduct down\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (child) {\n      conductDown(child.key);\n    });\n\n    // Conduct up\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conduct(key);\n  });\n\n  var checkedKeyList = [];\n  var halfCheckedKeyList = [];\n\n  // Fill checked list\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = checkedKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref7 = _step.value;\n\n      var _ref8 = _slicedToArray(_ref7, 2);\n\n      var key = _ref8[0];\n      var value = _ref8[1];\n\n      if (value) {\n        checkedKeyList.push(key);\n      }\n    }\n\n    // Fill half checked list\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = halfCheckedKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _ref9 = _step2.value;\n\n      var _ref10 = _slicedToArray(_ref9, 2);\n\n      var _key = _ref10[0];\n      var _value = _ref10[1];\n\n      if (!checkedKeys.get(_key) && _value) {\n        halfCheckedKeyList.push(_key);\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n        _iterator2['return']();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    checkedKeys: checkedKeyList,\n    halfCheckedKeys: halfCheckedKeyList\n  };\n}\n\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\nexport function conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Map();\n\n  function conductUp(key) {\n    if (expandedKeys.get(key)) return;\n\n    var entity = keyEntities.get(key);\n    if (!entity) return;\n\n    expandedKeys.set(key, true);\n\n    var parent = entity.parent,\n        node = entity.node;\n\n    var props = getOptionProps(node);\n    if (props && props.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n\n  return [].concat(_toConsumableArray(expandedKeys.keys()));\n}\n\n/**\n * Returns only the data- and aria- key/value pairs\n * @param {object} props\n */\nexport function getDataAndAria(props) {\n  return Object.keys(props).reduce(function (prev, key) {\n    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {\n      prev[key] = props[key];\n    }\n    return prev;\n  }, {});\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}