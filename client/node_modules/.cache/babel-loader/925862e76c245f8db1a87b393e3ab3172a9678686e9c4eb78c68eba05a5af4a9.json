{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { warning } from '../../vc-util/warning';\nfunction getKey(data, index) {\n  const {\n    key\n  } = data;\n  let value;\n  if ('value' in data) {\n    ({\n      value\n    } = data);\n  }\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n  if (value !== undefined) {\n    return value;\n  }\n  return `rc-index-key-${index}`;\n}\nexport function fillFieldNames(fieldNames, childrenAsData) {\n  const {\n    label,\n    value,\n    options\n  } = fieldNames || {};\n  return {\n    label: label || (childrenAsData ? 'children' : 'label'),\n    value: value || 'value',\n    options: options || 'options'\n  };\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\nexport function flattenOptions(options) {\n  let {\n    fieldNames,\n    childrenAsData\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const flattenList = [];\n  const {\n    label: fieldLabel,\n    value: fieldValue,\n    options: fieldOptions\n  } = fillFieldNames(fieldNames, false);\n  function dig(list, isGroupOption) {\n    list.forEach(data => {\n      const label = data[fieldLabel];\n      if (isGroupOption || !(fieldOptions in data)) {\n        const value = data[fieldValue];\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data,\n          label,\n          value\n        });\n      } else {\n        let grpLabel = label;\n        if (grpLabel === undefined && childrenAsData) {\n          grpLabel = data.label;\n        }\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data,\n          label: grpLabel\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\nexport function injectPropsWithOption(option) {\n  const newOption = _extends({}, option);\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n  return newOption;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n  let match = false;\n  function separate(str, _ref) {\n    let [token, ...restTokens] = _ref;\n    if (!token) {\n      return [str];\n    }\n    const list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(unit => unit);\n  }\n  const list = separate(text, tokens);\n  return match ? list : null;\n}","map":{"version":3,"names":["_extends","warning","getKey","data","index","key","value","undefined","fillFieldNames","fieldNames","childrenAsData","label","options","flattenOptions","arguments","length","flattenList","fieldLabel","fieldValue","fieldOptions","dig","list","isGroupOption","forEach","push","groupOption","grpLabel","group","injectPropsWithOption","option","newOption","Object","defineProperty","get","getSeparatedContent","text","tokens","match","separate","str","_ref","token","restTokens","split","reduce","prevList","unitStr","filter","unit"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-select/utils/valueUtil.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { warning } from '../../vc-util/warning';\nfunction getKey(data, index) {\n  const {\n    key\n  } = data;\n  let value;\n  if ('value' in data) {\n    ({\n      value\n    } = data);\n  }\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n  if (value !== undefined) {\n    return value;\n  }\n  return `rc-index-key-${index}`;\n}\nexport function fillFieldNames(fieldNames, childrenAsData) {\n  const {\n    label,\n    value,\n    options\n  } = fieldNames || {};\n  return {\n    label: label || (childrenAsData ? 'children' : 'label'),\n    value: value || 'value',\n    options: options || 'options'\n  };\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\nexport function flattenOptions(options) {\n  let {\n    fieldNames,\n    childrenAsData\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const flattenList = [];\n  const {\n    label: fieldLabel,\n    value: fieldValue,\n    options: fieldOptions\n  } = fillFieldNames(fieldNames, false);\n  function dig(list, isGroupOption) {\n    list.forEach(data => {\n      const label = data[fieldLabel];\n      if (isGroupOption || !(fieldOptions in data)) {\n        const value = data[fieldValue];\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data,\n          label,\n          value\n        });\n      } else {\n        let grpLabel = label;\n        if (grpLabel === undefined && childrenAsData) {\n          grpLabel = data.label;\n        }\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data,\n          label: grpLabel\n        });\n        dig(data[fieldOptions], true);\n      }\n    });\n  }\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\nexport function injectPropsWithOption(option) {\n  const newOption = _extends({}, option);\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n  return newOption;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n  let match = false;\n  function separate(str, _ref) {\n    let [token, ...restTokens] = _ref;\n    if (!token) {\n      return [str];\n    }\n    const list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(unit => unit);\n  }\n  const list = separate(text, tokens);\n  return match ? list : null;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}