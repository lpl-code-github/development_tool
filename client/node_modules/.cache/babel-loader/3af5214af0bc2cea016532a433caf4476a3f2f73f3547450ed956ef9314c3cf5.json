{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport { defineComponent, nextTick, onBeforeUnmount, onMounted, onUpdated, reactive, ref, computed } from 'vue';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport classNames from '../_util/classNames';\nimport addEventListener from '../vc-util/Dom/addEventListener';\nimport Affix from '../affix';\nimport scrollTo from '../_util/scrollTo';\nimport getScroll from '../_util/getScroll';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport useProvideAnchor from './context';\nimport useStyle from './style';\nimport AnchorLink from './AnchorLink';\nimport PropTypes from '../_util/vue-types';\nimport devWarning from '../vc-util/devWarning';\nimport { arrayType } from '../_util/type';\nfunction getDefaultContainer() {\n  return window;\n}\nfunction getOffsetTop(element, container) {\n  if (!element.getClientRects().length) {\n    return 0;\n  }\n  const rect = element.getBoundingClientRect();\n  if (rect.width || rect.height) {\n    if (container === window) {\n      container = element.ownerDocument.documentElement;\n      return rect.top - container.clientTop;\n    }\n    return rect.top - container.getBoundingClientRect().top;\n  }\n  return rect.top;\n}\nconst sharpMatcherRegx = /#([\\S ]+)$/;\nexport const anchorProps = () => ({\n  prefixCls: String,\n  offsetTop: Number,\n  bounds: Number,\n  affix: {\n    type: Boolean,\n    default: true\n  },\n  showInkInFixed: {\n    type: Boolean,\n    default: false\n  },\n  getContainer: Function,\n  wrapperClass: String,\n  wrapperStyle: {\n    type: Object,\n    default: undefined\n  },\n  getCurrentAnchor: Function,\n  targetOffset: Number,\n  items: arrayType(),\n  direction: PropTypes.oneOf(['vertical', 'horizontal']).def('vertical'),\n  onChange: Function,\n  onClick: Function\n});\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAnchor',\n  inheritAttrs: false,\n  props: anchorProps(),\n  setup(props, _ref) {\n    let {\n      emit,\n      attrs,\n      slots,\n      expose\n    } = _ref;\n    var _a;\n    const {\n      prefixCls,\n      getTargetContainer,\n      direction\n    } = useConfigInject('anchor', props);\n    const anchorDirection = computed(() => {\n      var _a;\n      return (_a = props.direction) !== null && _a !== void 0 ? _a : 'vertical';\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      devWarning(props.items && typeof slots.default !== 'function', 'Anchor', '`Anchor children` is deprecated. Please use `items` instead.');\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      devWarning(!(anchorDirection.value === 'horizontal' && ((_a = props.items) === null || _a === void 0 ? void 0 : _a.some(n => 'children' in n))), 'Anchor', '`Anchor items#children` is not supported when `Anchor` direction is horizontal.');\n    }\n    const spanLinkNode = ref(null);\n    const anchorRef = ref();\n    const state = reactive({\n      links: [],\n      scrollContainer: null,\n      scrollEvent: null,\n      animating: false\n    });\n    const activeLink = ref(null);\n    const getContainer = computed(() => {\n      const {\n        getContainer\n      } = props;\n      return getContainer || (getTargetContainer === null || getTargetContainer === void 0 ? void 0 : getTargetContainer.value) || getDefaultContainer;\n    });\n    // func...\n    const getCurrentAnchor = function () {\n      let offsetTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n      const linkSections = [];\n      const container = getContainer.value();\n      state.links.forEach(link => {\n        const sharpLinkMatch = sharpMatcherRegx.exec(link.toString());\n        if (!sharpLinkMatch) {\n          return;\n        }\n        const target = document.getElementById(sharpLinkMatch[1]);\n        if (target) {\n          const top = getOffsetTop(target, container);\n          if (top < offsetTop + bounds) {\n            linkSections.push({\n              link,\n              top\n            });\n          }\n        }\n      });\n      if (linkSections.length) {\n        const maxSection = linkSections.reduce((prev, curr) => curr.top > prev.top ? curr : prev);\n        return maxSection.link;\n      }\n      return '';\n    };\n    const setCurrentActiveLink = link => {\n      const {\n        getCurrentAnchor\n      } = props;\n      if (activeLink.value === link) {\n        return;\n      }\n      activeLink.value = typeof getCurrentAnchor === 'function' ? getCurrentAnchor(link) : link;\n      emit('change', link);\n    };\n    const handleScrollTo = link => {\n      const {\n        offsetTop,\n        targetOffset\n      } = props;\n      setCurrentActiveLink(link);\n      const sharpLinkMatch = sharpMatcherRegx.exec(link);\n      if (!sharpLinkMatch) {\n        return;\n      }\n      const targetElement = document.getElementById(sharpLinkMatch[1]);\n      if (!targetElement) {\n        return;\n      }\n      const container = getContainer.value();\n      const scrollTop = getScroll(container, true);\n      const eleOffsetTop = getOffsetTop(targetElement, container);\n      let y = scrollTop + eleOffsetTop;\n      y -= targetOffset !== undefined ? targetOffset : offsetTop || 0;\n      state.animating = true;\n      scrollTo(y, {\n        callback: () => {\n          state.animating = false;\n        },\n        getContainer: getContainer.value\n      });\n    };\n    expose({\n      scrollTo: handleScrollTo\n    });\n    const handleScroll = () => {\n      if (state.animating) {\n        return;\n      }\n      const {\n        offsetTop,\n        bounds,\n        targetOffset\n      } = props;\n      const currentActiveLink = getCurrentAnchor(targetOffset !== undefined ? targetOffset : offsetTop || 0, bounds);\n      setCurrentActiveLink(currentActiveLink);\n    };\n    const updateInk = () => {\n      const linkNode = anchorRef.value.querySelector(`.${prefixCls.value}-link-title-active`);\n      if (linkNode && spanLinkNode.value) {\n        const horizontalAnchor = anchorDirection.value === 'horizontal';\n        spanLinkNode.value.style.top = horizontalAnchor ? '' : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;\n        spanLinkNode.value.style.height = horizontalAnchor ? '' : `${linkNode.clientHeight}px`;\n        spanLinkNode.value.style.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : '';\n        spanLinkNode.value.style.width = horizontalAnchor ? `${linkNode.clientWidth}px` : '';\n        if (horizontalAnchor) {\n          scrollIntoView(linkNode, {\n            scrollMode: 'if-needed',\n            block: 'nearest'\n          });\n        }\n      }\n    };\n    useProvideAnchor({\n      registerLink: link => {\n        if (!state.links.includes(link)) {\n          state.links.push(link);\n        }\n      },\n      unregisterLink: link => {\n        const index = state.links.indexOf(link);\n        if (index !== -1) {\n          state.links.splice(index, 1);\n        }\n      },\n      activeLink,\n      scrollTo: handleScrollTo,\n      handleClick: (e, info) => {\n        emit('click', e, info);\n      },\n      direction: anchorDirection\n    });\n    onMounted(() => {\n      nextTick(() => {\n        const container = getContainer.value();\n        state.scrollContainer = container;\n        state.scrollEvent = addEventListener(state.scrollContainer, 'scroll', handleScroll);\n        handleScroll();\n      });\n    });\n    onBeforeUnmount(() => {\n      if (state.scrollEvent) {\n        state.scrollEvent.remove();\n      }\n    });\n    onUpdated(() => {\n      if (state.scrollEvent) {\n        const currentContainer = getContainer.value();\n        if (state.scrollContainer !== currentContainer) {\n          state.scrollContainer = currentContainer;\n          state.scrollEvent.remove();\n          state.scrollEvent = addEventListener(state.scrollContainer, 'scroll', handleScroll);\n          handleScroll();\n        }\n      }\n      updateInk();\n    });\n    const createNestedLink = options => Array.isArray(options) ? options.map(option => {\n      const {\n        children,\n        key,\n        href,\n        target,\n        class: cls,\n        style,\n        title\n      } = option;\n      return _createVNode(AnchorLink, {\n        \"key\": key,\n        \"href\": href,\n        \"target\": target,\n        \"class\": cls,\n        \"style\": style,\n        \"title\": title,\n        \"customTitleProps\": option\n      }, {\n        default: () => [anchorDirection.value === 'vertical' ? createNestedLink(children) : null],\n        customTitle: slots.customTitle\n      });\n    }) : null;\n    const [wrapSSR, hashId] = useStyle(prefixCls);\n    return () => {\n      var _a;\n      const {\n        offsetTop,\n        affix,\n        showInkInFixed\n      } = props;\n      const pre = prefixCls.value;\n      const inkClass = classNames(`${pre}-ink`, {\n        [`${pre}-ink-visible`]: activeLink.value\n      });\n      const wrapperClass = classNames(hashId.value, props.wrapperClass, `${pre}-wrapper`, {\n        [`${pre}-wrapper-horizontal`]: anchorDirection.value === 'horizontal',\n        [`${pre}-rtl`]: direction.value === 'rtl'\n      });\n      const anchorClass = classNames(pre, {\n        [`${pre}-fixed`]: !affix && !showInkInFixed\n      });\n      const wrapperStyle = _extends({\n        maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : '100vh'\n      }, props.wrapperStyle);\n      const anchorContent = _createVNode(\"div\", {\n        \"class\": wrapperClass,\n        \"style\": wrapperStyle,\n        \"ref\": anchorRef\n      }, [_createVNode(\"div\", {\n        \"class\": anchorClass\n      }, [_createVNode(\"span\", {\n        \"class\": inkClass,\n        \"ref\": spanLinkNode\n      }, null), Array.isArray(props.items) ? createNestedLink(props.items) : (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])]);\n      return wrapSSR(!affix ? anchorContent : _createVNode(Affix, _objectSpread(_objectSpread({}, attrs), {}, {\n        \"offsetTop\": offsetTop,\n        \"target\": getContainer.value\n      }), {\n        default: () => [anchorContent]\n      }));\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","resolveDirective","_resolveDirective","defineComponent","nextTick","onBeforeUnmount","onMounted","onUpdated","reactive","ref","computed","scrollIntoView","classNames","addEventListener","Affix","scrollTo","getScroll","useConfigInject","useProvideAnchor","useStyle","AnchorLink","PropTypes","devWarning","arrayType","getDefaultContainer","window","getOffsetTop","element","container","getClientRects","length","rect","getBoundingClientRect","width","height","ownerDocument","documentElement","top","clientTop","sharpMatcherRegx","anchorProps","prefixCls","String","offsetTop","Number","bounds","affix","type","Boolean","default","showInkInFixed","getContainer","Function","wrapperClass","wrapperStyle","Object","undefined","getCurrentAnchor","targetOffset","items","direction","oneOf","def","onChange","onClick","compatConfig","MODE","name","inheritAttrs","props","setup","_ref","emit","attrs","slots","expose","_a","getTargetContainer","anchorDirection","process","env","NODE_ENV","value","some","n","spanLinkNode","anchorRef","state","links","scrollContainer","scrollEvent","animating","activeLink","arguments","linkSections","forEach","link","sharpLinkMatch","exec","toString","target","document","getElementById","push","maxSection","reduce","prev","curr","setCurrentActiveLink","handleScrollTo","targetElement","scrollTop","eleOffsetTop","y","callback","handleScroll","currentActiveLink","updateInk","linkNode","querySelector","horizontalAnchor","style","clientHeight","left","offsetLeft","clientWidth","scrollMode","block","registerLink","includes","unregisterLink","index","indexOf","splice","handleClick","e","info","remove","currentContainer","createNestedLink","options","Array","isArray","map","option","children","key","href","class","cls","title","customTitle","wrapSSR","hashId","pre","inkClass","anchorClass","maxHeight","anchorContent","call"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/anchor/Anchor.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport { defineComponent, nextTick, onBeforeUnmount, onMounted, onUpdated, reactive, ref, computed } from 'vue';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport classNames from '../_util/classNames';\nimport addEventListener from '../vc-util/Dom/addEventListener';\nimport Affix from '../affix';\nimport scrollTo from '../_util/scrollTo';\nimport getScroll from '../_util/getScroll';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport useProvideAnchor from './context';\nimport useStyle from './style';\nimport AnchorLink from './AnchorLink';\nimport PropTypes from '../_util/vue-types';\nimport devWarning from '../vc-util/devWarning';\nimport { arrayType } from '../_util/type';\nfunction getDefaultContainer() {\n  return window;\n}\nfunction getOffsetTop(element, container) {\n  if (!element.getClientRects().length) {\n    return 0;\n  }\n  const rect = element.getBoundingClientRect();\n  if (rect.width || rect.height) {\n    if (container === window) {\n      container = element.ownerDocument.documentElement;\n      return rect.top - container.clientTop;\n    }\n    return rect.top - container.getBoundingClientRect().top;\n  }\n  return rect.top;\n}\nconst sharpMatcherRegx = /#([\\S ]+)$/;\nexport const anchorProps = () => ({\n  prefixCls: String,\n  offsetTop: Number,\n  bounds: Number,\n  affix: {\n    type: Boolean,\n    default: true\n  },\n  showInkInFixed: {\n    type: Boolean,\n    default: false\n  },\n  getContainer: Function,\n  wrapperClass: String,\n  wrapperStyle: {\n    type: Object,\n    default: undefined\n  },\n  getCurrentAnchor: Function,\n  targetOffset: Number,\n  items: arrayType(),\n  direction: PropTypes.oneOf(['vertical', 'horizontal']).def('vertical'),\n  onChange: Function,\n  onClick: Function\n});\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAnchor',\n  inheritAttrs: false,\n  props: anchorProps(),\n  setup(props, _ref) {\n    let {\n      emit,\n      attrs,\n      slots,\n      expose\n    } = _ref;\n    var _a;\n    const {\n      prefixCls,\n      getTargetContainer,\n      direction\n    } = useConfigInject('anchor', props);\n    const anchorDirection = computed(() => {\n      var _a;\n      return (_a = props.direction) !== null && _a !== void 0 ? _a : 'vertical';\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      devWarning(props.items && typeof slots.default !== 'function', 'Anchor', '`Anchor children` is deprecated. Please use `items` instead.');\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      devWarning(!(anchorDirection.value === 'horizontal' && ((_a = props.items) === null || _a === void 0 ? void 0 : _a.some(n => 'children' in n))), 'Anchor', '`Anchor items#children` is not supported when `Anchor` direction is horizontal.');\n    }\n    const spanLinkNode = ref(null);\n    const anchorRef = ref();\n    const state = reactive({\n      links: [],\n      scrollContainer: null,\n      scrollEvent: null,\n      animating: false\n    });\n    const activeLink = ref(null);\n    const getContainer = computed(() => {\n      const {\n        getContainer\n      } = props;\n      return getContainer || (getTargetContainer === null || getTargetContainer === void 0 ? void 0 : getTargetContainer.value) || getDefaultContainer;\n    });\n    // func...\n    const getCurrentAnchor = function () {\n      let offsetTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n      const linkSections = [];\n      const container = getContainer.value();\n      state.links.forEach(link => {\n        const sharpLinkMatch = sharpMatcherRegx.exec(link.toString());\n        if (!sharpLinkMatch) {\n          return;\n        }\n        const target = document.getElementById(sharpLinkMatch[1]);\n        if (target) {\n          const top = getOffsetTop(target, container);\n          if (top < offsetTop + bounds) {\n            linkSections.push({\n              link,\n              top\n            });\n          }\n        }\n      });\n      if (linkSections.length) {\n        const maxSection = linkSections.reduce((prev, curr) => curr.top > prev.top ? curr : prev);\n        return maxSection.link;\n      }\n      return '';\n    };\n    const setCurrentActiveLink = link => {\n      const {\n        getCurrentAnchor\n      } = props;\n      if (activeLink.value === link) {\n        return;\n      }\n      activeLink.value = typeof getCurrentAnchor === 'function' ? getCurrentAnchor(link) : link;\n      emit('change', link);\n    };\n    const handleScrollTo = link => {\n      const {\n        offsetTop,\n        targetOffset\n      } = props;\n      setCurrentActiveLink(link);\n      const sharpLinkMatch = sharpMatcherRegx.exec(link);\n      if (!sharpLinkMatch) {\n        return;\n      }\n      const targetElement = document.getElementById(sharpLinkMatch[1]);\n      if (!targetElement) {\n        return;\n      }\n      const container = getContainer.value();\n      const scrollTop = getScroll(container, true);\n      const eleOffsetTop = getOffsetTop(targetElement, container);\n      let y = scrollTop + eleOffsetTop;\n      y -= targetOffset !== undefined ? targetOffset : offsetTop || 0;\n      state.animating = true;\n      scrollTo(y, {\n        callback: () => {\n          state.animating = false;\n        },\n        getContainer: getContainer.value\n      });\n    };\n    expose({\n      scrollTo: handleScrollTo\n    });\n    const handleScroll = () => {\n      if (state.animating) {\n        return;\n      }\n      const {\n        offsetTop,\n        bounds,\n        targetOffset\n      } = props;\n      const currentActiveLink = getCurrentAnchor(targetOffset !== undefined ? targetOffset : offsetTop || 0, bounds);\n      setCurrentActiveLink(currentActiveLink);\n    };\n    const updateInk = () => {\n      const linkNode = anchorRef.value.querySelector(`.${prefixCls.value}-link-title-active`);\n      if (linkNode && spanLinkNode.value) {\n        const horizontalAnchor = anchorDirection.value === 'horizontal';\n        spanLinkNode.value.style.top = horizontalAnchor ? '' : `${linkNode.offsetTop + linkNode.clientHeight / 2}px`;\n        spanLinkNode.value.style.height = horizontalAnchor ? '' : `${linkNode.clientHeight}px`;\n        spanLinkNode.value.style.left = horizontalAnchor ? `${linkNode.offsetLeft}px` : '';\n        spanLinkNode.value.style.width = horizontalAnchor ? `${linkNode.clientWidth}px` : '';\n        if (horizontalAnchor) {\n          scrollIntoView(linkNode, {\n            scrollMode: 'if-needed',\n            block: 'nearest'\n          });\n        }\n      }\n    };\n    useProvideAnchor({\n      registerLink: link => {\n        if (!state.links.includes(link)) {\n          state.links.push(link);\n        }\n      },\n      unregisterLink: link => {\n        const index = state.links.indexOf(link);\n        if (index !== -1) {\n          state.links.splice(index, 1);\n        }\n      },\n      activeLink,\n      scrollTo: handleScrollTo,\n      handleClick: (e, info) => {\n        emit('click', e, info);\n      },\n      direction: anchorDirection\n    });\n    onMounted(() => {\n      nextTick(() => {\n        const container = getContainer.value();\n        state.scrollContainer = container;\n        state.scrollEvent = addEventListener(state.scrollContainer, 'scroll', handleScroll);\n        handleScroll();\n      });\n    });\n    onBeforeUnmount(() => {\n      if (state.scrollEvent) {\n        state.scrollEvent.remove();\n      }\n    });\n    onUpdated(() => {\n      if (state.scrollEvent) {\n        const currentContainer = getContainer.value();\n        if (state.scrollContainer !== currentContainer) {\n          state.scrollContainer = currentContainer;\n          state.scrollEvent.remove();\n          state.scrollEvent = addEventListener(state.scrollContainer, 'scroll', handleScroll);\n          handleScroll();\n        }\n      }\n      updateInk();\n    });\n    const createNestedLink = options => Array.isArray(options) ? options.map(option => {\n      const {\n        children,\n        key,\n        href,\n        target,\n        class: cls,\n        style,\n        title\n      } = option;\n      return _createVNode(AnchorLink, {\n        \"key\": key,\n        \"href\": href,\n        \"target\": target,\n        \"class\": cls,\n        \"style\": style,\n        \"title\": title,\n        \"customTitleProps\": option\n      }, {\n        default: () => [anchorDirection.value === 'vertical' ? createNestedLink(children) : null],\n        customTitle: slots.customTitle\n      });\n    }) : null;\n    const [wrapSSR, hashId] = useStyle(prefixCls);\n    return () => {\n      var _a;\n      const {\n        offsetTop,\n        affix,\n        showInkInFixed\n      } = props;\n      const pre = prefixCls.value;\n      const inkClass = classNames(`${pre}-ink`, {\n        [`${pre}-ink-visible`]: activeLink.value\n      });\n      const wrapperClass = classNames(hashId.value, props.wrapperClass, `${pre}-wrapper`, {\n        [`${pre}-wrapper-horizontal`]: anchorDirection.value === 'horizontal',\n        [`${pre}-rtl`]: direction.value === 'rtl'\n      });\n      const anchorClass = classNames(pre, {\n        [`${pre}-fixed`]: !affix && !showInkInFixed\n      });\n      const wrapperStyle = _extends({\n        maxHeight: offsetTop ? `calc(100vh - ${offsetTop}px)` : '100vh'\n      }, props.wrapperStyle);\n      const anchorContent = _createVNode(\"div\", {\n        \"class\": wrapperClass,\n        \"style\": wrapperStyle,\n        \"ref\": anchorRef\n      }, [_createVNode(\"div\", {\n        \"class\": anchorClass\n      }, [_createVNode(\"span\", {\n        \"class\": inkClass,\n        \"ref\": spanLinkNode\n      }, null), Array.isArray(props.items) ? createNestedLink(props.items) : (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])]);\n      return wrapSSR(!affix ? anchorContent : _createVNode(Affix, _objectSpread(_objectSpread({}, attrs), {}, {\n        \"offsetTop\": offsetTop,\n        \"target\": getContainer.value\n      }), {\n        default: () => [anchorContent]\n      }));\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}