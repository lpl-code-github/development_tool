{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { toArray } from './typeUtil';\nimport get from '../../vc-util/get';\nimport set from '../../vc-util/set';\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\nexport function getValue(store, namePath) {\n  const value = get(store, namePath);\n  return value;\n}\nexport function setValue(store, namePath, value) {\n  let removeIfUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const newStore = set(store, namePath, value, removeIfUndefined);\n  return newStore;\n}\nexport function containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(path => matchNamePath(path, namePath));\n}\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Copy values into store and return a new values object\n * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }\n */\nfunction internalSetValues(store, values) {\n  const newStore = Array.isArray(store) ? [...store] : _extends({}, store);\n  if (!values) {\n    return newStore;\n  }\n  Object.keys(values).forEach(key => {\n    const prevValue = newStore[key];\n    const value = values[key];\n    // If both are object (but target is not array), we use recursion to set deep value\n    const recursive = isObject(prevValue) && isObject(value);\n    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\nexport function setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n  return restValues.reduce((current, newStore) => internalSetValues(current, newStore), store);\n}\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\nexport function matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n  return namePath.every((nameUnit, i) => changedNamePath[i] === nameUnit);\n}","map":{"version":3,"names":["_extends","toArray","get","set","getNamePath","path","getValue","store","namePath","value","setValue","removeIfUndefined","arguments","length","undefined","newStore","containsNamePath","namePathList","some","matchNamePath","isObject","obj","Object","getPrototypeOf","prototype","internalSetValues","values","Array","isArray","keys","forEach","key","prevValue","recursive","setValues","_len","restValues","_key","reduce","current","cloneByNamePathList","changedNamePath","every","nameUnit","i"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/form/utils/valueUtil.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { toArray } from './typeUtil';\nimport get from '../../vc-util/get';\nimport set from '../../vc-util/set';\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\nexport function getValue(store, namePath) {\n  const value = get(store, namePath);\n  return value;\n}\nexport function setValue(store, namePath, value) {\n  let removeIfUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const newStore = set(store, namePath, value, removeIfUndefined);\n  return newStore;\n}\nexport function containsNamePath(namePathList, namePath) {\n  return namePathList && namePathList.some(path => matchNamePath(path, namePath));\n}\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Copy values into store and return a new values object\n * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }\n */\nfunction internalSetValues(store, values) {\n  const newStore = Array.isArray(store) ? [...store] : _extends({}, store);\n  if (!values) {\n    return newStore;\n  }\n  Object.keys(values).forEach(key => {\n    const prevValue = newStore[key];\n    const value = values[key];\n    // If both are object (but target is not array), we use recursion to set deep value\n    const recursive = isObject(prevValue) && isObject(value);\n    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;\n  });\n  return newStore;\n}\nexport function setValues(store) {\n  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    restValues[_key - 1] = arguments[_key];\n  }\n  return restValues.reduce((current, newStore) => internalSetValues(current, newStore), store);\n}\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\nexport function matchNamePath(namePath, changedNamePath) {\n  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {\n    return false;\n  }\n  return namePath.every((nameUnit, i) => changedNamePath[i] === nameUnit);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}