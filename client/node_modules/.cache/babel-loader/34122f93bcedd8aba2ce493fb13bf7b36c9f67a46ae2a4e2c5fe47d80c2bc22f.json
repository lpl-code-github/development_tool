{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { computed, defineComponent, onBeforeUnmount, onMounted, shallowRef, watch } from 'vue';\nimport { getStyleStr, getPixelRatio, rotateWatermark, reRendering } from './utils';\nimport { arrayType, objectType, someType, withInstall } from '../_util/type';\nimport { useMutationObserver } from '../_util/hooks/_vueuse/useMutationObserver';\nimport { initDefaultProps } from '../_util/props-util';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nexport const watermarkProps = () => ({\n  zIndex: Number,\n  rotate: Number,\n  width: Number,\n  height: Number,\n  image: String,\n  content: someType([String, Array]),\n  font: objectType(),\n  rootClassName: String,\n  gap: arrayType(),\n  offset: arrayType()\n});\nconst Watermark = defineComponent({\n  name: 'AWatermark',\n  inheritAttrs: false,\n  props: initDefaultProps(watermarkProps(), {\n    zIndex: 9,\n    rotate: -22,\n    font: {},\n    gap: [100, 100]\n  }),\n  setup(props, _ref) {\n    let {\n      slots,\n      attrs\n    } = _ref;\n    const containerRef = shallowRef();\n    const watermarkRef = shallowRef();\n    const stopObservation = shallowRef(false);\n    const gapX = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapY = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapXCenter = computed(() => gapX.value / 2);\n    const gapYCenter = computed(() => gapY.value / 2);\n    const offsetLeft = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : gapXCenter.value;\n    });\n    const offsetTop = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : gapYCenter.value;\n    });\n    const fontSize = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontSize) !== null && _b !== void 0 ? _b : 16;\n    });\n    const fontWeight = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontWeight) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontStyle = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontStyle) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontFamily = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontFamily) !== null && _b !== void 0 ? _b : 'sans-serif';\n    });\n    const color = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : 'rgba(0, 0, 0, 0.15)';\n    });\n    const markStyle = computed(() => {\n      var _a;\n      const markStyle = {\n        zIndex: (_a = props.zIndex) !== null && _a !== void 0 ? _a : 9,\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        backgroundRepeat: 'repeat'\n      };\n      /** Calculate the style of the offset */\n      let positionLeft = offsetLeft.value - gapXCenter.value;\n      let positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = `${positionLeft}px`;\n        markStyle.width = `calc(100% - ${positionLeft}px)`;\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = `${positionTop}px`;\n        markStyle.height = `calc(100% - ${positionTop}px)`;\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n      return markStyle;\n    });\n    const destroyWatermark = () => {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = undefined;\n      }\n    };\n    const appendWatermark = (base64Url, markWidth) => {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute('style', getStyleStr(_extends(_extends({}, markStyle.value), {\n          backgroundImage: `url('${base64Url}')`,\n          backgroundSize: `${(gapX.value + markWidth) * BaseSize}px`\n        })));\n        (_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.value);\n        // Delayed execution\n        setTimeout(() => {\n          stopObservation.value = false;\n        });\n      }\n    };\n    /**\n     * Get the width and height of the watermark. The default values are as follows\n     * Image: [120, 64]; Content: It's calculated by content;\n     */\n    const getMarkSize = ctx => {\n      let defaultWidth = 120;\n      let defaultHeight = 64;\n      const content = props.content;\n      const image = props.image;\n      const width = props.width;\n      const height = props.height;\n      if (!image && ctx.measureText) {\n        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;\n        const contents = Array.isArray(content) ? content : [content];\n        const widths = contents.map(item => ctx.measureText(item).width);\n        defaultWidth = Math.ceil(Math.max(...widths));\n        defaultHeight = Number(fontSize.value) * contents.length + (contents.length - 1) * FontGap;\n      }\n      return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n    };\n    const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n      const ratio = getPixelRatio();\n      const content = props.content;\n      const mergedFontSize = Number(fontSize.value) * ratio;\n      ctx.font = `${fontStyle.value} normal ${fontWeight.value} ${mergedFontSize}px/${drawHeight}px ${fontFamily.value}`;\n      ctx.fillStyle = color.value;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.translate(drawWidth / 2, 0);\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n      });\n    };\n    const renderWatermark = () => {\n      var _a;\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const image = props.image;\n      const rotate = (_a = props.rotate) !== null && _a !== void 0 ? _a : -22;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement('div');\n        }\n        const ratio = getPixelRatio();\n        const [markWidth, markHeight] = getMarkSize(ctx);\n        const canvasWidth = (gapX.value + markWidth) * ratio;\n        const canvasHeight = (gapY.value + markHeight) * ratio;\n        canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n        canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n        const drawX = gapX.value * ratio / 2;\n        const drawY = gapY.value * ratio / 2;\n        const drawWidth = markWidth * ratio;\n        const drawHeight = markHeight * ratio;\n        const rotateX = (drawWidth + gapX.value * ratio) / 2;\n        const rotateY = (drawHeight + gapY.value * ratio) / 2;\n        /** Alternate drawing parameters */\n        const alternateDrawX = drawX + canvasWidth;\n        const alternateDrawY = drawY + canvasHeight;\n        const alternateRotateX = rotateX + canvasWidth;\n        const alternateRotateY = rotateY + canvasHeight;\n        ctx.save();\n        rotateWatermark(ctx, rotateX, rotateY, rotate);\n        if (image) {\n          const img = new Image();\n          img.onload = () => {\n            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n            /** Draw interleaved pictures after rotation */\n            ctx.restore();\n            rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n            ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n            appendWatermark(canvas.toDataURL(), markWidth);\n          };\n          img.crossOrigin = 'anonymous';\n          img.referrerPolicy = 'no-referrer';\n          img.src = image;\n        } else {\n          fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n          /** Fill the interleaved text after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        }\n      }\n    };\n    onMounted(() => {\n      renderWatermark();\n    });\n    watch(() => props, () => {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: 'post'\n    });\n    onBeforeUnmount(() => {\n      destroyWatermark();\n    });\n    const onMutate = mutations => {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(mutation => {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true\n    });\n    return () => {\n      var _a;\n      return _createVNode(\"div\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"ref\": containerRef,\n        \"class\": [attrs.class, props.rootClassName],\n        \"style\": [{\n          position: 'relative'\n        }, attrs.style]\n      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);\n    };\n  }\n});\nexport default withInstall(Watermark);","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","computed","defineComponent","onBeforeUnmount","onMounted","shallowRef","watch","getStyleStr","getPixelRatio","rotateWatermark","reRendering","arrayType","objectType","someType","withInstall","useMutationObserver","initDefaultProps","BaseSize","FontGap","watermarkProps","zIndex","Number","rotate","width","height","image","String","content","Array","font","rootClassName","gap","offset","Watermark","name","inheritAttrs","props","setup","_ref","slots","attrs","containerRef","watermarkRef","stopObservation","gapX","_a","_b","gapY","gapXCenter","value","gapYCenter","offsetLeft","offsetTop","fontSize","fontWeight","fontStyle","fontFamily","color","markStyle","position","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","destroyWatermark","remove","undefined","appendWatermark","base64Url","markWidth","setAttribute","backgroundImage","backgroundSize","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","contents","isArray","widths","map","item","Math","ceil","max","length","fillTexts","drawX","drawY","drawWidth","drawHeight","ratio","mergedFontSize","fillStyle","textAlign","textBaseline","translate","forEach","index","fillText","renderWatermark","canvas","document","createElement","getContext","markHeight","canvasWidth","canvasHeight","rotateX","rotateY","alternateDrawX","alternateDrawY","alternateRotateX","alternateRotateY","save","img","Image","onload","drawImage","restore","toDataURL","crossOrigin","referrerPolicy","src","deep","flush","onMutate","mutations","mutation","attributes","class","style","default","call"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/watermark/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { computed, defineComponent, onBeforeUnmount, onMounted, shallowRef, watch } from 'vue';\nimport { getStyleStr, getPixelRatio, rotateWatermark, reRendering } from './utils';\nimport { arrayType, objectType, someType, withInstall } from '../_util/type';\nimport { useMutationObserver } from '../_util/hooks/_vueuse/useMutationObserver';\nimport { initDefaultProps } from '../_util/props-util';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nexport const watermarkProps = () => ({\n  zIndex: Number,\n  rotate: Number,\n  width: Number,\n  height: Number,\n  image: String,\n  content: someType([String, Array]),\n  font: objectType(),\n  rootClassName: String,\n  gap: arrayType(),\n  offset: arrayType()\n});\nconst Watermark = defineComponent({\n  name: 'AWatermark',\n  inheritAttrs: false,\n  props: initDefaultProps(watermarkProps(), {\n    zIndex: 9,\n    rotate: -22,\n    font: {},\n    gap: [100, 100]\n  }),\n  setup(props, _ref) {\n    let {\n      slots,\n      attrs\n    } = _ref;\n    const containerRef = shallowRef();\n    const watermarkRef = shallowRef();\n    const stopObservation = shallowRef(false);\n    const gapX = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapY = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.gap) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : 100;\n    });\n    const gapXCenter = computed(() => gapX.value / 2);\n    const gapYCenter = computed(() => gapY.value / 2);\n    const offsetLeft = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : gapXCenter.value;\n    });\n    const offsetTop = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : gapYCenter.value;\n    });\n    const fontSize = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontSize) !== null && _b !== void 0 ? _b : 16;\n    });\n    const fontWeight = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontWeight) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontStyle = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontStyle) !== null && _b !== void 0 ? _b : 'normal';\n    });\n    const fontFamily = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.fontFamily) !== null && _b !== void 0 ? _b : 'sans-serif';\n    });\n    const color = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : 'rgba(0, 0, 0, 0.15)';\n    });\n    const markStyle = computed(() => {\n      var _a;\n      const markStyle = {\n        zIndex: (_a = props.zIndex) !== null && _a !== void 0 ? _a : 9,\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        width: '100%',\n        height: '100%',\n        pointerEvents: 'none',\n        backgroundRepeat: 'repeat'\n      };\n      /** Calculate the style of the offset */\n      let positionLeft = offsetLeft.value - gapXCenter.value;\n      let positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = `${positionLeft}px`;\n        markStyle.width = `calc(100% - ${positionLeft}px)`;\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = `${positionTop}px`;\n        markStyle.height = `calc(100% - ${positionTop}px)`;\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n      return markStyle;\n    });\n    const destroyWatermark = () => {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = undefined;\n      }\n    };\n    const appendWatermark = (base64Url, markWidth) => {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute('style', getStyleStr(_extends(_extends({}, markStyle.value), {\n          backgroundImage: `url('${base64Url}')`,\n          backgroundSize: `${(gapX.value + markWidth) * BaseSize}px`\n        })));\n        (_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.value);\n        // Delayed execution\n        setTimeout(() => {\n          stopObservation.value = false;\n        });\n      }\n    };\n    /**\n     * Get the width and height of the watermark. The default values are as follows\n     * Image: [120, 64]; Content: It's calculated by content;\n     */\n    const getMarkSize = ctx => {\n      let defaultWidth = 120;\n      let defaultHeight = 64;\n      const content = props.content;\n      const image = props.image;\n      const width = props.width;\n      const height = props.height;\n      if (!image && ctx.measureText) {\n        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;\n        const contents = Array.isArray(content) ? content : [content];\n        const widths = contents.map(item => ctx.measureText(item).width);\n        defaultWidth = Math.ceil(Math.max(...widths));\n        defaultHeight = Number(fontSize.value) * contents.length + (contents.length - 1) * FontGap;\n      }\n      return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n    };\n    const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n      const ratio = getPixelRatio();\n      const content = props.content;\n      const mergedFontSize = Number(fontSize.value) * ratio;\n      ctx.font = `${fontStyle.value} normal ${fontWeight.value} ${mergedFontSize}px/${drawHeight}px ${fontFamily.value}`;\n      ctx.fillStyle = color.value;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'top';\n      ctx.translate(drawWidth / 2, 0);\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n      });\n    };\n    const renderWatermark = () => {\n      var _a;\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      const image = props.image;\n      const rotate = (_a = props.rotate) !== null && _a !== void 0 ? _a : -22;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement('div');\n        }\n        const ratio = getPixelRatio();\n        const [markWidth, markHeight] = getMarkSize(ctx);\n        const canvasWidth = (gapX.value + markWidth) * ratio;\n        const canvasHeight = (gapY.value + markHeight) * ratio;\n        canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n        canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n        const drawX = gapX.value * ratio / 2;\n        const drawY = gapY.value * ratio / 2;\n        const drawWidth = markWidth * ratio;\n        const drawHeight = markHeight * ratio;\n        const rotateX = (drawWidth + gapX.value * ratio) / 2;\n        const rotateY = (drawHeight + gapY.value * ratio) / 2;\n        /** Alternate drawing parameters */\n        const alternateDrawX = drawX + canvasWidth;\n        const alternateDrawY = drawY + canvasHeight;\n        const alternateRotateX = rotateX + canvasWidth;\n        const alternateRotateY = rotateY + canvasHeight;\n        ctx.save();\n        rotateWatermark(ctx, rotateX, rotateY, rotate);\n        if (image) {\n          const img = new Image();\n          img.onload = () => {\n            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n            /** Draw interleaved pictures after rotation */\n            ctx.restore();\n            rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n            ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n            appendWatermark(canvas.toDataURL(), markWidth);\n          };\n          img.crossOrigin = 'anonymous';\n          img.referrerPolicy = 'no-referrer';\n          img.src = image;\n        } else {\n          fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n          /** Fill the interleaved text after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        }\n      }\n    };\n    onMounted(() => {\n      renderWatermark();\n    });\n    watch(() => props, () => {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: 'post'\n    });\n    onBeforeUnmount(() => {\n      destroyWatermark();\n    });\n    const onMutate = mutations => {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(mutation => {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true\n    });\n    return () => {\n      var _a;\n      return _createVNode(\"div\", _objectSpread(_objectSpread({}, attrs), {}, {\n        \"ref\": containerRef,\n        \"class\": [attrs.class, props.rootClassName],\n        \"style\": [{\n          position: 'relative'\n        }, attrs.style]\n      }), [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)]);\n    };\n  }\n});\nexport default withInstall(Watermark);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}