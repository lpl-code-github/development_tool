{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\nconst trimAlignValue = _ref => {\n  let {\n    value,\n    handle,\n    bounds,\n    props\n  } = _ref;\n  const {\n    allowCross,\n    pushable\n  } = props;\n  const thershold = Number(pushable);\n  const valInRange = utils.ensureValueInRange(value, props);\n  let valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nconst rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    default: undefined\n  },\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  reverse: {\n    type: Boolean,\n    default: undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    default: undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    default: undefined\n  }\n};\nconst Range = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data() {\n    const {\n      count,\n      min,\n      max\n    } = this;\n    const initialValue = Array(...Array(count + 1)).map(() => min);\n    const defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    let {\n      value\n    } = this;\n    if (value === undefined) {\n      value = defaultValue;\n    }\n    const bounds = value.map((v, i) => trimAlignValue({\n      value: v,\n      handle: i,\n      props: this.$props\n    }));\n    const recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent,\n      bounds\n    };\n  },\n  watch: {\n    value: {\n      handler(val) {\n        const {\n          bounds\n        } = this;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min() {\n      const {\n        value\n      } = this;\n      this.setChangeValue(value || this.bounds);\n    },\n    max() {\n      const {\n        value\n      } = this;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue(value) {\n      const {\n        bounds\n      } = this;\n      let nextBounds = value.map((v, i) => trimAlignValue({\n        value: v,\n        handle: i,\n        bounds,\n        props: this.$props\n      }));\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every((v, i) => v === bounds[i])) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map((v, i) => trimAlignValue({\n          value: v,\n          handle: i,\n          props: this.$props\n        }));\n      }\n      this.setState({\n        bounds: nextBounds\n      });\n      if (value.some(v => utils.isValueOutOfRange(v, this.$props))) {\n        const newValues = value.map(v => {\n          return utils.ensureValueInRange(v, this.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange(state) {\n      const isNotControlled = !hasProp(this, 'value');\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        const controlledState = {};\n        ['sHandle', 'recent'].forEach(item => {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      const data = _extends(_extends({}, this.$data), state);\n      const changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue(position) {\n      const bounds = this.getValue();\n      const value = this.calcValueByPos(position);\n      const closestBound = this.getClosestBound(value);\n      const index = this.getBoundNeedMoving(value, closestBound);\n      const prevValue = bounds[index];\n      if (value === prevValue) return null;\n      const nextBounds = [...bounds];\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart(position) {\n      const {\n        bounds\n      } = this;\n      this.$emit('beforeChange', bounds);\n      const value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      const closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      const prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      const nextBounds = [...bounds];\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd(force) {\n      const {\n        sHandle\n      } = this;\n      this.removeDocumentEvents();\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      const {\n        $data: state,\n        $props: props\n      } = this;\n      const maxValue = props.max || 100;\n      const minValue = props.min || 0;\n      if (dragTrack) {\n        let pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        const max = maxValue - Math.max(...startBounds);\n        const min = minValue - Math.min(...startBounds);\n        const ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        const nextBounds = startBounds.map(v => Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue)));\n        if (state.bounds.map((c, i) => c === nextBounds[i]).some(c => !c)) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      const {\n        bounds,\n        sHandle\n      } = this;\n      const value = this.calcValueByPos(position);\n      const oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard(e) {\n      const {\n        reverse,\n        vertical\n      } = this.$props;\n      const valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        const {\n          bounds,\n          sHandle\n        } = this;\n        const oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        const mutatedValue = valueMutator(oldValue, this.$props);\n        const value = trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds,\n          props: this.$props\n        });\n        if (value === oldValue) return;\n        const isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound(value) {\n      const {\n        bounds\n      } = this;\n      let closestBound = 0;\n      for (let i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    },\n    getBoundNeedMoving(value, closestBound) {\n      const {\n        bounds,\n        recent\n      } = this;\n      let boundNeedMoving = closestBound;\n      const isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    },\n    getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound() {\n      const {\n        bounds\n      } = this;\n      return bounds[bounds.length - 1];\n    },\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints() {\n      const {\n        marks,\n        step,\n        min,\n        max\n      } = this;\n      const cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        const pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (let point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        const points = Object.keys(pointsObject).map(parseFloat);\n        points.sort((a, b) => a - b);\n        this.internalPointsCache = {\n          marks,\n          step,\n          points\n        };\n      }\n      return this.internalPointsCache.points;\n    },\n    moveTo(value, isFromKeyboardEvent) {\n      const nextBounds = [...this.bounds];\n      const {\n        sHandle,\n        recent\n      } = this;\n      const handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      let nextHandle = handle;\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort((a, b) => a - b);\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, () => {\n          this.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles(bounds, handle) {\n      const value = bounds[handle];\n      const {\n        pushable\n      } = this;\n      const threshold = Number(pushable);\n      let direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      const nextHandle = handle + direction;\n      const diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle(bounds, handle, direction, amount) {\n      const originalValue = bounds[handle];\n      let currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    },\n    pushHandleOnePoint(bounds, handle, direction) {\n      const points = this.getPoints();\n      const pointIndex = points.indexOf(bounds[handle]);\n      const nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      const nextHandle = handle + direction;\n      const nextValue = points[nextPointIndex];\n      const {\n        pushable\n      } = this;\n      const threshold = Number(pushable);\n      const diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue(value) {\n      const {\n        sHandle,\n        bounds\n      } = this;\n      return trimAlignValue({\n        value,\n        handle: sHandle,\n        bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict(handle, val, _ref2) {\n      let {\n        allowCross,\n        pushable: thershold\n      } = _ref2;\n      const state = this.$data || {};\n      const {\n        bounds\n      } = state;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    },\n    getTrack(_ref3) {\n      let {\n        bounds,\n        prefixCls,\n        reverse,\n        vertical,\n        included,\n        offsets,\n        trackStyle\n      } = _ref3;\n      return bounds.slice(0, -1).map((_, index) => {\n        const i = index + 1;\n        const trackClassName = classNames({\n          [`${prefixCls}-track`]: true,\n          [`${prefixCls}-track-${i}`]: true\n        });\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider() {\n      const {\n        sHandle,\n        bounds,\n        prefixCls,\n        vertical,\n        included,\n        disabled,\n        min,\n        max,\n        reverse,\n        handle,\n        defaultHandle,\n        trackStyle,\n        handleStyle,\n        tabindex,\n        ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles\n      } = this;\n      const handleGenerator = handle || defaultHandle;\n      const offsets = bounds.map(v => this.calcOffset(v));\n      const handleClassName = `${prefixCls}-handle`;\n      const handles = bounds.map((v, i) => {\n        let mergedTabIndex = tabindex[i] || 0;\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n        const dragging = sHandle === i;\n        return handleGenerator({\n          class: classNames({\n            [handleClassName]: true,\n            [`${handleClassName}-${i + 1}`]: true,\n            [`${handleClassName}-dragging`]: dragging\n          }),\n          prefixCls,\n          vertical,\n          dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min,\n          max,\n          reverse,\n          disabled,\n          style: handleStyle[i],\n          ref: h => this.saveHandle(i, h),\n          onFocus: this.onFocus,\n          onBlur: this.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds,\n          prefixCls,\n          reverse,\n          vertical,\n          included,\n          offsets,\n          trackStyle\n        }),\n        handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);","map":{"version":3,"names":["_extends","createVNode","_createVNode","classNames","PropTypes","withUndefined","BaseMixin","hasProp","Track","createSlider","utils","initDefaultProps","defineComponent","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","rangeProps","defaultValue","arrayOf","number","count","oneOfType","looseBool","type","Boolean","default","disabled","reverse","tabindex","prefixCls","String","min","max","autofocus","ariaLabelGroupForHandles","Array","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","draggableTrack","Range","compatConfig","MODE","name","mixins","inheritAttrs","emits","displayName","data","initialValue","map","v","i","$props","recent","sHandle","watch","handler","val","setChangeValue","deep","methods","nextBounds","every","setState","some","isValueOutOfRange","newValues","$emit","onChange","state","isNotControlled","controlledState","forEach","item","Object","keys","$data","changedValue","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","onStart","startValue","startPosition","prevMovedHandleIndex","onEnd","force","removeDocumentEvents","dragTrack","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","Math","ratio","getSliderLength","floor","c","oldValue","moveTo","onKeyboard","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","ensureValueNotConflict","_ref2","getTrack","_ref3","included","offsets","trackStyle","slice","_","trackClassName","renderSlider","defaultHandle","handleStyle","handleGenerator","calcOffset","handleClassName","handles","mergedTabIndex","dragging","class","offset","style","ref","h","saveHandle","onFocus","onBlur","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/vc-slider/src/Range.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\nconst trimAlignValue = _ref => {\n  let {\n    value,\n    handle,\n    bounds,\n    props\n  } = _ref;\n  const {\n    allowCross,\n    pushable\n  } = props;\n  const thershold = Number(pushable);\n  const valInRange = utils.ensureValueInRange(value, props);\n  let valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nconst rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    default: undefined\n  },\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  reverse: {\n    type: Boolean,\n    default: undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    default: undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    default: undefined\n  }\n};\nconst Range = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data() {\n    const {\n      count,\n      min,\n      max\n    } = this;\n    const initialValue = Array(...Array(count + 1)).map(() => min);\n    const defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    let {\n      value\n    } = this;\n    if (value === undefined) {\n      value = defaultValue;\n    }\n    const bounds = value.map((v, i) => trimAlignValue({\n      value: v,\n      handle: i,\n      props: this.$props\n    }));\n    const recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent,\n      bounds\n    };\n  },\n  watch: {\n    value: {\n      handler(val) {\n        const {\n          bounds\n        } = this;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min() {\n      const {\n        value\n      } = this;\n      this.setChangeValue(value || this.bounds);\n    },\n    max() {\n      const {\n        value\n      } = this;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue(value) {\n      const {\n        bounds\n      } = this;\n      let nextBounds = value.map((v, i) => trimAlignValue({\n        value: v,\n        handle: i,\n        bounds,\n        props: this.$props\n      }));\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every((v, i) => v === bounds[i])) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map((v, i) => trimAlignValue({\n          value: v,\n          handle: i,\n          props: this.$props\n        }));\n      }\n      this.setState({\n        bounds: nextBounds\n      });\n      if (value.some(v => utils.isValueOutOfRange(v, this.$props))) {\n        const newValues = value.map(v => {\n          return utils.ensureValueInRange(v, this.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange(state) {\n      const isNotControlled = !hasProp(this, 'value');\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        const controlledState = {};\n        ['sHandle', 'recent'].forEach(item => {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      const data = _extends(_extends({}, this.$data), state);\n      const changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue(position) {\n      const bounds = this.getValue();\n      const value = this.calcValueByPos(position);\n      const closestBound = this.getClosestBound(value);\n      const index = this.getBoundNeedMoving(value, closestBound);\n      const prevValue = bounds[index];\n      if (value === prevValue) return null;\n      const nextBounds = [...bounds];\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart(position) {\n      const {\n        bounds\n      } = this;\n      this.$emit('beforeChange', bounds);\n      const value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      const closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      const prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      const nextBounds = [...bounds];\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd(force) {\n      const {\n        sHandle\n      } = this;\n      this.removeDocumentEvents();\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      const {\n        $data: state,\n        $props: props\n      } = this;\n      const maxValue = props.max || 100;\n      const minValue = props.min || 0;\n      if (dragTrack) {\n        let pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        const max = maxValue - Math.max(...startBounds);\n        const min = minValue - Math.min(...startBounds);\n        const ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        const nextBounds = startBounds.map(v => Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue)));\n        if (state.bounds.map((c, i) => c === nextBounds[i]).some(c => !c)) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      const {\n        bounds,\n        sHandle\n      } = this;\n      const value = this.calcValueByPos(position);\n      const oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard(e) {\n      const {\n        reverse,\n        vertical\n      } = this.$props;\n      const valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        const {\n          bounds,\n          sHandle\n        } = this;\n        const oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        const mutatedValue = valueMutator(oldValue, this.$props);\n        const value = trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds,\n          props: this.$props\n        });\n        if (value === oldValue) return;\n        const isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound(value) {\n      const {\n        bounds\n      } = this;\n      let closestBound = 0;\n      for (let i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    },\n    getBoundNeedMoving(value, closestBound) {\n      const {\n        bounds,\n        recent\n      } = this;\n      let boundNeedMoving = closestBound;\n      const isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    },\n    getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound() {\n      const {\n        bounds\n      } = this;\n      return bounds[bounds.length - 1];\n    },\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints() {\n      const {\n        marks,\n        step,\n        min,\n        max\n      } = this;\n      const cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        const pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (let point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        const points = Object.keys(pointsObject).map(parseFloat);\n        points.sort((a, b) => a - b);\n        this.internalPointsCache = {\n          marks,\n          step,\n          points\n        };\n      }\n      return this.internalPointsCache.points;\n    },\n    moveTo(value, isFromKeyboardEvent) {\n      const nextBounds = [...this.bounds];\n      const {\n        sHandle,\n        recent\n      } = this;\n      const handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      let nextHandle = handle;\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort((a, b) => a - b);\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, () => {\n          this.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles(bounds, handle) {\n      const value = bounds[handle];\n      const {\n        pushable\n      } = this;\n      const threshold = Number(pushable);\n      let direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      const nextHandle = handle + direction;\n      const diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle(bounds, handle, direction, amount) {\n      const originalValue = bounds[handle];\n      let currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    },\n    pushHandleOnePoint(bounds, handle, direction) {\n      const points = this.getPoints();\n      const pointIndex = points.indexOf(bounds[handle]);\n      const nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      const nextHandle = handle + direction;\n      const nextValue = points[nextPointIndex];\n      const {\n        pushable\n      } = this;\n      const threshold = Number(pushable);\n      const diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue(value) {\n      const {\n        sHandle,\n        bounds\n      } = this;\n      return trimAlignValue({\n        value,\n        handle: sHandle,\n        bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict(handle, val, _ref2) {\n      let {\n        allowCross,\n        pushable: thershold\n      } = _ref2;\n      const state = this.$data || {};\n      const {\n        bounds\n      } = state;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    },\n    getTrack(_ref3) {\n      let {\n        bounds,\n        prefixCls,\n        reverse,\n        vertical,\n        included,\n        offsets,\n        trackStyle\n      } = _ref3;\n      return bounds.slice(0, -1).map((_, index) => {\n        const i = index + 1;\n        const trackClassName = classNames({\n          [`${prefixCls}-track`]: true,\n          [`${prefixCls}-track-${i}`]: true\n        });\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider() {\n      const {\n        sHandle,\n        bounds,\n        prefixCls,\n        vertical,\n        included,\n        disabled,\n        min,\n        max,\n        reverse,\n        handle,\n        defaultHandle,\n        trackStyle,\n        handleStyle,\n        tabindex,\n        ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles\n      } = this;\n      const handleGenerator = handle || defaultHandle;\n      const offsets = bounds.map(v => this.calcOffset(v));\n      const handleClassName = `${prefixCls}-handle`;\n      const handles = bounds.map((v, i) => {\n        let mergedTabIndex = tabindex[i] || 0;\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n        const dragging = sHandle === i;\n        return handleGenerator({\n          class: classNames({\n            [handleClassName]: true,\n            [`${handleClassName}-${i + 1}`]: true,\n            [`${handleClassName}-dragging`]: dragging\n          }),\n          prefixCls,\n          vertical,\n          dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min,\n          max,\n          reverse,\n          disabled,\n          style: handleStyle[i],\n          ref: h => this.saveHandle(i, h),\n          onFocus: this.onFocus,\n          onBlur: this.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds,\n          prefixCls,\n          reverse,\n          vertical,\n          included,\n          offsets,\n          trackStyle\n        }),\n        handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,SAASC,WAAW,IAAIC,YAAY,QAAQ,KAAK;AACjD,OAAOC,UAAU,MAAM,wBAAwB;AAC/C,OAAOC,SAAS,IAAIC,aAAa,QAAQ,uBAAuB;AAChE,OAAOC,SAAS,MAAM,uBAAuB;AAC7C,SAASC,OAAO,QAAQ,wBAAwB;AAChD,OAAOC,KAAK,MAAM,gBAAgB;AAClC,OAAOC,YAAY,MAAM,uBAAuB;AAChD,OAAO,KAAKC,KAAK,MAAM,SAAS;AAChC,OAAOC,gBAAgB,MAAM,yCAAyC;AACtE,SAASC,eAAe,QAAQ,KAAK;AACrC,MAAMC,cAAc,GAAGC,IAAI,IAAI;EAC7B,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC,MAAM;IACNC;EACF,CAAC,GAAGJ,IAAI;EACR,MAAM;IACJK,UAAU;IACVC;EACF,CAAC,GAAGF,KAAK;EACT,MAAMG,SAAS,GAAGC,MAAM,CAACF,QAAQ,CAAC;EAClC,MAAMG,UAAU,GAAGb,KAAK,CAACc,kBAAkB,CAACT,KAAK,EAAEG,KAAK,CAAC;EACzD,IAAIO,cAAc,GAAGF,UAAU;EAC/B,IAAI,CAACJ,UAAU,IAAIH,MAAM,IAAI,IAAI,IAAIC,MAAM,KAAKS,SAAS,EAAE;IACzD,IAAIV,MAAM,GAAG,CAAC,IAAIO,UAAU,IAAIN,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS,EAAE;MAC9DI,cAAc,GAAGR,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS;IACjD;IACA,IAAIL,MAAM,GAAGC,MAAM,CAACU,MAAM,GAAG,CAAC,IAAIJ,UAAU,IAAIN,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS,EAAE;MAC9EI,cAAc,GAAGR,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS;IACjD;EACF;EACA,OAAOX,KAAK,CAACkB,oBAAoB,CAACH,cAAc,EAAEP,KAAK,CAAC;AAC1D,CAAC;AACD,MAAMW,UAAU,GAAG;EACjBC,YAAY,EAAE1B,SAAS,CAAC2B,OAAO,CAAC3B,SAAS,CAAC4B,MAAM,CAAC;EACjDjB,KAAK,EAAEX,SAAS,CAAC2B,OAAO,CAAC3B,SAAS,CAAC4B,MAAM,CAAC;EAC1CC,KAAK,EAAEX,MAAM;EACbF,QAAQ,EAAEf,aAAa,CAACD,SAAS,CAAC8B,SAAS,CAAC,CAAC9B,SAAS,CAAC+B,SAAS,EAAE/B,SAAS,CAAC4B,MAAM,CAAC,CAAC,CAAC;EACrFb,UAAU,EAAE;IACViB,IAAI,EAAEC,OAAO;IACbC,OAAO,EAAEZ;EACX,CAAC;EACDa,QAAQ,EAAE;IACRH,IAAI,EAAEC,OAAO;IACbC,OAAO,EAAEZ;EACX,CAAC;EACDc,OAAO,EAAE;IACPJ,IAAI,EAAEC,OAAO;IACbC,OAAO,EAAEZ;EACX,CAAC;EACDe,QAAQ,EAAErC,SAAS,CAAC2B,OAAO,CAAC3B,SAAS,CAAC4B,MAAM,CAAC;EAC7CU,SAAS,EAAEC,MAAM;EACjBC,GAAG,EAAEtB,MAAM;EACXuB,GAAG,EAAEvB,MAAM;EACXwB,SAAS,EAAE;IACTV,IAAI,EAAEC,OAAO;IACbC,OAAO,EAAEZ;EACX,CAAC;EACDqB,wBAAwB,EAAEC,KAAK;EAC/BC,6BAA6B,EAAED,KAAK;EACpCE,qCAAqC,EAAEF,KAAK;EAC5CG,cAAc,EAAE;IACdf,IAAI,EAAEC,OAAO;IACbC,OAAO,EAAEZ;EACX;AACF,CAAC;AACD,MAAM0B,KAAK,GAAGxC,eAAe,CAAC;EAC5ByC,YAAY,EAAE;IACZC,IAAI,EAAE;EACR,CAAC;EACDC,IAAI,EAAE,OAAO;EACbC,MAAM,EAAE,CAAClD,SAAS,CAAC;EACnBmD,YAAY,EAAE,KAAK;EACnBvC,KAAK,EAAEP,gBAAgB,CAACkB,UAAU,EAAE;IAClCI,KAAK,EAAE,CAAC;IACRd,UAAU,EAAE,IAAI;IAChBC,QAAQ,EAAE,KAAK;IACfqB,QAAQ,EAAE,EAAE;IACZU,cAAc,EAAE,KAAK;IACrBJ,wBAAwB,EAAE,EAAE;IAC5BE,6BAA6B,EAAE,EAAE;IACjCC,qCAAqC,EAAE;EACzC,CAAC,CAAC;EACFQ,KAAK,EAAE,CAAC,cAAc,EAAE,aAAa,EAAE,QAAQ,CAAC;EAChDC,WAAW,EAAE,OAAO;EACpBC,IAAIA,CAAA,EAAG;IACL,MAAM;MACJ3B,KAAK;MACLW,GAAG;MACHC;IACF,CAAC,GAAG,IAAI;IACR,MAAMgB,YAAY,GAAGb,KAAK,CAAC,GAAGA,KAAK,CAACf,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC6B,GAAG,CAAC,MAAMlB,GAAG,CAAC;IAC9D,MAAMd,YAAY,GAAGvB,OAAO,CAAC,IAAI,EAAE,cAAc,CAAC,GAAG,IAAI,CAACuB,YAAY,GAAG+B,YAAY;IACrF,IAAI;MACF9C;IACF,CAAC,GAAG,IAAI;IACR,IAAIA,KAAK,KAAKW,SAAS,EAAE;MACvBX,KAAK,GAAGe,YAAY;IACtB;IACA,MAAMb,MAAM,GAAGF,KAAK,CAAC+C,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKnD,cAAc,CAAC;MAChDE,KAAK,EAAEgD,CAAC;MACR/C,MAAM,EAAEgD,CAAC;MACT9C,KAAK,EAAE,IAAI,CAAC+C;IACd,CAAC,CAAC,CAAC;IACH,MAAMC,MAAM,GAAGjD,MAAM,CAAC,CAAC,CAAC,KAAK4B,GAAG,GAAG,CAAC,GAAG5B,MAAM,CAACU,MAAM,GAAG,CAAC;IACxD,OAAO;MACLwC,OAAO,EAAE,IAAI;MACbD,MAAM;MACNjD;IACF,CAAC;EACH,CAAC;EACDmD,KAAK,EAAE;IACLrD,KAAK,EAAE;MACLsD,OAAOA,CAACC,GAAG,EAAE;QACX,MAAM;UACJrD;QACF,CAAC,GAAG,IAAI;QACR,IAAI,CAACsD,cAAc,CAACD,GAAG,IAAIrD,MAAM,CAAC;MACpC,CAAC;MACDuD,IAAI,EAAE;IACR,CAAC;IACD5B,GAAGA,CAAA,EAAG;MACJ,MAAM;QACJ7B;MACF,CAAC,GAAG,IAAI;MACR,IAAI,CAACwD,cAAc,CAACxD,KAAK,IAAI,IAAI,CAACE,MAAM,CAAC;IAC3C,CAAC;IACD4B,GAAGA,CAAA,EAAG;MACJ,MAAM;QACJ9B;MACF,CAAC,GAAG,IAAI;MACR,IAAI,CAACwD,cAAc,CAACxD,KAAK,IAAI,IAAI,CAACE,MAAM,CAAC;IAC3C;EACF,CAAC;EACDwD,OAAO,EAAE;IACPF,cAAcA,CAACxD,KAAK,EAAE;MACpB,MAAM;QACJE;MACF,CAAC,GAAG,IAAI;MACR,IAAIyD,UAAU,GAAG3D,KAAK,CAAC+C,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKnD,cAAc,CAAC;QAClDE,KAAK,EAAEgD,CAAC;QACR/C,MAAM,EAAEgD,CAAC;QACT/C,MAAM;QACNC,KAAK,EAAE,IAAI,CAAC+C;MACd,CAAC,CAAC,CAAC;MACH,IAAIhD,MAAM,CAACU,MAAM,KAAK+C,UAAU,CAAC/C,MAAM,EAAE;QACvC,IAAI+C,UAAU,CAACC,KAAK,CAAC,CAACZ,CAAC,EAAEC,CAAC,KAAKD,CAAC,KAAK9C,MAAM,CAAC+C,CAAC,CAAC,CAAC,EAAE;UAC/C,OAAO,IAAI;QACb;MACF,CAAC,MAAM;QACLU,UAAU,GAAG3D,KAAK,CAAC+C,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKnD,cAAc,CAAC;UAC9CE,KAAK,EAAEgD,CAAC;UACR/C,MAAM,EAAEgD,CAAC;UACT9C,KAAK,EAAE,IAAI,CAAC+C;QACd,CAAC,CAAC,CAAC;MACL;MACA,IAAI,CAACW,QAAQ,CAAC;QACZ3D,MAAM,EAAEyD;MACV,CAAC,CAAC;MACF,IAAI3D,KAAK,CAAC8D,IAAI,CAACd,CAAC,IAAIrD,KAAK,CAACoE,iBAAiB,CAACf,CAAC,EAAE,IAAI,CAACE,MAAM,CAAC,CAAC,EAAE;QAC5D,MAAMc,SAAS,GAAGhE,KAAK,CAAC+C,GAAG,CAACC,CAAC,IAAI;UAC/B,OAAOrD,KAAK,CAACc,kBAAkB,CAACuC,CAAC,EAAE,IAAI,CAACE,MAAM,CAAC;QACjD,CAAC,CAAC;QACF,IAAI,CAACe,KAAK,CAAC,QAAQ,EAAED,SAAS,CAAC;MACjC;IACF,CAAC;IACDE,QAAQA,CAACC,KAAK,EAAE;MACd,MAAMC,eAAe,GAAG,CAAC5E,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC;MAC/C,IAAI4E,eAAe,EAAE;QACnB,IAAI,CAACP,QAAQ,CAACM,KAAK,CAAC;MACtB,CAAC,MAAM;QACL,MAAME,eAAe,GAAG,CAAC,CAAC;QAC1B,CAAC,SAAS,EAAE,QAAQ,CAAC,CAACC,OAAO,CAACC,IAAI,IAAI;UACpC,IAAIJ,KAAK,CAACI,IAAI,CAAC,KAAK5D,SAAS,EAAE;YAC7B0D,eAAe,CAACE,IAAI,CAAC,GAAGJ,KAAK,CAACI,IAAI,CAAC;UACrC;QACF,CAAC,CAAC;QACF,IAAIC,MAAM,CAACC,IAAI,CAACJ,eAAe,CAAC,CAACzD,MAAM,EAAE;UACvC,IAAI,CAACiD,QAAQ,CAACQ,eAAe,CAAC;QAChC;MACF;MACA,MAAMxB,IAAI,GAAG5D,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAACyF,KAAK,CAAC,EAAEP,KAAK,CAAC;MACtD,MAAMQ,YAAY,GAAG9B,IAAI,CAAC3C,MAAM;MAChC,IAAI,CAAC+D,KAAK,CAAC,QAAQ,EAAEU,YAAY,CAAC;IACpC,CAAC;IACDC,gBAAgBA,CAACC,QAAQ,EAAE;MACzB,MAAM3E,MAAM,GAAG,IAAI,CAAC4E,QAAQ,CAAC,CAAC;MAC9B,MAAM9E,KAAK,GAAG,IAAI,CAAC+E,cAAc,CAACF,QAAQ,CAAC;MAC3C,MAAMG,YAAY,GAAG,IAAI,CAACC,eAAe,CAACjF,KAAK,CAAC;MAChD,MAAMkF,KAAK,GAAG,IAAI,CAACC,kBAAkB,CAACnF,KAAK,EAAEgF,YAAY,CAAC;MAC1D,MAAMI,SAAS,GAAGlF,MAAM,CAACgF,KAAK,CAAC;MAC/B,IAAIlF,KAAK,KAAKoF,SAAS,EAAE,OAAO,IAAI;MACpC,MAAMzB,UAAU,GAAG,CAAC,GAAGzD,MAAM,CAAC;MAC9ByD,UAAU,CAACuB,KAAK,CAAC,GAAGlF,KAAK;MACzB,OAAO2D,UAAU;IACnB,CAAC;IACD0B,OAAOA,CAACR,QAAQ,EAAE;MAChB,MAAM;QACJ3E;MACF,CAAC,GAAG,IAAI;MACR,IAAI,CAAC+D,KAAK,CAAC,cAAc,EAAE/D,MAAM,CAAC;MAClC,MAAMF,KAAK,GAAG,IAAI,CAAC+E,cAAc,CAACF,QAAQ,CAAC;MAC3C,IAAI,CAACS,UAAU,GAAGtF,KAAK;MACvB,IAAI,CAACuF,aAAa,GAAGV,QAAQ;MAC7B,MAAMG,YAAY,GAAG,IAAI,CAACC,eAAe,CAACjF,KAAK,CAAC;MAChD,IAAI,CAACwF,oBAAoB,GAAG,IAAI,CAACL,kBAAkB,CAACnF,KAAK,EAAEgF,YAAY,CAAC;MACxE,IAAI,CAACnB,QAAQ,CAAC;QACZT,OAAO,EAAE,IAAI,CAACoC,oBAAoB;QAClCrC,MAAM,EAAE,IAAI,CAACqC;MACf,CAAC,CAAC;MACF,MAAMJ,SAAS,GAAGlF,MAAM,CAAC,IAAI,CAACsF,oBAAoB,CAAC;MACnD,IAAIxF,KAAK,KAAKoF,SAAS,EAAE;MACzB,MAAMzB,UAAU,GAAG,CAAC,GAAGzD,MAAM,CAAC;MAC9ByD,UAAU,CAAC,IAAI,CAAC6B,oBAAoB,CAAC,GAAGxF,KAAK;MAC7C,IAAI,CAACkE,QAAQ,CAAC;QACZhE,MAAM,EAAEyD;MACV,CAAC,CAAC;IACJ,CAAC;IACD8B,KAAKA,CAACC,KAAK,EAAE;MACX,MAAM;QACJtC;MACF,CAAC,GAAG,IAAI;MACR,IAAI,CAACuC,oBAAoB,CAAC,CAAC;MAC3B,IAAI,CAACvC,OAAO,EAAE;QACZ,IAAI,CAACwC,SAAS,GAAG,KAAK;MACxB;MACA,IAAIxC,OAAO,KAAK,IAAI,IAAIsC,KAAK,EAAE;QAC7B,IAAI,CAACzB,KAAK,CAAC,aAAa,EAAE,IAAI,CAAC/D,MAAM,CAAC;MACxC;MACA,IAAI,CAAC2D,QAAQ,CAAC;QACZT,OAAO,EAAE;MACX,CAAC,CAAC;IACJ,CAAC;IACDyC,MAAMA,CAACC,CAAC,EAAEjB,QAAQ,EAAEe,SAAS,EAAEG,WAAW,EAAE;MAC1CpG,KAAK,CAACqG,UAAU,CAACF,CAAC,CAAC;MACnB,MAAM;QACJpB,KAAK,EAAEP,KAAK;QACZjB,MAAM,EAAE/C;MACV,CAAC,GAAG,IAAI;MACR,MAAM8F,QAAQ,GAAG9F,KAAK,CAAC2B,GAAG,IAAI,GAAG;MACjC,MAAMoE,QAAQ,GAAG/F,KAAK,CAAC0B,GAAG,IAAI,CAAC;MAC/B,IAAI+D,SAAS,EAAE;QACb,IAAIO,GAAG,GAAGhG,KAAK,CAACiG,QAAQ,GAAG,CAACvB,QAAQ,GAAGA,QAAQ;QAC/CsB,GAAG,GAAGhG,KAAK,CAACsB,OAAO,GAAG,CAAC0E,GAAG,GAAGA,GAAG;QAChC,MAAMrE,GAAG,GAAGmE,QAAQ,GAAGI,IAAI,CAACvE,GAAG,CAAC,GAAGiE,WAAW,CAAC;QAC/C,MAAMlE,GAAG,GAAGqE,QAAQ,GAAGG,IAAI,CAACxE,GAAG,CAAC,GAAGkE,WAAW,CAAC;QAC/C,MAAMO,KAAK,GAAGD,IAAI,CAACxE,GAAG,CAACwE,IAAI,CAACvE,GAAG,CAACqE,GAAG,IAAI,IAAI,CAACI,eAAe,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE1E,GAAG,CAAC,EAAEC,GAAG,CAAC;QAChF,MAAM6B,UAAU,GAAGoC,WAAW,CAAChD,GAAG,CAACC,CAAC,IAAIqD,IAAI,CAACG,KAAK,CAACH,IAAI,CAACvE,GAAG,CAACuE,IAAI,CAACxE,GAAG,CAACmB,CAAC,GAAGsD,KAAK,EAAEL,QAAQ,CAAC,EAAEC,QAAQ,CAAC,CAAC,CAAC;QACtG,IAAI/B,KAAK,CAACjE,MAAM,CAAC6C,GAAG,CAAC,CAAC0D,CAAC,EAAExD,CAAC,KAAKwD,CAAC,KAAK9C,UAAU,CAACV,CAAC,CAAC,CAAC,CAACa,IAAI,CAAC2C,CAAC,IAAI,CAACA,CAAC,CAAC,EAAE;UACjE,IAAI,CAACvC,QAAQ,CAAC;YACZhE,MAAM,EAAEyD;UACV,CAAC,CAAC;QACJ;QACA;MACF;MACA,MAAM;QACJzD,MAAM;QACNkD;MACF,CAAC,GAAG,IAAI;MACR,MAAMpD,KAAK,GAAG,IAAI,CAAC+E,cAAc,CAACF,QAAQ,CAAC;MAC3C,MAAM6B,QAAQ,GAAGxG,MAAM,CAACkD,OAAO,CAAC;MAChC,IAAIpD,KAAK,KAAK0G,QAAQ,EAAE;MACxB,IAAI,CAACC,MAAM,CAAC3G,KAAK,CAAC;IACpB,CAAC;IACD4G,UAAUA,CAACd,CAAC,EAAE;MACZ,MAAM;QACJrE,OAAO;QACP2E;MACF,CAAC,GAAG,IAAI,CAAClD,MAAM;MACf,MAAM2D,YAAY,GAAGlH,KAAK,CAACmH,uBAAuB,CAAChB,CAAC,EAAEM,QAAQ,EAAE3E,OAAO,CAAC;MACxE,IAAIoF,YAAY,EAAE;QAChBlH,KAAK,CAACqG,UAAU,CAACF,CAAC,CAAC;QACnB,MAAM;UACJ5F,MAAM;UACNkD;QACF,CAAC,GAAG,IAAI;QACR,MAAMsD,QAAQ,GAAGxG,MAAM,CAACkD,OAAO,KAAK,IAAI,GAAG,IAAI,CAACD,MAAM,GAAGC,OAAO,CAAC;QACjE,MAAM2D,YAAY,GAAGF,YAAY,CAACH,QAAQ,EAAE,IAAI,CAACxD,MAAM,CAAC;QACxD,MAAMlD,KAAK,GAAGF,cAAc,CAAC;UAC3BE,KAAK,EAAE+G,YAAY;UACnB9G,MAAM,EAAEmD,OAAO;UACflD,MAAM;UACNC,KAAK,EAAE,IAAI,CAAC+C;QACd,CAAC,CAAC;QACF,IAAIlD,KAAK,KAAK0G,QAAQ,EAAE;QACxB,MAAMM,mBAAmB,GAAG,IAAI;QAChC,IAAI,CAACL,MAAM,CAAC3G,KAAK,EAAEgH,mBAAmB,CAAC;MACzC;IACF,CAAC;IACD/B,eAAeA,CAACjF,KAAK,EAAE;MACrB,MAAM;QACJE;MACF,CAAC,GAAG,IAAI;MACR,IAAI8E,YAAY,GAAG,CAAC;MACpB,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/C,MAAM,CAACU,MAAM,GAAG,CAAC,EAAEqC,CAAC,IAAI,CAAC,EAAE;QAC7C,IAAIjD,KAAK,IAAIE,MAAM,CAAC+C,CAAC,CAAC,EAAE;UACtB+B,YAAY,GAAG/B,CAAC;QAClB;MACF;MACA,IAAIoD,IAAI,CAACY,GAAG,CAAC/G,MAAM,CAAC8E,YAAY,GAAG,CAAC,CAAC,GAAGhF,KAAK,CAAC,GAAGqG,IAAI,CAACY,GAAG,CAAC/G,MAAM,CAAC8E,YAAY,CAAC,GAAGhF,KAAK,CAAC,EAAE;QACvFgF,YAAY,IAAI,CAAC;MACnB;MACA,OAAOA,YAAY;IACrB,CAAC;IACDG,kBAAkBA,CAACnF,KAAK,EAAEgF,YAAY,EAAE;MACtC,MAAM;QACJ9E,MAAM;QACNiD;MACF,CAAC,GAAG,IAAI;MACR,IAAI+D,eAAe,GAAGlC,YAAY;MAClC,MAAMmC,gBAAgB,GAAGjH,MAAM,CAAC8E,YAAY,GAAG,CAAC,CAAC,KAAK9E,MAAM,CAAC8E,YAAY,CAAC;MAC1E,IAAImC,gBAAgB,IAAIjH,MAAM,CAACiD,MAAM,CAAC,KAAKjD,MAAM,CAAC8E,YAAY,CAAC,EAAE;QAC/DkC,eAAe,GAAG/D,MAAM;MAC1B;MACA,IAAIgE,gBAAgB,IAAInH,KAAK,KAAKE,MAAM,CAAC8E,YAAY,GAAG,CAAC,CAAC,EAAE;QAC1DkC,eAAe,GAAGlH,KAAK,GAAGE,MAAM,CAAC8E,YAAY,GAAG,CAAC,CAAC,GAAGA,YAAY,GAAGA,YAAY,GAAG,CAAC;MACtF;MACA,OAAOkC,eAAe;IACxB,CAAC;IACDE,aAAaA,CAAA,EAAG;MACd,OAAO,IAAI,CAAClH,MAAM,CAAC,CAAC,CAAC;IACvB,CAAC;IACDmH,aAAaA,CAAA,EAAG;MACd,MAAM;QACJnH;MACF,CAAC,GAAG,IAAI;MACR,OAAOA,MAAM,CAACA,MAAM,CAACU,MAAM,GAAG,CAAC,CAAC;IAClC,CAAC;IACD;AACJ;AACA;AACA;IACI0G,SAASA,CAAA,EAAG;MACV,MAAM;QACJC,KAAK;QACLC,IAAI;QACJ3F,GAAG;QACHC;MACF,CAAC,GAAG,IAAI;MACR,MAAM2F,KAAK,GAAG,IAAI,CAACC,mBAAmB;MACtC,IAAI,CAACD,KAAK,IAAIA,KAAK,CAACF,KAAK,KAAKA,KAAK,IAAIE,KAAK,CAACD,IAAI,KAAKA,IAAI,EAAE;QAC1D,MAAMG,YAAY,GAAG1I,QAAQ,CAAC,CAAC,CAAC,EAAEsI,KAAK,CAAC;QACxC,IAAIC,IAAI,KAAK,IAAI,EAAE;UACjB,KAAK,IAAII,KAAK,GAAG/F,GAAG,EAAE+F,KAAK,IAAI9F,GAAG,EAAE8F,KAAK,IAAIJ,IAAI,EAAE;YACjDG,YAAY,CAACC,KAAK,CAAC,GAAGA,KAAK;UAC7B;QACF;QACA,MAAMC,MAAM,GAAGrD,MAAM,CAACC,IAAI,CAACkD,YAAY,CAAC,CAAC5E,GAAG,CAAC+E,UAAU,CAAC;QACxDD,MAAM,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;QAC5B,IAAI,CAACP,mBAAmB,GAAG;UACzBH,KAAK;UACLC,IAAI;UACJK;QACF,CAAC;MACH;MACA,OAAO,IAAI,CAACH,mBAAmB,CAACG,MAAM;IACxC,CAAC;IACDlB,MAAMA,CAAC3G,KAAK,EAAEgH,mBAAmB,EAAE;MACjC,MAAMrD,UAAU,GAAG,CAAC,GAAG,IAAI,CAACzD,MAAM,CAAC;MACnC,MAAM;QACJkD,OAAO;QACPD;MACF,CAAC,GAAG,IAAI;MACR,MAAMlD,MAAM,GAAGmD,OAAO,KAAK,IAAI,GAAGD,MAAM,GAAGC,OAAO;MAClDO,UAAU,CAAC1D,MAAM,CAAC,GAAGD,KAAK;MAC1B,IAAIkI,UAAU,GAAGjI,MAAM;MACvB,IAAI,IAAI,CAACiD,MAAM,CAAC7C,QAAQ,KAAK,KAAK,EAAE;QAClC,IAAI,CAAC8H,sBAAsB,CAACxE,UAAU,EAAEuE,UAAU,CAAC;MACrD,CAAC,MAAM,IAAI,IAAI,CAAChF,MAAM,CAAC9C,UAAU,EAAE;QACjCuD,UAAU,CAACoE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;QAChCC,UAAU,GAAGvE,UAAU,CAACyE,OAAO,CAACpI,KAAK,CAAC;MACxC;MACA,IAAI,CAACkE,QAAQ,CAAC;QACZf,MAAM,EAAE+E,UAAU;QAClB9E,OAAO,EAAE8E,UAAU;QACnBhI,MAAM,EAAEyD;MACV,CAAC,CAAC;MACF,IAAIqD,mBAAmB,EAAE;QACvB;QACA;QACA;QACA;QACA,IAAI,CAAC/C,KAAK,CAAC,aAAa,EAAEN,UAAU,CAAC;QACrC,IAAI,CAACE,QAAQ,CAAC,CAAC,CAAC,EAAE,MAAM;UACtB,IAAI,CAACwE,WAAW,CAACH,UAAU,CAAC,CAACI,KAAK,CAAC,CAAC;QACtC,CAAC,CAAC;QACF,IAAI,CAAC7C,KAAK,CAAC,CAAC;MACd;IACF,CAAC;IACD0C,sBAAsBA,CAACjI,MAAM,EAAED,MAAM,EAAE;MACrC,MAAMD,KAAK,GAAGE,MAAM,CAACD,MAAM,CAAC;MAC5B,MAAM;QACJI;MACF,CAAC,GAAG,IAAI;MACR,MAAMkI,SAAS,GAAGhI,MAAM,CAACF,QAAQ,CAAC;MAClC,IAAImI,SAAS,GAAG,CAAC;MACjB,IAAItI,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGD,KAAK,GAAGuI,SAAS,EAAE;QAC1CC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;MAClB;;MAEA,IAAIxI,KAAK,GAAGE,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGsI,SAAS,EAAE;QAC1CC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;MAClB;;MAEA,IAAIA,SAAS,KAAK,CAAC,EAAE;QACnB;MACF;MACA,MAAMN,UAAU,GAAGjI,MAAM,GAAGuI,SAAS;MACrC,MAAMC,UAAU,GAAGD,SAAS,IAAItI,MAAM,CAACgI,UAAU,CAAC,GAAGlI,KAAK,CAAC;MAC3D,IAAI,CAAC,IAAI,CAAC0I,UAAU,CAACxI,MAAM,EAAEgI,UAAU,EAAEM,SAAS,EAAED,SAAS,GAAGE,UAAU,CAAC,EAAE;QAC3E;QACAvI,MAAM,CAACD,MAAM,CAAC,GAAGC,MAAM,CAACgI,UAAU,CAAC,GAAGM,SAAS,GAAGD,SAAS;MAC7D;IACF,CAAC;IACDG,UAAUA,CAACxI,MAAM,EAAED,MAAM,EAAEuI,SAAS,EAAEG,MAAM,EAAE;MAC5C,MAAMC,aAAa,GAAG1I,MAAM,CAACD,MAAM,CAAC;MACpC,IAAI4I,YAAY,GAAG3I,MAAM,CAACD,MAAM,CAAC;MACjC,OAAOuI,SAAS,IAAIK,YAAY,GAAGD,aAAa,CAAC,GAAGD,MAAM,EAAE;QAC1D,IAAI,CAAC,IAAI,CAACG,kBAAkB,CAAC5I,MAAM,EAAED,MAAM,EAAEuI,SAAS,CAAC,EAAE;UACvD;UACA;UACAtI,MAAM,CAACD,MAAM,CAAC,GAAG2I,aAAa;UAC9B,OAAO,KAAK;QACd;QACAC,YAAY,GAAG3I,MAAM,CAACD,MAAM,CAAC;MAC/B;MACA;MACA,OAAO,IAAI;IACb,CAAC;IACD6I,kBAAkBA,CAAC5I,MAAM,EAAED,MAAM,EAAEuI,SAAS,EAAE;MAC5C,MAAMX,MAAM,GAAG,IAAI,CAACP,SAAS,CAAC,CAAC;MAC/B,MAAMyB,UAAU,GAAGlB,MAAM,CAACO,OAAO,CAAClI,MAAM,CAACD,MAAM,CAAC,CAAC;MACjD,MAAM+I,cAAc,GAAGD,UAAU,GAAGP,SAAS;MAC7C,IAAIQ,cAAc,IAAInB,MAAM,CAACjH,MAAM,IAAIoI,cAAc,GAAG,CAAC,EAAE;QACzD;QACA,OAAO,KAAK;MACd;MACA,MAAMd,UAAU,GAAGjI,MAAM,GAAGuI,SAAS;MACrC,MAAMS,SAAS,GAAGpB,MAAM,CAACmB,cAAc,CAAC;MACxC,MAAM;QACJ3I;MACF,CAAC,GAAG,IAAI;MACR,MAAMkI,SAAS,GAAGhI,MAAM,CAACF,QAAQ,CAAC;MAClC,MAAMoI,UAAU,GAAGD,SAAS,IAAItI,MAAM,CAACgI,UAAU,CAAC,GAAGe,SAAS,CAAC;MAC/D,IAAI,CAAC,IAAI,CAACP,UAAU,CAACxI,MAAM,EAAEgI,UAAU,EAAEM,SAAS,EAAED,SAAS,GAAGE,UAAU,CAAC,EAAE;QAC3E;QACA,OAAO,KAAK;MACd;MACA;MACAvI,MAAM,CAACD,MAAM,CAAC,GAAGgJ,SAAS;MAC1B,OAAO,IAAI;IACb,CAAC;IACDnJ,cAAcA,CAACE,KAAK,EAAE;MACpB,MAAM;QACJoD,OAAO;QACPlD;MACF,CAAC,GAAG,IAAI;MACR,OAAOJ,cAAc,CAAC;QACpBE,KAAK;QACLC,MAAM,EAAEmD,OAAO;QACflD,MAAM;QACNC,KAAK,EAAE,IAAI,CAAC+C;MACd,CAAC,CAAC;IACJ,CAAC;IACDgG,sBAAsBA,CAACjJ,MAAM,EAAEsD,GAAG,EAAE4F,KAAK,EAAE;MACzC,IAAI;QACF/I,UAAU;QACVC,QAAQ,EAAEC;MACZ,CAAC,GAAG6I,KAAK;MACT,MAAMhF,KAAK,GAAG,IAAI,CAACO,KAAK,IAAI,CAAC,CAAC;MAC9B,MAAM;QACJxE;MACF,CAAC,GAAGiE,KAAK;MACTlE,MAAM,GAAGA,MAAM,KAAKU,SAAS,GAAGwD,KAAK,CAACf,OAAO,GAAGnD,MAAM;MACtDK,SAAS,GAAGC,MAAM,CAACD,SAAS,CAAC;MAC7B;MACA,IAAI,CAACF,UAAU,IAAIH,MAAM,IAAI,IAAI,IAAIC,MAAM,KAAKS,SAAS,EAAE;QACzD,IAAIV,MAAM,GAAG,CAAC,IAAIsD,GAAG,IAAIrD,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS,EAAE;UACvD,OAAOJ,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS;QACvC;QACA,IAAIL,MAAM,GAAGC,MAAM,CAACU,MAAM,GAAG,CAAC,IAAI2C,GAAG,IAAIrD,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS,EAAE;UACvE,OAAOJ,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,GAAGK,SAAS;QACvC;MACF;MACA;MACA,OAAOiD,GAAG;IACZ,CAAC;IACD6F,QAAQA,CAACC,KAAK,EAAE;MACd,IAAI;QACFnJ,MAAM;QACNyB,SAAS;QACTF,OAAO;QACP2E,QAAQ;QACRkD,QAAQ;QACRC,OAAO;QACPC;MACF,CAAC,GAAGH,KAAK;MACT,OAAOnJ,MAAM,CAACuJ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC1G,GAAG,CAAC,CAAC2G,CAAC,EAAExE,KAAK,KAAK;QAC3C,MAAMjC,CAAC,GAAGiC,KAAK,GAAG,CAAC;QACnB,MAAMyE,cAAc,GAAGvK,UAAU,CAAC;UAChC,CAAE,GAAEuC,SAAU,QAAO,GAAG,IAAI;UAC5B,CAAE,GAAEA,SAAU,UAASsB,CAAE,EAAC,GAAG;QAC/B,CAAC,CAAC;QACF,OAAO9D,YAAY,CAACM,KAAK,EAAE;UACzB,OAAO,EAAEkK,cAAc;UACvB,UAAU,EAAEvD,QAAQ;UACpB,SAAS,EAAE3E,OAAO;UAClB,UAAU,EAAE6H,QAAQ;UACpB,QAAQ,EAAEC,OAAO,CAACtG,CAAC,GAAG,CAAC,CAAC;UACxB,QAAQ,EAAEsG,OAAO,CAACtG,CAAC,CAAC,GAAGsG,OAAO,CAACtG,CAAC,GAAG,CAAC,CAAC;UACrC,OAAO,EAAEuG,UAAU,CAACtE,KAAK,CAAC;UAC1B,KAAK,EAAEjC;QACT,CAAC,EAAE,IAAI,CAAC;MACV,CAAC,CAAC;IACJ,CAAC;IACD2G,YAAYA,CAAA,EAAG;MACb,MAAM;QACJxG,OAAO;QACPlD,MAAM;QACNyB,SAAS;QACTyE,QAAQ;QACRkD,QAAQ;QACR9H,QAAQ;QACRK,GAAG;QACHC,GAAG;QACHL,OAAO;QACPxB,MAAM;QACN4J,aAAa;QACbL,UAAU;QACVM,WAAW;QACXpI,QAAQ;QACRM,wBAAwB;QACxBE,6BAA6B;QAC7BC;MACF,CAAC,GAAG,IAAI;MACR,MAAM4H,eAAe,GAAG9J,MAAM,IAAI4J,aAAa;MAC/C,MAAMN,OAAO,GAAGrJ,MAAM,CAAC6C,GAAG,CAACC,CAAC,IAAI,IAAI,CAACgH,UAAU,CAAChH,CAAC,CAAC,CAAC;MACnD,MAAMiH,eAAe,GAAI,GAAEtI,SAAU,SAAQ;MAC7C,MAAMuI,OAAO,GAAGhK,MAAM,CAAC6C,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;QACnC,IAAIkH,cAAc,GAAGzI,QAAQ,CAACuB,CAAC,CAAC,IAAI,CAAC;QACrC,IAAIzB,QAAQ,IAAIE,QAAQ,CAACuB,CAAC,CAAC,KAAK,IAAI,EAAE;UACpCkH,cAAc,GAAG,IAAI;QACvB;QACA,MAAMC,QAAQ,GAAGhH,OAAO,KAAKH,CAAC;QAC9B,OAAO8G,eAAe,CAAC;UACrBM,KAAK,EAAEjL,UAAU,CAAC;YAChB,CAAC6K,eAAe,GAAG,IAAI;YACvB,CAAE,GAAEA,eAAgB,IAAGhH,CAAC,GAAG,CAAE,EAAC,GAAG,IAAI;YACrC,CAAE,GAAEgH,eAAgB,WAAU,GAAGG;UACnC,CAAC,CAAC;UACFzI,SAAS;UACTyE,QAAQ;UACRgE,QAAQ;UACRE,MAAM,EAAEf,OAAO,CAACtG,CAAC,CAAC;UAClBjD,KAAK,EAAEgD,CAAC;UACRkC,KAAK,EAAEjC,CAAC;UACRvB,QAAQ,EAAEyI,cAAc;UACxBtI,GAAG;UACHC,GAAG;UACHL,OAAO;UACPD,QAAQ;UACR+I,KAAK,EAAET,WAAW,CAAC7G,CAAC,CAAC;UACrBuH,GAAG,EAAEC,CAAC,IAAI,IAAI,CAACC,UAAU,CAACzH,CAAC,EAAEwH,CAAC,CAAC;UAC/BE,OAAO,EAAE,IAAI,CAACA,OAAO;UACrBC,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBC,SAAS,EAAE7I,wBAAwB,CAACiB,CAAC,CAAC;UACtC6H,cAAc,EAAE5I,6BAA6B,CAACe,CAAC,CAAC;UAChD8H,sBAAsB,EAAE5I,qCAAqC,CAACc,CAAC;QACjE,CAAC,CAAC;MACJ,CAAC,CAAC;MACF,OAAO;QACL+H,MAAM,EAAE,IAAI,CAAC5B,QAAQ,CAAC;UACpBlJ,MAAM;UACNyB,SAAS;UACTF,OAAO;UACP2E,QAAQ;UACRkD,QAAQ;UACRC,OAAO;UACPC;QACF,CAAC,CAAC;QACFU;MACF,CAAC;IACH;EACF;AACF,CAAC,CAAC;AACF,eAAexK,YAAY,CAAC2C,KAAK,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}