{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport omit from '../_util/omit';\nimport useStyle from './style';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport const affixProps = () => ({\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: Number,\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: Number,\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: {\n    type: Function,\n    default: getDefaultTarget\n  },\n  prefixCls: String,\n  /** 固定状态改变时触发的回调函数 */\n  onChange: Function,\n  onTestUpdatePosition: Function\n});\nconst Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  inheritAttrs: false,\n  props: affixProps(),\n  setup(props, _ref) {\n    let {\n      slots,\n      emit,\n      expose,\n      attrs\n    } = _ref;\n    const placeholderNode = shallowRef();\n    const fixedNode = shallowRef();\n    const state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    const currentInstance = getCurrentInstance();\n    const offsetTop = computed(() => {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    const offsetBottom = computed(() => props.offsetBottom);\n    const measure = () => {\n      const {\n        status,\n        lastAffix\n      } = state;\n      const {\n        target\n      } = props;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      const targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      const newState = {\n        status: AffixStatus.None\n      };\n      const placeholderRect = getTargetRect(placeholderNode.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        const width = `${placeholderRect.width}px`;\n        const height = `${placeholderRect.height}px`;\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width,\n          height\n        };\n        newState.placeholderStyle = {\n          width,\n          height\n        };\n      } else if (fixedBottom !== undefined) {\n        const width = `${placeholderRect.width}px`;\n        const height = `${placeholderRect.height}px`;\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width,\n          height\n        };\n        newState.placeholderStyle = {\n          width,\n          height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    const prepareMeasure = () => {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    const updatePosition = throttleByAnimationFrame(() => {\n      prepareMeasure();\n    });\n    const lazyUpdatePosition = throttleByAnimationFrame(() => {\n      const {\n        target\n      } = props;\n      const {\n        affixStyle\n      } = state;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        const targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          const targetRect = getTargetRect(targetNode);\n          const placeholderRect = getTargetRect(placeholderNode.value);\n          const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition,\n      lazyUpdatePosition\n    });\n    watch(() => props.target, val => {\n      const newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(() => [props.offsetTop, props.offsetBottom], updatePosition);\n    onMounted(() => {\n      const {\n        target\n      } = props;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(() => {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(() => {\n      measure();\n    });\n    onUnmounted(() => {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    const {\n      prefixCls\n    } = useConfigInject('affix', props);\n    const [wrapSSR, hashId] = useStyle(prefixCls);\n    return () => {\n      var _a;\n      const {\n        affixStyle,\n        placeholderStyle\n      } = state;\n      const className = classNames({\n        [prefixCls.value]: affixStyle,\n        [hashId.value]: true\n      });\n      const restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return wrapSSR(_createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: () => [_createVNode(\"div\", _objectSpread(_objectSpread(_objectSpread({}, restProps), attrs), {}, {\n          \"ref\": placeholderNode\n        }), [affixStyle && _createVNode(\"div\", {\n          \"style\": placeholderStyle,\n          \"aria-hidden\": \"true\"\n        }, null), _createVNode(\"div\", {\n          \"class\": className,\n          \"ref\": fixedNode,\n          \"style\": affixStyle\n        }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])]\n      }));\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","defineComponent","shallowRef","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","useStyle","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","default","prefixCls","String","onChange","onTestUpdatePosition","Affix","compatConfig","MODE","name","inheritAttrs","props","setup","_ref","slots","emit","expose","attrs","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","position","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","wrapSSR","hashId","_a","className","restProps","call"],"sources":["/Users/lpl/工作/Teamsupport/develop_help/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, shallowRef, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../config-provider/hooks/useConfigInject';\nimport omit from '../_util/omit';\nimport useStyle from './style';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport const affixProps = () => ({\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: Number,\n  /** 距离窗口底部达到指定偏移量后触发 */\n  offsetBottom: Number,\n  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n  target: {\n    type: Function,\n    default: getDefaultTarget\n  },\n  prefixCls: String,\n  /** 固定状态改变时触发的回调函数 */\n  onChange: Function,\n  onTestUpdatePosition: Function\n});\nconst Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  inheritAttrs: false,\n  props: affixProps(),\n  setup(props, _ref) {\n    let {\n      slots,\n      emit,\n      expose,\n      attrs\n    } = _ref;\n    const placeholderNode = shallowRef();\n    const fixedNode = shallowRef();\n    const state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    const currentInstance = getCurrentInstance();\n    const offsetTop = computed(() => {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    const offsetBottom = computed(() => props.offsetBottom);\n    const measure = () => {\n      const {\n        status,\n        lastAffix\n      } = state;\n      const {\n        target\n      } = props;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      const targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      const newState = {\n        status: AffixStatus.None\n      };\n      const placeholderRect = getTargetRect(placeholderNode.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      if (fixedTop !== undefined) {\n        const width = `${placeholderRect.width}px`;\n        const height = `${placeholderRect.height}px`;\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width,\n          height\n        };\n        newState.placeholderStyle = {\n          width,\n          height\n        };\n      } else if (fixedBottom !== undefined) {\n        const width = `${placeholderRect.width}px`;\n        const height = `${placeholderRect.height}px`;\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width,\n          height\n        };\n        newState.placeholderStyle = {\n          width,\n          height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    const prepareMeasure = () => {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    const updatePosition = throttleByAnimationFrame(() => {\n      prepareMeasure();\n    });\n    const lazyUpdatePosition = throttleByAnimationFrame(() => {\n      const {\n        target\n      } = props;\n      const {\n        affixStyle\n      } = state;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        const targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          const targetRect = getTargetRect(targetNode);\n          const placeholderRect = getTargetRect(placeholderNode.value);\n          const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition,\n      lazyUpdatePosition\n    });\n    watch(() => props.target, val => {\n      const newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(() => [props.offsetTop, props.offsetBottom], updatePosition);\n    onMounted(() => {\n      const {\n        target\n      } = props;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(() => {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(() => {\n      measure();\n    });\n    onUnmounted(() => {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    const {\n      prefixCls\n    } = useConfigInject('affix', props);\n    const [wrapSSR, hashId] = useStyle(prefixCls);\n    return () => {\n      var _a;\n      const {\n        affixStyle,\n        placeholderStyle\n      } = state;\n      const className = classNames({\n        [prefixCls.value]: affixStyle,\n        [hashId.value]: true\n      });\n      const restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return wrapSSR(_createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: () => [_createVNode(\"div\", _objectSpread(_objectSpread(_objectSpread({}, restProps), attrs), {}, {\n          \"ref\": placeholderNode\n        }), [affixStyle && _createVNode(\"div\", {\n          \"style\": placeholderStyle,\n          \"aria-hidden\": \"true\"\n        }, null), _createVNode(\"div\", {\n          \"class\": className,\n          \"ref\": fixedNode,\n          \"style\": affixStyle\n        }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])]\n      }));\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}